/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <inttypes.h>

#include <karbonit/forwdecl.h>
#include <karbonit/stdx/unique_id.h>
#include <karbonit/archive/encode_async.h>
#include <karbonit/archive/pack.h>
#include <karbonit/archive/strid_it.h>
#include <karbonit/archive/internal.h>
#include <karbonit/archive/query.h>
#include <karbonit/archive/cache.h>
#include <karbonit/archive.h>
#include <karbonit/archive/encode_sync.h>
#include <karbonit/stdinc.h>
#include <karbonit/mem/memblock.h>
#include <karbonit/mem/memfile.h>
#include <karbonit/archive/huffman.h>
#include <karbonit/archive.h>

#define WRITE_PRIMITIVE_VALUES(memfile, values_vec, type)                                                              \
{                                                                                                                      \
    type *values = VEC_ALL(values_vec, type);                                                                \
    MEMFILE_WRITE(memfile, values, values_vec->num_elems * sizeof(type));                                       \
}

#define WRITE_ARRAY_VALUES(memfile, values_vec, type)                                                                  \
{                                                                                                                      \
    for (u32 i = 0; i < values_vec->num_elems; i++) {                                                             \
        vec ofType(type) *nested_values = VEC_GET(values_vec, i, vec);                     \
        WRITE_PRIMITIVE_VALUES(memfile, nested_values, type);                                                          \
    }                                                                                                                  \
}

#define PRINT_SIMPLE_PROPS(file, memfile, offset, nesting_level, value_type, type_string, format_string)               \
{                                                                                                                      \
    prop_header *prop_header = MEMFILE_READ_TYPE(memfile, struct prop_header);             \
    archive_field_sid_t *keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop_header->num_entries *          \
                                   sizeof(archive_field_sid_t));                                                        \
    value_type *values = (value_type *) MEMFILE_READ(memfile, prop_header->num_entries * sizeof(value_type));   \
    fprintf(file, "0x%04x ", (unsigned) offset);                                                                       \
    INTENT_LINE(nesting_level)                                                                                         \
    fprintf(file, "[marker: %c (" type_string ")] [num_entries: %d] [", entryMarker, prop_header->num_entries);        \
    for (u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
        fprintf(file, "key: %"PRIu64"%s", keys[i], i + 1 < prop_header->num_entries ? ", " : "");                      \
    }                                                                                                                  \
    fprintf(file, "] [");                                                                                              \
    for (u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
      fprintf(file, "value: "format_string"%s", values[i], i + 1 < prop_header->num_entries ? ", " : "");              \
    }                                                                                                                  \
    fprintf(file, "]\n");                                                                                              \
}

#define PRINT_ARRAY_PROPS(memfile, offset, nesting_level, entryMarker, type, type_string, format_string)               \
{                                                                                                                      \
    prop_header *prop_header = MEMFILE_READ_TYPE(memfile, struct prop_header);             \
                                                                                                                       \
    archive_field_sid_t *keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop_header->num_entries *          \
                                        sizeof(archive_field_sid_t));                                                   \
    u32 *array_lengths;                                                                                           \
                                                                                                                       \
    fprintf(file, "0x%04x ", (unsigned) offset);                                                                       \
    INTENT_LINE(nesting_level)                                                                                         \
    fprintf(file, "[marker: %c ("type_string")] [num_entries: %d] [", entryMarker, prop_header->num_entries);          \
                                                                                                                       \
    for (u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
        fprintf(file, "key: %"PRIu64"%s", keys[i], i + 1 < prop_header->num_entries ? ", " : "");                      \
    }                                                                                                                  \
    fprintf(file, "] [");                                                                                              \
                                                                                                                       \
    array_lengths = (u32 *) MEMFILE_READ(memfile, prop_header->num_entries * sizeof(u32));            \
                                                                                                                       \
    for (u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
        fprintf(file, "num_entries: %d%s", array_lengths[i], i + 1 < prop_header->num_entries ? ", " : "");            \
    }                                                                                                                  \
                                                                                                                       \
    fprintf(file, "] [");                                                                                              \
                                                                                                                       \
    for (u32 array_idx = 0; array_idx < prop_header->num_entries; array_idx++) {                                  \
        type *values = (type *) MEMFILE_READ(memfile, array_lengths[array_idx] * sizeof(type));                 \
        fprintf(file, "[");                                                                                            \
        for (u32 i = 0; i < array_lengths[array_idx]; i++) {                                                      \
            fprintf(file, "value: "format_string"%s", values[i], i + 1 < array_lengths[array_idx] ? ", " : "");        \
        }                                                                                                              \
        fprintf(file, "]%s", array_idx + 1 < prop_header->num_entries ? ", " : "");                                    \
    }                                                                                                                  \
                                                                                                                       \
    fprintf(file, "]\n");                                                                                              \
}

#define INTENT_LINE(nesting_level)                                                                                     \
{                                                                                                                      \
    for (unsigned nest_level = 0; nest_level < nesting_level; nest_level++) {                                          \
        fprintf(file, "   ");                                                                                          \
    }                                                                                                                  \
}

#define PRINT_VALUE_ARRAY(type, memfile, header, format_string)                                                        \
{                                                                                                                      \
    u32 num_elements = *MEMFILE_READ_TYPE(memfile, u32);                                              \
    const type *values = (const type *) MEMFILE_READ(memfile, num_elements * sizeof(type));                     \
    fprintf(file, "0x%04x ", (unsigned) offset);                                                                       \
    INTENT_LINE(nesting_level);                                                                                        \
    fprintf(file, "   [num_elements: %d] [values: [", num_elements);                                                   \
    for (size_t i = 0; i < num_elements; i++) {                                                                        \
        fprintf(file, "value: "format_string"%s", values[i], i + 1 < num_elements ? ", " : "");                        \
    }                                                                                                                  \
    fprintf(file, "]\n");                                                                                              \
}

static offset_t skip_record_header(memfile *memfile);

static void
update_record_header(memfile *memfile, offset_t root_object_header_offset, column_doc *model,
                     u64 record_size);

static bool __serialize(offset_t *offset, memfile *memfile,
                        column_doc_obj *columndoc,
                        offset_t root_object_header_offset);

static object_flags_u *get_flags(object_flags_u *flags, column_doc_obj *columndoc);

static void update_file_header(memfile *memfile, offset_t root_object_header_offset);

static void skip_file_header(memfile *memfile);

static bool serialize_string_dic(memfile *memfile, const doc_bulk *context,
                                 packer_e compressor);

static bool print_archive_from_memfile(FILE *file, memfile *memfile);

bool archive_from_json(archive *out, const char *file, const char *json_string,
                           packer_e compressor, str_dict_tag_e dictionary,
                           size_t num_async_dic_threads,
                           bool read_optimized,
                           bool bake_string_id_index, archive_callback *callback)
{
        OPTIONAL_CALL(callback, begin_create_from_json);

        memblock *stream;
        FILE *out_file;

        if (!archive_stream_from_json(&stream,
                                          json_string,
                                          compressor,
                                          dictionary,
                                          num_async_dic_threads,
                                          read_optimized,
                                          bake_string_id_index,
                                          callback)) {
                return false;
        }

        OPTIONAL_CALL(callback, begin_write_archive_file_to_disk);

        if ((out_file = fopen(file, "w")) == NULL) {
                ERROR(ERR_FOPENWRITE, NULL);
                MEMBLOCK_DROP(stream);
                return false;
        }

        if (!archive_write(out_file, stream)) {
                ERROR(ERR_WRITEARCHIVE, NULL);
                fclose(out_file);
                MEMBLOCK_DROP(stream);
                return false;
        }

        fclose(out_file);

        OPTIONAL_CALL(callback, end_write_archive_file_to_disk);

        OPTIONAL_CALL(callback, begin_load_archive);

        if (!archive_open(out, file)) {
                ERROR(ERR_ARCHIVEOPEN, NULL);
                return false;
        }

        OPTIONAL_CALL(callback, end_load_archive);

        MEMBLOCK_DROP(stream);

        OPTIONAL_CALL(callback, end_create_from_json);

        return true;
}

bool archive_stream_from_json(memblock **stream, const char *json_string,
                              packer_e compressor, str_dict_tag_e dictionary,
                              size_t num_async_dic_threads,
                              bool read_optimized,
                              bool bake_id_index, archive_callback *callback)
{
        string_dict dic;
        json_parser parser;
        json_err error_desc;
        doc_bulk bulk;
        doc_entries *partition;
        column_doc *columndoc;
        json json;

        OPTIONAL_CALL(callback, begin_archive_stream_from_json)

        OPTIONAL_CALL(callback, begin_setup_string_dict_ionary);
        if (dictionary == SYNC) {
                encode_sync_create(&dic, 1000, 1000, 1000, 0);
        } else if (dictionary == ASYNC) {
                encode_async_create(&dic, 1000, 1000, 1000, num_async_dic_threads);
        } else {
                ERROR(ERR_UNKNOWN_DIC_TYPE, NULL);
        }

        OPTIONAL_CALL(callback, end_setup_string_dict_ionary);

        OPTIONAL_CALL(callback, begin_parse_json);
        if (!(json_parse(&json, &error_desc, &parser, json_string))) {
                char buffer[2048];
                if (error_desc.token) {
                        sprintf(buffer,
                                "%s. Token %s was found in line %u column %u",
                                error_desc.msg,
                                error_desc.token_type_str,
                                error_desc.token->line,
                                error_desc.token->column);
                        ERROR(ERR_JSONPARSEERR, &buffer[0]);
                } else {
                        sprintf(buffer, "%s", error_desc.msg);
                        ERROR(ERR_JSONPARSEERR, &buffer[0]);
                }
                return false;
        }
        OPTIONAL_CALL(callback, end_parse_json);

        OPTIONAL_CALL(callback, begin_test_json);
        if (!json_test(&json)) {
                return false;
        }
        OPTIONAL_CALL(callback, end_test_json);

        OPTIONAL_CALL(callback, begin_import_json);
        if (!doc_bulk_create(&bulk, &dic)) {
                ERROR(ERR_BULKCREATEFAILED, NULL);
                return false;
        }

        partition = doc_bulk_new_entries(&bulk);
        doc_bulk_add_json(partition, &json);

        json_drop(&json);

        doc_bulk_shrink(&bulk);

        columndoc = doc_entries_columndoc(&bulk, partition, read_optimized);

        if (!archive_from_model(stream, columndoc, compressor, bake_id_index, callback)) {
                return false;
        }

        OPTIONAL_CALL(callback, end_import_json);

        OPTIONAL_CALL(callback, begin_cleanup);
        string_dict_drop(&dic);
        doc_bulk_drop(&bulk);
        doc_entries_drop(partition);
        columndoc_free(columndoc);
        free(columndoc);
        OPTIONAL_CALL(callback, end_cleanup);

        OPTIONAL_CALL(callback, end_archive_stream_from_json)

        return true;
}

static bool run_string_id_baking(memblock **stream)
{
        archive archive;
        char tmp_file_name[512];
        unique_id_t rand_part;
        unique_id_create(&rand_part);
        sprintf(tmp_file_name, "/tmp/carbon-tool-temp-%"
                               PRIu64
                               ".carbon-tool", rand_part);
        FILE *tmp_file;

        if ((tmp_file = fopen(tmp_file_name, "w")) == NULL) {
                ERROR(ERR_TMP_FOPENWRITE, NULL);
                return false;
        }

        if (!archive_write(tmp_file, *stream)) {
                ERROR(ERR_WRITEARCHIVE, NULL);
                fclose(tmp_file);
                remove(tmp_file_name);
                return false;
        }

        fflush(tmp_file);
        fclose(tmp_file);

        if (!archive_open(&archive, tmp_file_name)) {
                ERROR(ERR_ARCHIVEOPEN, NULL);
                return false;
        }

        bool has_index;
        archive_has_query_index_string_id_to_offset(&has_index, &archive);
        if (has_index) {
                ERROR(ERR_INTERNALERR, NULL);
                remove(tmp_file_name);
                return false;
        }

        struct sid_to_offset *index;
        query query;
        query_create(&query, &archive);
        query_create_index_string_id_to_offset(&index, &query);
        query_drop(&query);
        archive_close(&archive);

        if ((tmp_file = fopen(tmp_file_name, "rb+")) == NULL) {
                ERROR(ERR_TMP_FOPENWRITE, NULL);
                return false;
        }

        fseek(tmp_file, 0, SEEK_END);
        offset_t index_pos = ftell(tmp_file);
        query_index_id_to_offset_serialize(tmp_file, index);
        offset_t file_length = ftell(tmp_file);
        fseek(tmp_file, 0, SEEK_SET);

        archive_header header;
        size_t nread = fread(&header, sizeof(archive_header), 1, tmp_file);
        ERROR_IF_AND_RETURN(nread != 1, ERR_FREAD_FAILED, NULL);
        header.string_id_to_offset_index_offset = index_pos;
        fseek(tmp_file, 0, SEEK_SET);
        int nwrite = fwrite(&header, sizeof(archive_header), 1, tmp_file);
        ERROR_IF_AND_RETURN(nwrite != 1, ERR_FWRITE_FAILED, NULL);
        fseek(tmp_file, 0, SEEK_SET);

        query_drop_index_string_id_to_offset(index);

        MEMBLOCK_DROP(*stream);
        MEMBLOCK_FROM_FILE(stream, tmp_file, file_length);

        remove(tmp_file_name);

        return true;
}

bool archive_from_model(memblock **stream, column_doc *model, packer_e compressor,
                        bool bake_string_id_index, archive_callback *callback)
{
        OPTIONAL_CALL(callback, begin_create_from_model)

        MEMBLOCK_CREATE(stream, 1024 * 1024 * 1024);
        memfile memfile;
        MEMFILE_OPEN(&memfile, *stream, READ_WRITE);

        OPTIONAL_CALL(callback, begin_write_string_table);
        skip_file_header(&memfile);
        if (!serialize_string_dic(&memfile, model->bulk, compressor)) {
                return false;
        }
        OPTIONAL_CALL(callback, end_write_string_table);

        OPTIONAL_CALL(callback, begin_write_record_table);
        offset_t record_header_offset = skip_record_header(&memfile);
        update_file_header(&memfile, record_header_offset);
        offset_t root_object_header_offset = MEMFILE_TELL(&memfile);
        if (!__serialize(NULL, &memfile, &model->columndoc, root_object_header_offset)) {
                return false;
        }
        u64 record_size = MEMFILE_TELL(&memfile) - (record_header_offset + sizeof(record_header));
        update_record_header(&memfile, record_header_offset, model, record_size);
        OPTIONAL_CALL(callback, end_write_record_table);

        MEMFILE_SHRINK(&memfile);

        if (bake_string_id_index) {
                /** create str_buf id to offset index, and append it to the CARBON file */
                OPTIONAL_CALL(callback, begin_string_id_index_baking);
                if (!run_string_id_baking(stream)) {
                        return false;
                }
                OPTIONAL_CALL(callback, end_string_id_index_baking);
        } else {
                OPTIONAL_CALL(callback, skip_string_id_index_baking);
        }

        OPTIONAL_CALL(callback, end_create_from_model)

        return true;
}

archive_io_context *archive_io_context_create(archive *archive)
{
        archive_io_context *context;
        if (io_context_create(&context, archive->disk_file_path)) {
                return context;
        } else {
                ERROR(ERR_IO, NULL);
                return NULL;
        }
}

bool archive_write(FILE *file, const memblock *stream)
{
        return MEMBLOCK_WRITE_TO_FILE(file, stream);
}

bool archive_load(memblock **stream, FILE *file)
{
        long start = ftell(file);
        fseek(file, 0, SEEK_END);
        long end = ftell(file);
        fseek(file, start, SEEK_SET);
        long fileSize = (end - start);

        return MEMBLOCK_FROM_FILE(stream, file, fileSize);
}

bool archive_print(FILE *file, memblock *stream)
{
        memfile memfile;
        MEMFILE_OPEN(&memfile, stream, READ_ONLY);
        if (MEMFILE_SIZE(&memfile)
            < sizeof(archive_header) + sizeof(string_table_header) +
              sizeof(object_header)) {
                ERROR(ERR_NOCARBONSTREAM, NULL);
                return false;
        } else {
                return print_archive_from_memfile(file, &memfile);
        }
}

bool _archive_print_object(FILE *file, memfile *memfile, unsigned nesting_level);

static u32 flags_to_int32(object_flags_u *flags)
{
        return *((i32 *) flags);
}

static const char *array_value_type_to_string(archive_field_e type)
{
        switch (type) {
                case ARCHIVE_FIELD_NULL:
                        return "Null Array";
                case ARCHIVE_FIELD_BOOLEAN:
                        return "Boolean Array";
                case ARCHIVE_FIELD_INT8:
                        return "Int8 Array";
                case ARCHIVE_FIELD_INT16:
                        return "Int16 Array";
                case ARCHIVE_FIELD_INT32:
                        return "Int32 Array";
                case ARCHIVE_FIELD_INT64:
                        return "Int64 Array";
                case ARCHIVE_FIELD_UINT8:
                        return "UInt8 Array";
                case ARCHIVE_FIELD_UINT16:
                        return "UInt16 Array";
                case ARCHIVE_FIELD_UINT32:
                        return "UInt32 Array";
                case ARCHIVE_FIELD_UINT64:
                        return "UInt64 Array";
                case ARCHIVE_FIELD_FLOAT:
                        return "UIntFloat Array";
                case ARCHIVE_FIELD_STRING:
                        return "Text Array";
                case ARCHIVE_FIELD_OBJECT:
                        return "Object Array";
                default: {
                        ERROR(ERR_NOVALUESTR, NULL);
                        return NULL;
                }
        }
}

static void
write_primitive_key_column(memfile *memfile, vec ofType(archive_field_sid_t) *keys)
{
        archive_field_sid_t *string_ids = VEC_ALL(keys, archive_field_sid_t);
        MEMFILE_WRITE(memfile, string_ids, keys->num_elems * sizeof(archive_field_sid_t));
}

static offset_t skip_var_value_offset_column(memfile *memfile, size_t num_keys)
{
        offset_t result = MEMFILE_TELL(memfile);
        MEMFILE_SKIP(memfile, num_keys * sizeof(offset_t));
        return result;
}

static void write_var_value_offset_column(memfile *file, offset_t where, offset_t after,
                                          const offset_t *values,
                                          size_t n)
{
        MEMFILE_SEEK(file, where);
        MEMFILE_WRITE(file, values, n * sizeof(offset_t));
        MEMFILE_SEEK(file, after);
}

static bool
write_primitive_fixed_value_column(memfile *memfile, archive_field_e type,
                                   vec ofType(T) *values_vec)
{
        assert (type != ARCHIVE_FIELD_OBJECT); /** use 'write_primitive_var_value_column' instead */

        switch (type) {
                case ARCHIVE_FIELD_NULL:
                        break;
                case ARCHIVE_FIELD_BOOLEAN: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_boolean_t);
                        break;
                case ARCHIVE_FIELD_INT8: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_i8_t);
                        break;
                case ARCHIVE_FIELD_INT16: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_i16_t);
                        break;
                case ARCHIVE_FIELD_INT32: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_i32_t);
                        break;
                case ARCHIVE_FIELD_INT64: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_i64_t);
                        break;
                case ARCHIVE_FIELD_UINT8: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_u8_t);
                        break;
                case ARCHIVE_FIELD_UINT16: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_u16_t);
                        break;
                case ARCHIVE_FIELD_UINT32: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_u32_t);
                        break;
                case ARCHIVE_FIELD_UINT64: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_u64_t);
                        break;
                case ARCHIVE_FIELD_FLOAT: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_number_t);
                        break;
                case ARCHIVE_FIELD_STRING: WRITE_PRIMITIVE_VALUES(memfile, values_vec, archive_field_sid_t);
                        break;
                default: ERROR(ERR_NOTYPE, NULL);
                        return false;
        }
        return true;
}

static offset_t *__write_primitive_column(memfile *memfile,
                                              vec ofType(column_doc_obj) *values_vec,
                                              offset_t root_offset)
{
        offset_t *result = MALLOC(values_vec->num_elems * sizeof(offset_t));
        column_doc_obj *mapped = VEC_ALL(values_vec, column_doc_obj);
        for (u32 i = 0; i < values_vec->num_elems; i++) {
                column_doc_obj *obj = mapped + i;
                result[i] = MEMFILE_TELL(memfile) - root_offset;
                if (!__serialize(NULL, memfile, obj, root_offset)) {
                        return NULL;
                }
        }
        return result;
}

static bool __write_array_len_column(memfile *memfile, archive_field_e type,
                                     vec ofType(...) *values)
{
        switch (type) {
                case ARCHIVE_FIELD_NULL:
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                case ARCHIVE_FIELD_INT8:
                case ARCHIVE_FIELD_INT16:
                case ARCHIVE_FIELD_INT32:
                case ARCHIVE_FIELD_INT64:
                case ARCHIVE_FIELD_UINT8:
                case ARCHIVE_FIELD_UINT16:
                case ARCHIVE_FIELD_UINT32:
                case ARCHIVE_FIELD_UINT64:
                case ARCHIVE_FIELD_FLOAT:
                case ARCHIVE_FIELD_STRING:
                        for (u32 i = 0; i < values->num_elems; i++) {
                                vec *arrays = VEC_GET(values, i, vec);
                                MEMFILE_WRITE(memfile, &arrays->num_elems, sizeof(u32));
                        }
                        break;
                case ARCHIVE_FIELD_OBJECT:
                        return ERROR(ERR_ILLEGALIMPL, NULL);
                default:
                        return ERROR(ERR_NOTYPE, NULL);
        }
        return true;
}

static bool write_array_value_column(memfile *memfile, archive_field_e type,
                                     vec ofType(...) *values_vec)
{

        switch (type) {
                case ARCHIVE_FIELD_NULL: WRITE_PRIMITIVE_VALUES(memfile, values_vec, u32);
                        break;
                case ARCHIVE_FIELD_BOOLEAN: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_boolean_t);
                        break;
                case ARCHIVE_FIELD_INT8: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_i8_t);
                        break;
                case ARCHIVE_FIELD_INT16: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_i16_t);
                        break;
                case ARCHIVE_FIELD_INT32: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_i32_t);
                        break;
                case ARCHIVE_FIELD_INT64: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_i64_t);
                        break;
                case ARCHIVE_FIELD_UINT8: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_u64_t);
                        break;
                case ARCHIVE_FIELD_UINT16: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_u16_t);
                        break;
                case ARCHIVE_FIELD_UINT32: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_u32_t);
                        break;
                case ARCHIVE_FIELD_UINT64: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_u64_t);
                        break;
                case ARCHIVE_FIELD_FLOAT: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_number_t);
                        break;
                case ARCHIVE_FIELD_STRING: WRITE_ARRAY_VALUES(memfile, values_vec, archive_field_sid_t);
                        break;
                case ARCHIVE_FIELD_OBJECT:
                        return ERROR(ERR_NOTIMPL, NULL);
                default:
                        return ERROR(ERR_NOTYPE, NULL);
        }
        return true;
}

static bool write_array_prop(offset_t *offset, memfile *memfile,
                             vec ofType(archive_field_sid_t) *keys, archive_field_e type,
                             vec ofType(...) *values,
                             offset_t root_object_header_offset)
{
        assert(keys->num_elems == values->num_elems);

        if (keys->num_elems > 0) {
                prop_header header =
                        {.marker = global_marker_symbols[global_value_array_marker_mapping[type].marker].symbol, .num_entries = keys
                                ->num_elems};
                offset_t prop_ofOffset = MEMFILE_TELL(memfile);
                MEMFILE_WRITE(memfile, &header, sizeof(prop_header));

                write_primitive_key_column(memfile, keys);
                if (!__write_array_len_column(memfile, type, values)) {
                        return false;
                }
                if (!write_array_value_column(memfile, type, values)) {
                        return false;
                }
                *offset = (prop_ofOffset - root_object_header_offset);
        } else {
                *offset = 0;
        }
        return true;
}

static bool write_array_props(memfile *memfile, column_doc_obj *columndoc,
                              archive_prop_offs *offsets, offset_t root_object_header_offset)
{
        if (!write_array_prop(&offsets->null_arrays,
                              memfile,
                              &columndoc->null_array_prop_keys,
                              ARCHIVE_FIELD_NULL,
                              &columndoc->null_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->bool_arrays,
                              memfile,
                              &columndoc->bool_array_prop_keys,
                              ARCHIVE_FIELD_BOOLEAN,
                              &columndoc->bool_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int8_arrays,
                              memfile,
                              &columndoc->int8_array_prop_keys,
                              ARCHIVE_FIELD_INT8,
                              &columndoc->int8_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int16_arrays,
                              memfile,
                              &columndoc->int16_array_prop_keys,
                              ARCHIVE_FIELD_INT16,
                              &columndoc->int16_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int32_arrays,
                              memfile,
                              &columndoc->int32_array_prop_keys,
                              ARCHIVE_FIELD_INT32,
                              &columndoc->int32_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int64_arrays,
                              memfile,
                              &columndoc->int64_array_prop_keys,
                              ARCHIVE_FIELD_INT64,
                              &columndoc->int64_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint8_arrays,
                              memfile,
                              &columndoc->uint8_array_prop_keys,
                              ARCHIVE_FIELD_UINT8,
                              &columndoc->uint8_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint16_arrays,
                              memfile,
                              &columndoc->uint16_array_prop_keys,
                              ARCHIVE_FIELD_UINT16,
                              &columndoc->uint16_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint32_arrays,
                              memfile,
                              &columndoc->uint32_array_prop_keys,
                              ARCHIVE_FIELD_UINT32,
                              &columndoc->uint32_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint64_arrays,
                              memfile,
                              &columndoc->uint64_array_prop_keys,
                              ARCHIVE_FIELD_UINT64,
                              &columndoc->ui64_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->float_arrays,
                              memfile,
                              &columndoc->float_array_prop_keys,
                              ARCHIVE_FIELD_FLOAT,
                              &columndoc->float_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->string_arrays,
                              memfile,
                              &columndoc->string_array_prop_keys,
                              ARCHIVE_FIELD_STRING,
                              &columndoc->string_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        return true;
}

/** Fixed-length property lists; value position can be determined by size of value and position of key in key column.
 * In contrast, variable-length property list require an additional offset column (see 'write_var_props') */
static bool write_fixed_props(offset_t *offset, memfile *memfile,
                              vec ofType(archive_field_sid_t) *keys, archive_field_e type,
                              vec ofType(T) *values)
{
        assert(!values || keys->num_elems == values->num_elems);
        assert(type != ARCHIVE_FIELD_OBJECT); /** use 'write_var_props' instead */

        if (keys->num_elems > 0) {
                prop_header header =
                        {.marker = global_marker_symbols[valueMarkerMapping[type].marker].symbol, .num_entries = keys
                                ->num_elems};

                offset_t prop_ofOffset = MEMFILE_TELL(memfile);
                MEMFILE_WRITE(memfile, &header, sizeof(prop_header));

                write_primitive_key_column(memfile, keys);
                if (!write_primitive_fixed_value_column(memfile, type, values)) {
                        return false;
                }
                *offset = prop_ofOffset;
        } else {
                *offset = 0;
        }
        return true;
}

/** Variable-length property lists; value position cannot be determined by position of key in key column, since single
 * value has unknown size. Hence, a dedicated offset column is added to these properties allowing to seek directly
 * to a particular property. Due to the move of strings (i.e., variable-length values) to a dedicated string table,
 * the only variable-length value for properties are "JSON objects".
 * In contrast, fixed-length property list doesn't require an additional offset column (see 'write_fixed_props') */
static bool write_var_props(offset_t *offset, memfile *memfile,
                            vec ofType(archive_field_sid_t) *keys,
                            vec ofType(column_doc_obj) *objects,
                            offset_t root_object_header_offset)
{
        assert(!objects || keys->num_elems == objects->num_elems);

        if (keys->num_elems > 0) {
                prop_header header = {.marker = MARKER_SYMBOL_PROP_OBJECT, .num_entries = keys->num_elems};

                offset_t prop_ofOffset = MEMFILE_TELL(memfile);
                MEMFILE_WRITE(memfile, &header, sizeof(prop_header));

                write_primitive_key_column(memfile, keys);
                offset_t value_offset = skip_var_value_offset_column(memfile, keys->num_elems);
                offset_t *value_offsets = __write_primitive_column(memfile, objects,
                                                                       root_object_header_offset);
                if (!value_offsets) {
                        return false;
                }

                offset_t last = MEMFILE_TELL(memfile);
                write_var_value_offset_column(memfile, value_offset, last, value_offsets, keys->num_elems);
                free(value_offsets);
                *offset = prop_ofOffset;
        } else {
                *offset = 0;
        }
        return true;
}

static bool
write_primitive_props(memfile *memfile, column_doc_obj *columndoc,
                      archive_prop_offs *offsets, offset_t root_object_header_offset)
{
        if (!write_fixed_props(&offsets->nulls, memfile, &columndoc->null_prop_keys, ARCHIVE_FIELD_NULL, NULL)) {
                return false;
        }
        if (!write_fixed_props(&offsets->bools,
                               memfile,
                               &columndoc->bool_prop_keys,
                               ARCHIVE_FIELD_BOOLEAN,
                               &columndoc->bool_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int8s,
                               memfile,
                               &columndoc->int8_prop_keys,
                               ARCHIVE_FIELD_INT8,
                               &columndoc->int8_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int16s,
                               memfile,
                               &columndoc->int16_prop_keys,
                               ARCHIVE_FIELD_INT16,
                               &columndoc->int16_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int32s,
                               memfile,
                               &columndoc->int32_prop_keys,
                               ARCHIVE_FIELD_INT32,
                               &columndoc->int32_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int64s,
                               memfile,
                               &columndoc->int64_prop_keys,
                               ARCHIVE_FIELD_INT64,
                               &columndoc->int64_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint8s,
                               memfile,
                               &columndoc->uint8_prop_keys,
                               ARCHIVE_FIELD_UINT8,
                               &columndoc->uint8_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint16s,
                               memfile,
                               &columndoc->uint16_prop_keys,
                               ARCHIVE_FIELD_UINT16,
                               &columndoc->uint16_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint32s,
                               memfile,
                               &columndoc->uin32_prop_keys,
                               ARCHIVE_FIELD_UINT32,
                               &columndoc->uint32_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint64s,
                               memfile,
                               &columndoc->uint64_prop_keys,
                               ARCHIVE_FIELD_UINT64,
                               &columndoc->uint64_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->floats,
                               memfile,
                               &columndoc->float_prop_keys,
                               ARCHIVE_FIELD_FLOAT,
                               &columndoc->float_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->strings,
                               memfile,
                               &columndoc->string_prop_keys,
                               ARCHIVE_FIELD_STRING,
                               &columndoc->string_prop_vals)) {
                return false;
        }
        if (!write_var_props(&offsets->objects,
                             memfile,
                             &columndoc->obj_prop_keys,
                             &columndoc->obj_prop_vals,
                             root_object_header_offset)) {
                return false;
        }

        offsets->nulls -= root_object_header_offset;
        offsets->bools -= root_object_header_offset;
        offsets->int8s -= root_object_header_offset;
        offsets->int16s -= root_object_header_offset;
        offsets->int32s -= root_object_header_offset;
        offsets->int64s -= root_object_header_offset;
        offsets->uint8s -= root_object_header_offset;
        offsets->uint16s -= root_object_header_offset;
        offsets->uint32s -= root_object_header_offset;
        offsets->uint64s -= root_object_header_offset;
        offsets->floats -= root_object_header_offset;
        offsets->strings -= root_object_header_offset;
        offsets->objects -= root_object_header_offset;
        return true;
}

static bool write_column_entry(memfile *memfile, archive_field_e type,
                               vec ofType(<T>) *column, offset_t root_object_header_offset)
{
        MEMFILE_WRITE(memfile, &column->num_elems, sizeof(u32));
        switch (type) {
                case ARCHIVE_FIELD_NULL:
                        MEMFILE_WRITE(memfile, column->base, column->num_elems * sizeof(u32));
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                case ARCHIVE_FIELD_INT8:
                case ARCHIVE_FIELD_INT16:
                case ARCHIVE_FIELD_INT32:
                case ARCHIVE_FIELD_INT64:
                case ARCHIVE_FIELD_UINT8:
                case ARCHIVE_FIELD_UINT16:
                case ARCHIVE_FIELD_UINT32:
                case ARCHIVE_FIELD_UINT64:
                case ARCHIVE_FIELD_FLOAT:
                case ARCHIVE_FIELD_STRING:
                        MEMFILE_WRITE(memfile, column->base, column->num_elems * GET_TYPE_SIZE(type));
                        break;
                case ARCHIVE_FIELD_OBJECT: {
                        offset_t preObjectNext = 0;
                        for (size_t i = 0; i < column->num_elems; i++) {
                                column_doc_obj *object = VEC_GET(column, i, column_doc_obj);
                                if (LIKELY(preObjectNext != 0)) {
                                        offset_t continuePos = MEMFILE_TELL(memfile);
                                        offset_t relativeContinuePos = continuePos - root_object_header_offset;
                                        MEMFILE_SEEK(memfile, preObjectNext);
                                        MEMFILE_WRITE(memfile, &relativeContinuePos, sizeof(offset_t));
                                        MEMFILE_SEEK(memfile, continuePos);
                                }
                                if (!__serialize(&preObjectNext, memfile, object, root_object_header_offset)) {
                                        return false;
                                }
                        }
                }
                        break;
                default:
                        return ERROR(ERR_NOTYPE, NULL);
        }
        return true;
}

static bool write_column(memfile *memfile, column_doc_column *column,
                         offset_t root_object_header_offset)
{
        assert(column->array_positions.num_elems == column->values.num_elems);

        column_header header = {.marker = global_marker_symbols[MARKER_TYPE_COLUMN].symbol, .column_name = column
                ->key_name, .value_type = global_marker_symbols[global_value_array_marker_mapping[column->type].marker]
                .symbol, .num_entries = column->values.num_elems};

        MEMFILE_WRITE(memfile, &header, sizeof(column_header));

        /** skip offset column to value entry points */
        offset_t value_entry_offsets = MEMFILE_TELL(memfile);
        MEMFILE_SKIP(memfile, column->values.num_elems * sizeof(offset_t));

        MEMFILE_WRITE(memfile, column->array_positions.base, column->array_positions.num_elems * sizeof(u32));

        for (size_t i = 0; i < column->values.num_elems; i++) {
                vec ofType(<T>) *column_data = VEC_GET(&column->values, i, vec);
                offset_t column_entry_offset = MEMFILE_TELL(memfile);
                offset_t relative_entry_offset = column_entry_offset - root_object_header_offset;
                MEMFILE_SEEK(memfile, value_entry_offsets + i * sizeof(offset_t));
                MEMFILE_WRITE(memfile, &relative_entry_offset, sizeof(offset_t));
                MEMFILE_SEEK(memfile, column_entry_offset);
                if (!write_column_entry(memfile, column->type, column_data, root_object_header_offset)) {
                        return false;
                }
        }
        return true;
}

static bool write_object_array_props(memfile *memfile,
                                     vec ofType(column_doc_group) *object_key_columns,
                                     archive_prop_offs *offsets,
                                     offset_t root_object_header_offset)
{
        if (object_key_columns->num_elems > 0) {
                object_array_header header = {.marker = global_marker_symbols[MARKER_TYPE_PROP_OBJECT_ARRAY]
                        .symbol, .num_entries = object_key_columns->num_elems};

                offsets->object_arrays = MEMFILE_TELL(memfile) - root_object_header_offset;
                MEMFILE_WRITE(memfile, &header, sizeof(object_array_header));

                for (size_t i = 0; i < object_key_columns->num_elems; i++) {
                        column_doc_group *column_group = VEC_GET(object_key_columns, i,
                                                                            column_doc_group);
                        MEMFILE_WRITE(memfile, &column_group->key, sizeof(archive_field_sid_t));
                }

                // skip offset column to column groups
                offset_t column_offsets = MEMFILE_TELL(memfile);
                MEMFILE_SKIP(memfile, object_key_columns->num_elems * sizeof(offset_t));

                for (size_t i = 0; i < object_key_columns->num_elems; i++) {
                        column_doc_group *column_group = VEC_GET(object_key_columns, i,
                                                                            column_doc_group);
                        offset_t this_column_offset_relative = MEMFILE_TELL(memfile) - root_object_header_offset;

                        /** write an object-id for each position number */
                        size_t max_pos = 0;
                        for (size_t k = 0; k < column_group->columns.num_elems; k++) {
                                column_doc_column
                                        *column = VEC_GET(&column_group->columns, k, column_doc_column);
                                const u32 *array_pos = VEC_ALL(&column->array_positions, u32);
                                for (size_t m = 0; m < column->array_positions.num_elems; m++) {
                                        max_pos = JAK_MAX(max_pos, array_pos[m]);
                                }
                        }
                        column_group_header column_group_header =
                                {.marker = global_marker_symbols[MARKER_TYPE_COLUMN_GROUP].symbol, .num_columns = column_group
                                        ->columns.num_elems, .num_objects = max_pos + 1};
                        MEMFILE_WRITE(memfile, &column_group_header, sizeof(column_group_header));

                        for (size_t i = 0; i < column_group_header.num_objects; i++) {
                                unique_id_t oid;
                                if (!unique_id_create(&oid)) {
                                        ERROR(ERR_THREADOOOBJIDS, NULL);
                                        return false;
                                }
                                MEMFILE_WRITE(memfile, &oid, sizeof(unique_id_t));
                        }

                        offset_t continue_write = MEMFILE_TELL(memfile);
                        MEMFILE_SEEK(memfile, column_offsets + i * sizeof(offset_t));
                        MEMFILE_WRITE(memfile, &this_column_offset_relative, sizeof(offset_t));
                        MEMFILE_SEEK(memfile, continue_write);

                        offset_t offset_column_to_columns = continue_write;
                        MEMFILE_SKIP(memfile, column_group->columns.num_elems * sizeof(offset_t));

                        for (size_t k = 0; k < column_group->columns.num_elems; k++) {
                                column_doc_column
                                        *column = VEC_GET(&column_group->columns, k, column_doc_column);
                                offset_t continue_write = MEMFILE_TELL(memfile);
                                offset_t column_off = continue_write - root_object_header_offset;
                                MEMFILE_SEEK(memfile, offset_column_to_columns + k * sizeof(offset_t));
                                MEMFILE_WRITE(memfile, &column_off, sizeof(offset_t));
                                MEMFILE_SEEK(memfile, continue_write);
                                if (!write_column(memfile, column, root_object_header_offset)) {
                                        return false;
                                }
                        }

                }
        } else {
                offsets->object_arrays = 0;
        }

        return true;
}

static offset_t skip_record_header(memfile *memfile)
{
        offset_t offset = MEMFILE_TELL(memfile);
        MEMFILE_SKIP(memfile, sizeof(record_header));
        return offset;
}

static void
update_record_header(memfile *memfile, offset_t root_object_header_offset, column_doc *model,
                     u64 record_size)
{
        record_flags flags = {.bits.is_sorted = model->read_optimized};
        record_header
                header = {.marker = MARKER_SYMBOL_RECORD_HEADER, .flags = flags.value, .record_size = record_size};
        offset_t offset;
        MEMFILE_GET_OFFSET(&offset, memfile);
        MEMFILE_SEEK(memfile, root_object_header_offset);
        MEMFILE_WRITE(memfile, &header, sizeof(record_header));
        MEMFILE_SEEK(memfile, offset);
}

static void propOffsetsWrite(memfile *memfile, const object_flags_u *flags,
                             archive_prop_offs *prop_offsets)
{
        if (flags->bits.has_null_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->nulls, sizeof(offset_t));
        }
        if (flags->bits.has_bool_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->bools, sizeof(offset_t));
        }
        if (flags->bits.has_int8_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int8s, sizeof(offset_t));
        }
        if (flags->bits.has_int16_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int16s, sizeof(offset_t));
        }
        if (flags->bits.has_int32_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int32s, sizeof(offset_t));
        }
        if (flags->bits.has_int64_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int64s, sizeof(offset_t));
        }
        if (flags->bits.has_uint8_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint8s, sizeof(offset_t));
        }
        if (flags->bits.has_uint16_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint16s, sizeof(offset_t));
        }
        if (flags->bits.has_uint32_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint32s, sizeof(offset_t));
        }
        if (flags->bits.has_uint64_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint64s, sizeof(offset_t));
        }
        if (flags->bits.has_float_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->floats, sizeof(offset_t));
        }
        if (flags->bits.has_string_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->strings, sizeof(offset_t));
        }
        if (flags->bits.has_object_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->objects, sizeof(offset_t));
        }
        if (flags->bits.has_null_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->null_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_bool_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->bool_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_int8_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int8_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_int16_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int16_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_int32_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int32_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_int64_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->int64_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_uint8_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint8_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_uint16_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint16_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_uint32_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint32_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_uint64_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->uint64_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_float_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->float_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_string_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->string_arrays, sizeof(offset_t));
        }
        if (flags->bits.has_object_array_props) {
                MEMFILE_WRITE(memfile, &prop_offsets->object_arrays, sizeof(offset_t));
        }
}

static void prop_offsets_skip_write(memfile *memfile, const object_flags_u *flags)
{
        unsigned num_skip_offset_bytes = 0;
        if (flags->bits.has_null_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_bool_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int8_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int16_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int32_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int64_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint8_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint16_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint32_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint64_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_float_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_string_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_object_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_null_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_bool_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int8_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int16_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int32_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int64_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint8_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint16_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint32_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint64_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_float_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_string_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_object_array_props) {
                num_skip_offset_bytes++;
        }

        MEMFILE_SKIP(memfile, num_skip_offset_bytes * sizeof(offset_t));
}

static bool __serialize(offset_t *offset, memfile *memfile,
                        column_doc_obj *columndoc,
                        offset_t root_object_header_offset)
{
        object_flags_u flags;
        archive_prop_offs prop_offsets;
        get_flags(&flags, columndoc);

        offset_t header_offset = MEMFILE_TELL(memfile);
        MEMFILE_SKIP(memfile, sizeof(object_header));

        prop_offsets_skip_write(memfile, &flags);
        offset_t next_offset = MEMFILE_TELL(memfile);
        offset_t default_next_nil = 0;
        MEMFILE_WRITE(memfile, &default_next_nil, sizeof(offset_t));

        if (!write_primitive_props(memfile, columndoc, &prop_offsets, root_object_header_offset)) {
                return false;
        }
        if (!write_array_props(memfile, columndoc, &prop_offsets, root_object_header_offset)) {
                return false;
        }
        if (!write_object_array_props(memfile,
                                      &columndoc->obj_array_props,
                                      &prop_offsets,
                                      root_object_header_offset)) {
                return false;
        }

        MEMFILE_WRITE(memfile, &global_marker_symbols[MARKER_TYPE_OBJECT_END].symbol, 1);

        offset_t object_end_offset = MEMFILE_TELL(memfile);
        MEMFILE_SEEK(memfile, header_offset);

        unique_id_t oid;
        if (!unique_id_create(&oid)) {
                ERROR(ERR_THREADOOOBJIDS, NULL);
                return false;
        }

        object_header header =
                {.marker = global_marker_symbols[MARKER_TYPE_OBJECT_BEGIN].symbol, .oid = oid, .flags = flags_to_int32(
                        &flags),

                };

        MEMFILE_WRITE(memfile, &header, sizeof(object_header));

        propOffsetsWrite(memfile, &flags, &prop_offsets);

        MEMFILE_SEEK(memfile, object_end_offset);
        OPTIONAL_SET(offset, next_offset);
        return true;
}

static char *embedded_dic_flags_to_string(const string_tab_flags_u *flags)
{
        size_t max = 2048;
        char *string = MALLOC(max + 1);
        size_t length = 0;

        if (flags->value == 0) {
                strcpy(string, " uncompressed");
                length = strlen(string);
                assert(length <= max);
        } else {

                for (size_t i = 0; i < ARRAY_LENGTH(global_pack_strategy_register); i++) {
                        if (flags->value & global_pack_strategy_register[i].flag_bit) {
                                strcpy(string + length, global_pack_strategy_register[i].name);
                                length = strlen(string);
                                strcpy(string + length, " ");
                                length = strlen(string);
                        }
                }
        }
        string[length] = '\0';
        return string;
}

static char *record_header_flags_to_string(const record_flags *flags)
{
        size_t max = 2048;
        char *string = MALLOC(max + 1);
        size_t length = 0;

        if (flags->value == 0) {
                strcpy(string, " none");
                length = strlen(string);
                assert(length <= max);
        } else {
                if (flags->bits.is_sorted) {
                        strcpy(string + length, " sorted");
                        length = strlen(string);
                        assert(length <= max);
                }
        }
        string[length] = '\0';
        return string;
}

static bool serialize_string_dic(memfile *memfile, const doc_bulk *context, packer_e compressor)
{
        string_tab_flags_u flags;
        packer strategy;
        string_table_header header;

        vec ofType (const char *) *strings;
        vec ofType(archive_field_sid_t) *string_ids;

        doc_bulk_get_dic_contents(&strings, &string_ids, context);

        assert(strings->num_elems == string_ids->num_elems);

        flags.value = 0;
        if (!pack_by_type(&strategy, compressor)) {
                return false;
        }
        u8 flag_bit = pack_flagbit_by_type(compressor);
        SET_BITS(flags.value, flag_bit);

        offset_t header_pos = MEMFILE_TELL(memfile);
        MEMFILE_SKIP(memfile, sizeof(string_table_header));

        offset_t extra_begin_off = MEMFILE_TELL(memfile);
        pack_write_extra(&strategy, memfile, strings);
        offset_t extra_end_off = MEMFILE_TELL(memfile);

        header = (string_table_header) {.marker = global_marker_symbols[MARKER_TYPE_EMBEDDED_STR_DIC]
                .symbol, .flags = flags.value, .num_entries = strings
                ->num_elems, .first_entry = MEMFILE_TELL(memfile), .compressor_extra_size = (extra_end_off
                                                                                             - extra_begin_off)};

        for (size_t i = 0; i < strings->num_elems; i++) {
                archive_field_sid_t id = *VEC_GET(string_ids, i, archive_field_sid_t);
                const char *string = *VEC_GET(strings, i, char *);

                string_entry_header header = {.marker = global_marker_symbols[MARKER_TYPE_EMBEDDED_UNCOMP_STR]
                        .symbol, .next_entry_off = 0, .string_id = id, .string_len = strlen(string)};

                offset_t header_pos_off = MEMFILE_TELL(memfile);
                MEMFILE_SKIP(memfile, sizeof(string_entry_header));

                if (!pack_encode(&strategy, memfile, string)) {
                        error_print(stderr);
                        return false;
                }
                offset_t continue_off = MEMFILE_TELL(memfile);
                MEMFILE_SEEK(memfile, header_pos_off);
                header.next_entry_off = i + 1 < strings->num_elems ? continue_off : 0;
                MEMFILE_WRITE(memfile, &header, sizeof(string_entry_header));
                MEMFILE_SEEK(memfile, continue_off);
        }

        offset_t continue_pos = MEMFILE_TELL(memfile);
        MEMFILE_SEEK(memfile, header_pos);
        MEMFILE_WRITE(memfile, &header, sizeof(string_table_header));
        MEMFILE_SEEK(memfile, continue_pos);

        vec_drop(strings);
        vec_drop(string_ids);
        free(strings);
        free(string_ids);

        return pack_drop(&strategy);
}

static void skip_file_header(memfile *memfile)
{
        MEMFILE_SKIP(memfile, sizeof(archive_header));
}

static void update_file_header(memfile *memfile, offset_t record_header_offset)
{
        offset_t current_pos;
        MEMFILE_GET_OFFSET(&current_pos, memfile);
        MEMFILE_SEEK(memfile, 0);
        memcpy(&this_file_header.magic, CARBON_ARCHIVE_MAGIC, strlen(CARBON_ARCHIVE_MAGIC));
        this_file_header.root_object_header_offset = record_header_offset;
        this_file_header.string_id_to_offset_index_offset = 0;
        MEMFILE_WRITE(memfile, &this_file_header, sizeof(archive_header));
        MEMFILE_SEEK(memfile, current_pos);
}

static bool
print_column_form_memfile(FILE *file, memfile *memfile, unsigned nesting_level)
{
        offset_t offset;
        MEMFILE_GET_OFFSET(&offset, memfile);
        column_header *header = MEMFILE_READ_TYPE(memfile, column_header);
        if (header->marker != MARKER_SYMBOL_COLUMN) {
                char buffer[256];
                sprintf(buffer, "expected marker [%c] but found [%c]", MARKER_SYMBOL_COLUMN, header->marker);
                return ERROR(ERR_CORRUPTED, buffer);
        }
        fprintf(file, "0x%04x ", (unsigned) offset);
        INTENT_LINE(nesting_level);
        const char *type_name = array_value_type_to_string(int_marker_to_field_type(header->value_type));
        if (!type_name) {
                return false;
        }

        fprintf(file,
                "[marker: %c (Column)] [column_name: '%"PRIu64"'] [value_type: %c (%s)] [nentries: %d] [",
                header->marker,
                header->column_name,
                header->value_type,
                type_name,
                header->num_entries);

        for (size_t i = 0; i < header->num_entries; i++) {
                offset_t entry_off = *MEMFILE_READ_TYPE(memfile, offset_t);
                fprintf(file, "offset: 0x%04x%s", (unsigned) entry_off, i + 1 < header->num_entries ? ", " : "");
        }

        u32 *positions = (u32 *) MEMFILE_READ(memfile, header->num_entries * sizeof(u32));
        fprintf(file, "] [positions: [");
        for (size_t i = 0; i < header->num_entries; i++) {
                fprintf(file, "%d%s", positions[i], i + 1 < header->num_entries ? ", " : "");
        }

        fprintf(file, "]]\n");

        archive_field_e data_type = int_marker_to_field_type(header->value_type);

        //fprintf(file, "[");
        for (size_t i = 0; i < header->num_entries; i++) {
                switch (data_type) {
                        case ARCHIVE_FIELD_NULL: {
                                PRINT_VALUE_ARRAY(u32, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_BOOLEAN: {
                                PRINT_VALUE_ARRAY(archive_field_boolean_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_INT8: {
                                PRINT_VALUE_ARRAY(archive_field_i8_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_INT16: {
                                PRINT_VALUE_ARRAY(archive_field_i16_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_INT32: {
                                PRINT_VALUE_ARRAY(archive_field_i32_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_INT64: {
                                PRINT_VALUE_ARRAY(archive_field_i64_t, memfile, header, "%"
                                        PRIi64);
                        }
                                break;
                        case ARCHIVE_FIELD_UINT8: {
                                PRINT_VALUE_ARRAY(archive_field_u8_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_UINT16: {
                                PRINT_VALUE_ARRAY(archive_field_u16_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_UINT32: {
                                PRINT_VALUE_ARRAY(archive_field_u32_t, memfile, header, "%d");
                        }
                                break;
                        case ARCHIVE_FIELD_UINT64: {
                                PRINT_VALUE_ARRAY(archive_field_u64_t, memfile, header, "%"
                                        PRIu64);
                        }
                                break;
                        case ARCHIVE_FIELD_FLOAT: {
                                PRINT_VALUE_ARRAY(archive_field_number_t, memfile, header, "%f");
                        }
                                break;
                        case ARCHIVE_FIELD_STRING: {
                                PRINT_VALUE_ARRAY(archive_field_sid_t, memfile, header, "%"
                                        PRIu64
                                        "");
                        }
                                break;
                        case ARCHIVE_FIELD_OBJECT: {
                                u32 num_elements = *MEMFILE_READ_TYPE(memfile, u32);
                                INTENT_LINE(nesting_level);
                                fprintf(file, "   [num_elements: %d] [values: [\n", num_elements);
                                for (size_t i = 0; i < num_elements; i++) {
                                        if (!_archive_print_object(file, memfile, nesting_level + 2)) {
                                                return false;
                                        }
                                }
                                INTENT_LINE(nesting_level);
                                fprintf(file, "   ]\n");
                        }
                                break;
                        default:
                                return ERROR(ERR_NOTYPE, NULL);
                }
        }
        return true;
}

static bool _archive_print_object_array_from_memfile(FILE *file, memfile *mem_file,
                                            unsigned nesting_level)
{
        unsigned offset = (unsigned) MEMFILE_TELL(mem_file);
        object_array_header *header = MEMFILE_READ_TYPE(mem_file, object_array_header);
        if (header->marker != MARKER_SYMBOL_PROP_OBJECT_ARRAY) {
                char buffer[256];
                sprintf(buffer, "expected marker [%c] but found [%c]", MARKER_SYMBOL_PROP_OBJECT_ARRAY,
                        header->marker);
                ERROR(ERR_CORRUPTED, buffer);
                return false;
        }

        fprintf(file, "0x%04x ", offset);
        INTENT_LINE(nesting_level);
        fprintf(file, "[marker: %c (Object Array)] [nentries: %d] [", header->marker, header->num_entries);

        for (size_t i = 0; i < header->num_entries; i++) {
                archive_field_sid_t string_id = *MEMFILE_READ_TYPE(mem_file, archive_field_sid_t);
                fprintf(file, "key: %"PRIu64"%s", string_id, i + 1 < header->num_entries ? ", " : "");
        }
        fprintf(file, "] [");
        for (size_t i = 0; i < header->num_entries; i++) {
                offset_t columnGroupOffset = *MEMFILE_READ_TYPE(mem_file, offset_t);
                fprintf(file,
                        "offset: 0x%04x%s",
                        (unsigned) columnGroupOffset,
                        i + 1 < header->num_entries ? ", " : "");
        }

        fprintf(file, "]\n");
        nesting_level++;

        for (size_t i = 0; i < header->num_entries; i++) {
                offset = MEMFILE_TELL(mem_file);
                column_group_header
                        *column_group_header = MEMFILE_READ_TYPE(mem_file, struct column_group_header);
                if (column_group_header->marker != MARKER_SYMBOL_COLUMN_GROUP) {
                        char buffer[256];
                        sprintf(buffer,
                                "expected marker [%c] but found [%c]",
                                MARKER_SYMBOL_COLUMN_GROUP,
                                column_group_header->marker);
                        ERROR(ERR_CORRUPTED, buffer);
                        return false;
                }
                fprintf(file, "0x%04x ", offset);
                INTENT_LINE(nesting_level);
                fprintf(file,
                        "[marker: %c (Column Group)] [num_columns: %d] [num_objects: %d] [object_ids: ",
                        column_group_header->marker,
                        column_group_header->num_columns,
                        column_group_header->num_objects);
                const unique_id_t
                        *oids = MEMFILE_READ_TYPE_LIST(mem_file, unique_id_t,
                                                           column_group_header->num_objects);
                for (size_t k = 0; k < column_group_header->num_objects; k++) {
                        fprintf(file, "%"PRIu64"%s", oids[k], k + 1 < column_group_header->num_objects ? ", " : "");
                }
                fprintf(file, "] [offsets: ");
                for (size_t k = 0; k < column_group_header->num_columns; k++) {
                        offset_t column_off = *MEMFILE_READ_TYPE(mem_file, offset_t);
                        fprintf(file,
                                "0x%04x%s",
                                (unsigned) column_off,
                                k + 1 < column_group_header->num_columns ? ", " : "");
                }

                fprintf(file, "]\n");

                for (size_t k = 0; k < column_group_header->num_columns; k++) {
                        if (!print_column_form_memfile(file, mem_file, nesting_level + 1)) {
                                return false;
                        }
                }

                fprintf(file, "0x%04x ", offset);
                INTENT_LINE(nesting_level);
                fprintf(file, "]\n");
        }
        return true;
}

static void print_prop_offsets(FILE *file, const object_flags_u *flags,
                               const archive_prop_offs *prop_offsets)
{
        if (flags->bits.has_null_props) {
                fprintf(file, " nulls: 0x%04x", (unsigned) prop_offsets->nulls);
        }
        if (flags->bits.has_bool_props) {
                fprintf(file, " bools: 0x%04x", (unsigned) prop_offsets->bools);
        }
        if (flags->bits.has_int8_props) {
                fprintf(file, " int8s: 0x%04x", (unsigned) prop_offsets->int8s);
        }
        if (flags->bits.has_int16_props) {
                fprintf(file, " int16s: 0x%04x", (unsigned) prop_offsets->int16s);
        }
        if (flags->bits.has_int32_props) {
                fprintf(file, " int32s: 0x%04x", (unsigned) prop_offsets->int32s);
        }
        if (flags->bits.has_int64_props) {
                fprintf(file, " int64s: 0x%04x", (unsigned) prop_offsets->int64s);
        }
        if (flags->bits.has_uint8_props) {
                fprintf(file, " uint8s: 0x%04x", (unsigned) prop_offsets->uint8s);
        }
        if (flags->bits.has_uint16_props) {
                fprintf(file, " uint16s: 0x%04x", (unsigned) prop_offsets->uint16s);
        }
        if (flags->bits.has_uint32_props) {
                fprintf(file, " uint32s: 0x%04x", (unsigned) prop_offsets->uint32s);
        }
        if (flags->bits.has_uint64_props) {
                fprintf(file, " uint64s: 0x%04x", (unsigned) prop_offsets->uint64s);
        }
        if (flags->bits.has_float_props) {
                fprintf(file, " floats: 0x%04x", (unsigned) prop_offsets->floats);
        }
        if (flags->bits.has_string_props) {
                fprintf(file, " texts: 0x%04x", (unsigned) prop_offsets->strings);
        }
        if (flags->bits.has_object_props) {
                fprintf(file, " objects: 0x%04x", (unsigned) prop_offsets->objects);
        }
        if (flags->bits.has_null_array_props) {
                fprintf(file, " nullArrays: 0x%04x", (unsigned) prop_offsets->null_arrays);
        }
        if (flags->bits.has_bool_array_props) {
                fprintf(file, " boolArrays: 0x%04x", (unsigned) prop_offsets->bool_arrays);
        }
        if (flags->bits.has_int8_array_props) {
                fprintf(file, " int8Arrays: 0x%04x", (unsigned) prop_offsets->int8_arrays);
        }
        if (flags->bits.has_int16_array_props) {
                fprintf(file, " int16Arrays: 0x%04x", (unsigned) prop_offsets->int16_arrays);
        }
        if (flags->bits.has_int32_array_props) {
                fprintf(file, " int32Arrays: 0x%04x", (unsigned) prop_offsets->int32_arrays);
        }
        if (flags->bits.has_int64_array_props) {
                fprintf(file, " int16Arrays: 0x%04x", (unsigned) prop_offsets->int64_arrays);
        }
        if (flags->bits.has_uint8_array_props) {
                fprintf(file, " uint8Arrays: 0x%04x", (unsigned) prop_offsets->uint8_arrays);
        }
        if (flags->bits.has_uint16_array_props) {
                fprintf(file, " uint16Arrays: 0x%04x", (unsigned) prop_offsets->uint16_arrays);
        }
        if (flags->bits.has_uint32_array_props) {
                fprintf(file, " uint32Arrays: 0x%04x", (unsigned) prop_offsets->uint32_arrays);
        }
        if (flags->bits.has_uint64_array_props) {
                fprintf(file, " uint64Arrays: 0x%04x", (unsigned) prop_offsets->uint64_arrays);
        }
        if (flags->bits.has_float_array_props) {
                fprintf(file, " floatArrays: 0x%04x", (unsigned) prop_offsets->float_arrays);
        }
        if (flags->bits.has_string_array_props) {
                fprintf(file, " textArrays: 0x%04x", (unsigned) prop_offsets->string_arrays);
        }
        if (flags->bits.has_object_array_props) {
                fprintf(file, " objectArrays: 0x%04x", (unsigned) prop_offsets->object_arrays);
        }
}

bool _archive_print_object(FILE *file, memfile *memfile, unsigned nesting_level)
{
        unsigned offset = (unsigned) MEMFILE_TELL(memfile);
        object_header *header = MEMFILE_READ_TYPE(memfile, object_header);

        archive_prop_offs prop_offsets;
        object_flags_u flags = {.value = header->flags};

        int_read_prop_offsets(&prop_offsets, memfile, &flags);
        offset_t nextObjectOrNil = *MEMFILE_READ_TYPE(memfile, offset_t);

        if (header->marker != MARKER_SYMBOL_OBJECT_BEGIN) {
                char buffer[256];
                sprintf(buffer, "Parsing ERROR: expected object marker [{] but found [%c]\"", header->marker);
                ERROR(ERR_CORRUPTED, buffer);
                return false;
        }

        fprintf(file, "0x%04x ", offset);
        INTENT_LINE(nesting_level);
        nesting_level++;
        fprintf(file,
                "[marker: %c (BeginObject)] [object-id: %"PRIu64"] [flags: %u] [propertyOffsets: [",
                header->marker,
                header->oid,
                header->flags);
        print_prop_offsets(file, &flags, &prop_offsets);
        fprintf(file, " ] [next: 0x%04x] \n", (unsigned) nextObjectOrNil);

        bool continue_read = true;
        while (continue_read) {
                offset = MEMFILE_TELL(memfile);
                char entryMarker = *MEMFILE_PEEK_TYPE(memfile, char);

                switch (entryMarker) {
                        case MARKER_SYMBOL_PROP_NULL: {
                                prop_header *prop_header = MEMFILE_READ_TYPE(memfile,
                                                                                                struct prop_header);
                                archive_field_sid_t *keys = (archive_field_sid_t *) MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(archive_field_sid_t));
                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file, "[marker: %c (null)] [nentries: %d] [", entryMarker,
                                        prop_header->num_entries);

                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "]\n");
                        }
                                break;
                        case MARKER_SYMBOL_PROP_BOOLEAN: {
                                prop_header *prop_header = MEMFILE_READ_TYPE(memfile, struct prop_header);
                                archive_field_sid_t *keys = (archive_field_sid_t *) MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(archive_field_sid_t));
                                archive_field_boolean_t *values = (archive_field_boolean_t *) MEMFILE_READ(
                                        memfile,
                                        prop_header->num_entries *
                                        sizeof(archive_field_boolean_t));
                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file, "[marker: %c (boolean)] [nentries: %d] [", entryMarker,
                                        prop_header->num_entries);
                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");
                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file,
                                                "%s%s",
                                                values[i] ? "true" : "false",
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "]\n");
                        }
                                break;
                        case MARKER_SYMBOL_PROP_INT8: PRINT_SIMPLE_PROPS(file,
                                                                             memfile,
                                                                             MEMFILE_TELL(memfile),
                                                                             nesting_level,
                                                                             archive_field_i8_t,
                                                                             "Int8",
                                                                             "%d");
                                break;
                        case MARKER_SYMBOL_PROP_INT16: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              MEMFILE_TELL(memfile),
                                                                              nesting_level,
                                                                              archive_field_i16_t,
                                                                              "Int16",
                                                                              "%d");
                                break;
                        case MARKER_SYMBOL_PROP_INT32: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              MEMFILE_TELL(memfile),
                                                                              nesting_level,
                                                                              archive_field_i32_t,
                                                                              "Int32",
                                                                              "%d");
                                break;
                        case MARKER_SYMBOL_PROP_INT64: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              MEMFILE_TELL(memfile),
                                                                              nesting_level,
                                                                              archive_field_i64_t,
                                                                              "Int64",
                                                                              "%"
                                                                                      PRIi64);
                                break;
                        case MARKER_SYMBOL_PROP_UINT8: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              MEMFILE_TELL(memfile),
                                                                              nesting_level,
                                                                              archive_field_u8_t,
                                                                              "UInt8",
                                                                              "%d");
                                break;
                        case MARKER_SYMBOL_PROP_UINT16: PRINT_SIMPLE_PROPS(file,
                                                                               memfile,
                                                                               MEMFILE_TELL(memfile),
                                                                               nesting_level,
                                                                               archive_field_u16_t,
                                                                               "UInt16",
                                                                               "%d");
                                break;
                        case MARKER_SYMBOL_PROP_UINT32: PRINT_SIMPLE_PROPS(file,
                                                                               memfile,
                                                                               MEMFILE_TELL(memfile),
                                                                               nesting_level,
                                                                               archive_field_u32_t,
                                                                               "UInt32",
                                                                               "%d");
                                break;
                        case MARKER_SYMBOL_PROP_UINT64: PRINT_SIMPLE_PROPS(file,
                                                                               memfile,
                                                                               MEMFILE_TELL(memfile),
                                                                               nesting_level,
                                                                               archive_field_u64_t,
                                                                               "UInt64",
                                                                               "%"
                                                                                       PRIu64);
                                break;
                        case MARKER_SYMBOL_PROP_REAL: PRINT_SIMPLE_PROPS(file,
                                                                             memfile,
                                                                             MEMFILE_TELL(memfile),
                                                                             nesting_level,
                                                                             archive_field_number_t,
                                                                             "Float",
                                                                             "%f");
                                break;
                        case MARKER_SYMBOL_PROP_TEXT: PRINT_SIMPLE_PROPS(file,
                                                                             memfile,
                                                                             MEMFILE_TELL(memfile),
                                                                             nesting_level,
                                                                             archive_field_sid_t,
                                                                             "Text",
                                                                             "%"
                                                                                     PRIu64
                                                                                     "");
                                break;
                        case MARKER_SYMBOL_PROP_OBJECT: {
                                var_prop prop;
                                int_embedded_var_props_read(&prop, memfile);
                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file, "[marker: %c (Object)] [nentries: %d] [", entryMarker,
                                        prop.header->num_entries);
                                for (u32 i = 0; i < prop.header->num_entries; i++) {
                                        fprintf(file,
                                                "key: %"PRIu64"%s",
                                                prop.keys[i],
                                                i + 1 < prop.header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");
                                for (u32 i = 0; i < prop.header->num_entries; i++) {
                                        fprintf(file,
                                                "offsets: 0x%04x%s",
                                                (unsigned) prop.offsets[i],
                                                i + 1 < prop.header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [\n");

                                char nextEntryMarker;
                                do {
                                        if (!_archive_print_object(file, memfile, nesting_level + 1)) {
                                                return false;
                                        }
                                        nextEntryMarker = *MEMFILE_PEEK_TYPE(memfile, char);
                                } while (nextEntryMarker == MARKER_SYMBOL_OBJECT_BEGIN);

                        }
                                break;
                        case MARKER_SYMBOL_PROP_NULL_ARRAY: {
                                prop_header *prop_header = MEMFILE_READ_TYPE(memfile, struct prop_header);

                                archive_field_sid_t *keys = (archive_field_sid_t *) MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(archive_field_sid_t));
                                u32 *nullArrayLengths;

                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file,
                                        "[marker: %c (Null Array)] [nentries: %d] [",
                                        entryMarker,
                                        prop_header->num_entries);

                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");

                                nullArrayLengths = (u32 *) MEMFILE_READ(memfile,
                                                                                prop_header->num_entries *
                                                                                sizeof(u32));

                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file,
                                                "nentries: %d%s",
                                                nullArrayLengths[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }

                                fprintf(file, "]\n");
                        }
                                break;
                        case MARKER_SYMBOL_PROP_BOOLEAN_ARRAY: {
                                prop_header *prop_header = MEMFILE_READ_TYPE(memfile, struct prop_header);

                                archive_field_sid_t *keys = (archive_field_sid_t *) MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(archive_field_sid_t));
                                u32 *array_lengths;

                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file,
                                        "[marker: %c (Boolean Array)] [nentries: %d] [",
                                        entryMarker,
                                        prop_header->num_entries);

                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");

                                array_lengths = (u32 *) MEMFILE_READ(memfile,
                                                                             prop_header->num_entries *
                                                                             sizeof(u32));

                                for (u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file,
                                                "arrayLength: %d%s",
                                                array_lengths[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }

                                fprintf(file, "] [");

                                for (u32 array_idx = 0; array_idx < prop_header->num_entries; array_idx++) {
                                        archive_field_boolean_t *values = (archive_field_boolean_t *) MEMFILE_READ(
                                                memfile,
                                                array_lengths[array_idx] *
                                                sizeof(archive_field_boolean_t));
                                        fprintf(file, "[");
                                        for (u32 i = 0; i < array_lengths[array_idx]; i++) {
                                                fprintf(file,
                                                        "value: %s%s",
                                                        values[i] ? "true" : "false",
                                                        i + 1 < array_lengths[array_idx] ? ", " : "");
                                        }
                                        fprintf(file, "]%s", array_idx + 1 < prop_header->num_entries ? ", " : "");
                                }

                                fprintf(file, "]\n");
                        }
                                break;
                                break;
                        case MARKER_SYMBOL_PROP_INT8_ARRAY: {
                                PRINT_ARRAY_PROPS(memfile,
                                                  MEMFILE_TELL(memfile),
                                                  nesting_level,
                                                  entryMarker,
                                                  archive_field_i8_t,
                                                  "Int8 Array",
                                                  "%d");
                        }
                                break;
                        case MARKER_SYMBOL_PROP_INT16_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   MEMFILE_TELL(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   archive_field_i16_t,
                                                                                   "Int16 Array",
                                                                                   "%d");
                                break;
                        case MARKER_SYMBOL_PROP_INT32_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   MEMFILE_TELL(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   archive_field_i32_t,
                                                                                   "Int32 Array",
                                                                                   "%d");
                                break;
                        case MARKER_SYMBOL_PROP_INT64_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   MEMFILE_TELL(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   archive_field_i64_t,
                                                                                   "Int64 Array",
                                                                                   "%"
                                                                                           PRIi64);
                                break;
                        case MARKER_SYMBOL_PROP_UINT8_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   MEMFILE_TELL(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   archive_field_u8_t,
                                                                                   "UInt8 Array",
                                                                                   "%d");
                                break;
                        case MARKER_SYMBOL_PROP_UINT16_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                    MEMFILE_TELL(memfile),
                                                                                    nesting_level,
                                                                                    entryMarker,
                                                                                    archive_field_u16_t,
                                                                                    "UInt16 Array",
                                                                                    "%d");
                                break;
                        case MARKER_SYMBOL_PROP_UINT32_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                    MEMFILE_TELL(memfile),
                                                                                    nesting_level,
                                                                                    entryMarker,
                                                                                    archive_field_u32_t,
                                                                                    "UInt32 Array",
                                                                                    "%d");
                                break;
                        case MARKER_SYMBOL_PROP_UINT64_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                    MEMFILE_TELL(memfile),
                                                                                    nesting_level,
                                                                                    entryMarker,
                                                                                    archive_field_u64_t,
                                                                                    "UInt64 Array",
                                                                                    "%"
                                                                                            PRIu64);
                                break;
                        case MARKER_SYMBOL_PROP_REAL_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                  MEMFILE_TELL(memfile),
                                                                                  nesting_level,
                                                                                  entryMarker,
                                                                                  archive_field_number_t,
                                                                                  "Float Array",
                                                                                  "%f");
                                break;
                        case MARKER_SYMBOL_PROP_TEXT_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                  MEMFILE_TELL(memfile),
                                                                                  nesting_level,
                                                                                  entryMarker,
                                                                                  archive_field_sid_t,
                                                                                  "Text Array",
                                                                                  "%"
                                                                                          PRIu64
                                                                                          "");
                                break;
                        case MARKER_SYMBOL_PROP_OBJECT_ARRAY:
                                if (!_archive_print_object_array_from_memfile(file, memfile, nesting_level)) {
                                        return false;
                                }
                                break;
                        case MARKER_SYMBOL_OBJECT_END:
                                continue_read = false;
                                break;
                        default: {
                                char buffer[256];
                                sprintf(buffer,
                                        "Parsing ERROR: unexpected marker [%c] was detected in file %p",
                                        entryMarker,
                                        memfile);
                                ERROR(ERR_CORRUPTED, buffer);
                                return false;
                        }
                }
        }

        offset = MEMFILE_TELL(memfile);
        char end_marker = *MEMFILE_READ_TYPE(memfile, char);
        assert (end_marker == MARKER_SYMBOL_OBJECT_END);
        nesting_level--;
        fprintf(file, "0x%04x ", offset);
        INTENT_LINE(nesting_level);
        fprintf(file, "[marker: %c (EndObject)]\n", end_marker);
        return true;
}

static bool is_valid_file(const archive_header *header)
{
        if (ARRAY_LENGTH(header->magic) != strlen(CARBON_ARCHIVE_MAGIC)) {
                return false;
        } else {
                for (size_t i = 0; i < ARRAY_LENGTH(header->magic); i++) {
                        if (header->magic[i] != CARBON_ARCHIVE_MAGIC[i]) {
                                return false;
                        }
                }
                if (header->version != CARBON_ARCHIVE_VERSION) {
                        return false;
                }
                if (header->root_object_header_offset == 0) {
                        return false;
                }
                return true;
        }
}

static void print_record_header_from_memfile(FILE *file, memfile *memfile)
{
        unsigned offset = MEMFILE_TELL(memfile);
        record_header *header = MEMFILE_READ_TYPE(memfile, record_header);
        record_flags flags;
        memset(&flags, 0, sizeof(record_flags));
        flags.value = header->flags;
        char *flags_string = record_header_flags_to_string(&flags);
        fprintf(file, "0x%04x ", offset);
        fprintf(file,
                "[marker: %c] [flags: %s] [record_size: 0x%04x]\n",
                header->marker,
                flags_string,
                (unsigned) header->record_size);
        free(flags_string);
}

static bool print_header_from_memfile(FILE *file, memfile *memfile)
{
        unsigned offset = MEMFILE_TELL(memfile);
        assert(MEMFILE_SIZE(memfile) > sizeof(archive_header));
        archive_header *header = MEMFILE_READ_TYPE(memfile, archive_header);
        if (!is_valid_file(header)) {
                return ERROR(ERR_NOARCHIVEFILE, NULL);
        }

        fprintf(file, "0x%04x ", offset);
        fprintf(file,
                "[magic: " CARBON_ARCHIVE_MAGIC "] [version: %d] [recordOffset: 0x%04x] [str_buf-id-offset-index: 0x%04x]\n",
                header->version,
                (unsigned) header->root_object_header_offset,
                (unsigned) header->string_id_to_offset_index_offset);
        return true;
}

static bool print_embedded_dic_from_memfile(FILE *file, memfile *memfile)
{
        packer strategy;
        string_tab_flags_u flags;

        unsigned offset = MEMFILE_TELL(memfile);
        string_table_header *header = MEMFILE_READ_TYPE(memfile, string_table_header);
        if (header->marker != global_marker_symbols[MARKER_TYPE_EMBEDDED_STR_DIC].symbol) {
                char buffer[256];
                sprintf(buffer,
                        "expected [%c] marker, but found [%c]",
                        global_marker_symbols[MARKER_TYPE_EMBEDDED_STR_DIC].symbol,
                        header->marker);
                ERROR(ERR_CORRUPTED, buffer);
                return false;
        }
        flags.value = header->flags;

        char *flagsStr = embedded_dic_flags_to_string(&flags);
        fprintf(file, "0x%04x ", offset);
        fprintf(file,
                "[marker: %c] [nentries: %d] [flags: %s] [first-entry-off: 0x%04x] [extra-size: %" PRIu64 "]\n",
                header->marker,
                header->num_entries,
                flagsStr,
                (unsigned) header->first_entry,
                header->compressor_extra_size);
        free(flagsStr);

        if (pack_by_flags(&strategy, flags.value) != true) {
                return ERROR(ERR_NOCOMPRESSOR, NULL);
        }

        pack_print_extra(&strategy, file, memfile);

        while ((*MEMFILE_PEEK_TYPE(memfile, char)) == global_marker_symbols[MARKER_TYPE_EMBEDDED_UNCOMP_STR].symbol) {
                unsigned offset = MEMFILE_TELL(memfile);
                string_entry_header header = *MEMFILE_READ_TYPE(memfile, string_entry_header);
                fprintf(file,
                        "0x%04x    [marker: %c] [next-entry-off: 0x%04zx] [str_buf-id: %"PRIu64"] [str_buf-length: %"PRIu32"]",
                        offset,
                        header.marker,
                        (size_t) header.next_entry_off,
                        header.string_id,
                        header.string_len);
                pack_print_encoded(&strategy, file, memfile, header.string_len);
                fprintf(file, "\n");
        }

        return pack_drop(&strategy);
}

static bool print_archive_from_memfile(FILE *file, memfile *memfile)
{
        if (!print_header_from_memfile(file, memfile)) {
                return false;
        }
        if (!print_embedded_dic_from_memfile(file, memfile)) {
                return false;
        }
        print_record_header_from_memfile(file, memfile);
        if (!_archive_print_object(file, memfile, 0)) {
                return false;
        }
        return true;
}

static object_flags_u *get_flags(object_flags_u *flags, column_doc_obj *columndoc)
{
        ZERO_MEMORY(flags, sizeof(object_flags_u));
        flags->bits.has_null_props = (columndoc->null_prop_keys.num_elems > 0);
        flags->bits.has_bool_props = (columndoc->bool_prop_keys.num_elems > 0);
        flags->bits.has_int8_props = (columndoc->int8_prop_keys.num_elems > 0);
        flags->bits.has_int16_props = (columndoc->int16_prop_keys.num_elems > 0);
        flags->bits.has_int32_props = (columndoc->int32_prop_keys.num_elems > 0);
        flags->bits.has_int64_props = (columndoc->int64_prop_keys.num_elems > 0);
        flags->bits.has_uint8_props = (columndoc->uint8_prop_keys.num_elems > 0);
        flags->bits.has_uint16_props = (columndoc->uint16_prop_keys.num_elems > 0);
        flags->bits.has_uint32_props = (columndoc->uin32_prop_keys.num_elems > 0);
        flags->bits.has_uint64_props = (columndoc->uint64_prop_keys.num_elems > 0);
        flags->bits.has_float_props = (columndoc->float_prop_keys.num_elems > 0);
        flags->bits.has_string_props = (columndoc->string_prop_keys.num_elems > 0);
        flags->bits.has_object_props = (columndoc->obj_prop_keys.num_elems > 0);
        flags->bits.has_null_array_props = (columndoc->null_array_prop_keys.num_elems > 0);
        flags->bits.has_bool_array_props = (columndoc->bool_array_prop_keys.num_elems > 0);
        flags->bits.has_int8_array_props = (columndoc->int8_array_prop_keys.num_elems > 0);
        flags->bits.has_int16_array_props = (columndoc->int16_array_prop_keys.num_elems > 0);
        flags->bits.has_int32_array_props = (columndoc->int32_array_prop_keys.num_elems > 0);
        flags->bits.has_int64_array_props = (columndoc->int64_array_prop_keys.num_elems > 0);
        flags->bits.has_uint8_array_props = (columndoc->uint8_array_prop_keys.num_elems > 0);
        flags->bits.has_uint16_array_props = (columndoc->uint16_array_prop_keys.num_elems > 0);
        flags->bits.has_uint32_array_props = (columndoc->uint32_array_prop_keys.num_elems > 0);
        flags->bits.has_uint64_array_props = (columndoc->uint64_array_prop_keys.num_elems > 0);
        flags->bits.has_float_array_props = (columndoc->float_array_prop_keys.num_elems > 0);
        flags->bits.has_string_array_props = (columndoc->string_array_prop_keys.num_elems > 0);
        flags->bits.has_object_array_props = (columndoc->obj_array_props.num_elems > 0);
        //assert(flags->value != 0);
        return flags;
}

static bool init_decompressor(packer *strategy, u8 flags);

static bool read_stringtable(string_table *table, FILE *disk_file);

static bool read_record(record_header *header_read, archive *archive, FILE *disk_file,
                        offset_t record_header_offset);

static bool read_string_id_to_offset_index(archive *archive, const char *file_path,
                                           offset_t string_id_to_offset_index_offset);

bool archive_open(archive *out, const char *file_path)
{
        int status;
        FILE *disk_file;

        out->disk_file_path = strdup(file_path);
        disk_file = fopen(out->disk_file_path, "r");
        if (!disk_file) {
                str_buf sb;
                char cwd[PATH_MAX];
                str_buf_create(&sb);

                str_buf_add(&sb, "File '");
                str_buf_add(&sb, file_path);
                str_buf_add(&sb, "' not found in current working directory ('");
                str_buf_add(&sb, getcwd(cwd, sizeof(cwd)));
                str_buf_add(&sb, "')");
                ERROR(ERR_FOPEN_FAILED, str_buf_cstr(&sb));
                str_buf_drop(&sb);
                return false;
        } else {
                archive_header header;
                size_t nread = fread(&header, sizeof(archive_header), 1, disk_file);
                if (nread != 1) {
                        fclose(disk_file);
                        ERROR(ERR_IO, NULL);
                        return false;
                } else {
                        if (!is_valid_file(&header)) {
                                ERROR(ERR_FORMATVERERR, NULL);
                                return false;
                        } else {
                                out->query_index_string_id_to_offset = NULL;
                                out->string_id_cache = NULL;

                                record_header record_header;

                                if ((status = read_stringtable(&out->string_table, disk_file)) != true) {
                                        return status;
                                }
                                if ((status = read_record(&record_header,
                                                          out,
                                                          disk_file,
                                                          header.root_object_header_offset)) != true) {
                                        return status;
                                }

                                if (header.string_id_to_offset_index_offset != 0) {
                                        if ((status = read_string_id_to_offset_index(out,
                                                                                     file_path,
                                                                                     header.string_id_to_offset_index_offset)) !=
                                            true) {
                                                ERROR(ERR_NOTFOUND, NULL);
                                                return status;
                                        }
                                }

                                fseek(disk_file, sizeof(archive_header), SEEK_SET);

                                offset_t data_start = ftell(disk_file);
                                fseek(disk_file, 0, SEEK_END);
                                offset_t file_size = ftell(disk_file);

                                fclose(disk_file);

                                size_t string_table_size = header.root_object_header_offset - data_start;
                                size_t record_table_size = record_header.record_size;
                                size_t string_id_index = file_size - header.string_id_to_offset_index_offset;

                                out->info.string_table_size = string_table_size;
                                out->info.record_table_size = record_table_size;
                                out->info.num_embeddded_strings = out->string_table.num_embeddded_strings;
                                out->info.string_id_index_size = string_id_index;
                                out->default_query = MALLOC(sizeof(query));
                                query_create(out->default_query, out);

                        }
                }
        }

        return true;
}

bool archive_get_info(archive_info *info, const archive *archive)
{
        *info = archive->info;
        return true;
}

bool archive_close(archive *archive)
{
        archive_drop_indexes(archive);
        archive_drop_query_string_id_cache(archive);
        free(archive->disk_file_path);
        MEMBLOCK_DROP(archive->record_table.record_db);
        query_drop(archive->default_query);
        free(archive->default_query);
        return true;
}

bool archive_drop_indexes(archive *archive)
{
        if (archive->query_index_string_id_to_offset) {
                query_drop_index_string_id_to_offset(archive->query_index_string_id_to_offset);
                archive->query_index_string_id_to_offset = NULL;
        }
        return true;
}

bool archive_query_run(query *query, archive *archive)
{
        if (query_create(query, archive)) {
                bool has_index = false;
                archive_has_query_index_string_id_to_offset(&has_index, archive);
                if (!has_index) {
                        query_create_index_string_id_to_offset(&archive->query_index_string_id_to_offset, query);
                }
                bool has_cache = false;
                archive_hash_query_string_id_cache(&has_cache, archive);
                if (!has_cache) {
                        string_id_cache_create_lru(&archive->string_id_cache, archive);
                }
                return true;
        } else {
                return false;
        }
}

bool archive_has_query_index_string_id_to_offset(bool *state, archive *archive)
{
        *state = (archive->query_index_string_id_to_offset != NULL);
        return true;
}

bool archive_hash_query_string_id_cache(bool *has_cache, archive *archive)
{
        *has_cache = archive->string_id_cache != NULL;
        return true;
}

bool archive_drop_query_string_id_cache(archive *archive)
{
        if (archive->string_id_cache) {
                string_id_cache_drop(archive->string_id_cache);
                archive->string_id_cache = NULL;
        }
        return true;
}

struct string_cache *archive_get_query_string_id_cache(archive *archive)
{
        return archive->string_id_cache;
}

query *archive_query_default(archive *archive)
{
        return archive ? archive->default_query : NULL;
}

static bool init_decompressor(packer *strategy, u8 flags)
{
        if (pack_by_flags(strategy, flags) != true) {
                return false;
        }
        return true;
}

static bool read_stringtable(string_table *table, FILE *disk_file)
{
        assert(disk_file);

        string_table_header header;
        string_tab_flags_u flags;

        size_t num_read = fread(&header, sizeof(string_table_header), 1, disk_file);
        if (num_read != 1) {
                return ERROR(ERR_IO, NULL);
        }
        if (header.marker != global_marker_symbols[MARKER_TYPE_EMBEDDED_STR_DIC].symbol) {
                return ERROR(ERR_CORRUPTED, NULL);
        }

        flags.value = header.flags;
        table->first_entry_off = header.first_entry;
        table->num_embeddded_strings = header.num_entries;

        if ((init_decompressor(&table->compressor, flags.value)) != true) {
                return false;
        }
        if ((pack_read_extra(&table->compressor, disk_file, header.compressor_extra_size)) != true) {
                return false;
        }
        return true;
}

static bool read_record(record_header *header_read, archive *archive, FILE *disk_file,
                        offset_t record_header_offset)
{
        fseek(disk_file, record_header_offset, SEEK_SET);
        record_header header;
        if (fread(&header, sizeof(record_header), 1, disk_file) != 1) {
                ERROR(ERR_CORRUPTED, NULL);
                return false;
        } else {
                archive->record_table.flags.value = header.flags;
                bool status = MEMBLOCK_FROM_FILE(&archive->record_table.record_db, disk_file, header.record_size);
                if (!status) {
                        return false;
                }

                memfile memfile;
                MEMFILE_OPEN(&memfile, archive->record_table.record_db, READ_ONLY);
                if (*MEMFILE_PEEK_TYPE(&memfile, char) != MARKER_SYMBOL_OBJECT_BEGIN) {
                        ERROR(ERR_CORRUPTED, NULL);
                        status = false;
                }

                *header_read = header;
                return true;
        }
}

static bool read_string_id_to_offset_index(archive *archive, const char *file_path,
                                           offset_t string_id_to_offset_index_offset)
{
        return query_index_id_to_offset_deserialize(&archive->query_index_string_id_to_offset,
                                                        file_path,
                                                        string_id_to_offset_index_offset);
}







/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/stdinc.h>
#include <karbonit/std/hash.h>
#include <karbonit/error.h>
#include <karbonit/archive/cache.h>

struct cache_entry {
        struct cache_entry *prev, *next;
        archive_field_sid_t id;
        char *string;
};

struct lru_list {
        struct cache_entry *most_recent;
        struct cache_entry *lest_recent;
        struct cache_entry entries[1024];
};

struct string_cache {
        vec ofType(struct lru_list) list_entries;
        sid_cache_stats statistics;
        query query;
        size_t capacity;
};

static void init_list(struct lru_list *list)
{
        size_t num_entries = sizeof(list->entries) / sizeof(list->entries[0]);
        list->most_recent = list->entries + 0;
        list->lest_recent = list->entries + num_entries - 1;
        for (size_t i = 0; i < num_entries; i++) {
                struct cache_entry *entry = list->entries + i;
                entry->prev = i == 0 ? NULL : &list->entries[i - 1];
                entry->next = i + 1 < num_entries ? &list->entries[i + 1] : NULL;
        }
}

bool string_id_cache_create_lru(struct string_cache **cache, archive *archive)
{
        DECLARE_AND_INIT(archive_info, archive_info)
        archive_get_info(&archive_info, archive);
        u32 capacity = archive_info.num_embeddded_strings * 0.25f;
        return string_id_cache_create_lru_ex(cache, archive, capacity);
}

bool string_id_cache_create_lru_ex(struct string_cache **cache, archive *archive, size_t capacity)
{
        struct string_cache *result = MALLOC(sizeof(struct string_cache));

        query_create(&result->query, archive);
        result->capacity = capacity;

        size_t num_buckets = JAK_MAX(1, capacity);
        vec_create(&result->list_entries, sizeof(struct lru_list), num_buckets);
        for (size_t i = 0; i < num_buckets; i++) {
                struct lru_list *list = VEC_NEW_AND_GET(&result->list_entries, struct lru_list);
                ZERO_MEMORY(list, sizeof(struct lru_list));
                init_list(list);
        }

        string_id_cache_reset_statistics(result);
        *cache = result;

        return true;
}

bool string_id_cache_get_size(size_t *size, const struct string_cache *cache)
{
        *size = cache->capacity;
        return true;
}

static void make_most_recent(struct lru_list *list, struct cache_entry *entry)
{
        if (list->most_recent == entry) {
                return;
        } else {
                if (entry->prev) {
                        entry->prev->next = entry->next;
                }
                if (entry->next) {
                        entry->next->prev = entry->prev;
                } else {
                        list->lest_recent = entry->prev;
                }
                list->most_recent->prev = entry;
                entry->next = list->most_recent;
                list->most_recent = entry;
        }
}

char *string_id_cache_get(struct string_cache *cache, archive_field_sid_t id)
{
        hash32_t id_hash = HASH_BERNSTEIN(sizeof(archive_field_sid_t), &id);
        size_t bucket_pos = id_hash % cache->list_entries.num_elems;
        struct lru_list *list = VEC_GET(&cache->list_entries, bucket_pos, struct lru_list);
        struct cache_entry *cursor = list->most_recent;
        while (cursor != NULL) {
                if (id == cursor->id) {
                        make_most_recent(list, cursor);
                        cache->statistics.num_hits++;
                        return strdup(cursor->string);
                }
                cursor = cursor->next;
        }
        char *result = query_fetch_string_by_id_nocache(&cache->query, id);
        assert(result);
        if (list->lest_recent->string != NULL) {
                cache->statistics.num_evicted++;
        }
        list->lest_recent->string = result;
        list->lest_recent->id = id;
        make_most_recent(list, list->lest_recent);
        cache->statistics.num_misses++;
        return strdup(result);
}

bool string_id_cache_get_statistics(sid_cache_stats *statistics, struct string_cache *cache)
{
        *statistics = cache->statistics;
        return true;
}

bool string_id_cache_reset_statistics(struct string_cache *cache)
{
        ZERO_MEMORY(&cache->statistics, sizeof(sid_cache_stats));
        return true;
}

bool string_id_cache_drop(struct string_cache *cache)
{
        for (size_t i = 0; i < cache->list_entries.num_elems; i++) {
                struct lru_list *entry = VEC_GET(&cache->list_entries, i, struct lru_list);
                for (size_t k = 0; k < sizeof(entry->entries) / sizeof(entry->entries[0]); k++) {
                        struct cache_entry *it = &entry->entries[k];
                        if (it->string) {
                                free(it->string);
                        }
                }
        }
        vec_drop(&cache->list_entries);
        return true;
}


/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>
#include <inttypes.h>

#include <karbonit/archive/column_doc.h>
#include <karbonit/archive/doc.h>

static void
setup_object(column_doc_obj *model, column_doc *parent, archive_field_sid_t key, size_t idx);

static bool object_put(column_doc_obj *model, const doc_entries *entry,
                       string_dict *dic);

static bool import_object(column_doc_obj *dst, const doc_obj *doc,
                          string_dict *dic);

static bool
_column_doc_print_object(FILE *file, const column_doc_obj *object, string_dict *dic);

static const char *get_type_name(archive_field_e type);

static void object_array_key_columns_create(vec ofType(column_doc_group) *columns);

static column_doc_column *object_array_key_columns_find_or_new(
        vec ofType(column_doc_group) *columns, archive_field_sid_t array_key,
        archive_field_sid_t nested_object_entry_key, archive_field_e nested_object_entry_type);

static bool object_array_key_column_push(column_doc_column *col, const doc_entries *entry,
                                         u32 array_idx, string_dict *dic,
                                         column_doc_obj *model);

bool columndoc_create(column_doc *columndoc, const doc *doc,
                      const doc_bulk *bulk,
                      const doc_entries *entries, string_dict *dic)
{
        columndoc->dic = dic;
        columndoc->doc = doc;
        columndoc->bulk = bulk;

        const char *root_string = "/";
        archive_field_sid_t *rootId;

        string_dict_insert(dic, &rootId, (char *const *) &root_string, 1, 0);

        setup_object(&columndoc->columndoc, columndoc, *rootId, 0);

        string_dict_free(dic, rootId);

        const doc_obj *root = doc_entries_get_root(entries);
        if (!import_object(&columndoc->columndoc, root, dic)) {
                return false;
        }

        return true;
}

static void object_array_key_columns_drop(vec ofType(column_doc_group) *columns);

static void object_meta_model_free(column_doc_obj *columndoc)
{
        vec_drop(&columndoc->bool_prop_keys);
        vec_drop(&columndoc->int8_prop_keys);
        vec_drop(&columndoc->int16_prop_keys);
        vec_drop(&columndoc->int32_prop_keys);
        vec_drop(&columndoc->int64_prop_keys);
        vec_drop(&columndoc->uint8_prop_keys);
        vec_drop(&columndoc->uint16_prop_keys);
        vec_drop(&columndoc->uin32_prop_keys);
        vec_drop(&columndoc->uint64_prop_keys);
        vec_drop(&columndoc->string_prop_keys);
        vec_drop(&columndoc->float_prop_keys);
        vec_drop(&columndoc->null_prop_keys);
        vec_drop(&columndoc->obj_prop_keys);

        vec_drop(&columndoc->bool_array_prop_keys);
        vec_drop(&columndoc->int8_array_prop_keys);
        vec_drop(&columndoc->int16_array_prop_keys);
        vec_drop(&columndoc->int32_array_prop_keys);
        vec_drop(&columndoc->int64_array_prop_keys);
        vec_drop(&columndoc->uint8_array_prop_keys);
        vec_drop(&columndoc->uint16_array_prop_keys);
        vec_drop(&columndoc->uint32_array_prop_keys);
        vec_drop(&columndoc->uint64_array_prop_keys);
        vec_drop(&columndoc->string_array_prop_keys);
        vec_drop(&columndoc->float_array_prop_keys);
        vec_drop(&columndoc->null_array_prop_keys);

        vec_drop(&columndoc->bool_prop_vals);
        vec_drop(&columndoc->int8_prop_vals);
        vec_drop(&columndoc->int16_prop_vals);
        vec_drop(&columndoc->int32_prop_vals);
        vec_drop(&columndoc->int64_prop_vals);
        vec_drop(&columndoc->uint8_prop_vals);
        vec_drop(&columndoc->uint16_prop_vals);
        vec_drop(&columndoc->uint32_prop_vals);
        vec_drop(&columndoc->uint64_prop_vals);
        vec_drop(&columndoc->float_prop_vals);
        vec_drop(&columndoc->string_prop_vals);

        for (size_t i = 0; i < columndoc->bool_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->bool_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->bool_array_prop_vals);

        for (size_t i = 0; i < columndoc->int8_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int8_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int8_array_prop_vals);

        for (size_t i = 0; i < columndoc->int16_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int16_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int16_array_prop_vals);

        for (size_t i = 0; i < columndoc->int32_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int32_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int32_array_prop_vals);

        for (size_t i = 0; i < columndoc->int64_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int64_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int64_array_prop_vals);

        for (size_t i = 0; i < columndoc->uint8_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint8_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint8_array_prop_vals);

        for (size_t i = 0; i < columndoc->uint16_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint16_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint16_array_prop_vals);

        for (size_t i = 0; i < columndoc->uint32_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint32_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint32_array_prop_vals);

        for (size_t i = 0; i < columndoc->ui64_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->ui64_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->ui64_array_prop_vals);

        for (size_t i = 0; i < columndoc->float_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->float_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->float_array_prop_vals);

        for (size_t i = 0; i < columndoc->string_array_prop_vals.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->string_array_prop_vals, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->string_array_prop_vals);

        vec_drop(&columndoc->null_array_prop_vals);

        vec_drop(&columndoc->bool_val_idxs);
        vec_drop(&columndoc->int8_val_idxs);
        vec_drop(&columndoc->int16_val_idxs);
        vec_drop(&columndoc->int32_val_idxs);
        vec_drop(&columndoc->int64_val_idxs);
        vec_drop(&columndoc->uint8_val_idxs);
        vec_drop(&columndoc->uint16_val_idxs);
        vec_drop(&columndoc->uint32_val_idxs);
        vec_drop(&columndoc->uint64_val_idxs);
        vec_drop(&columndoc->float_val_idxs);
        vec_drop(&columndoc->string_val_idxs);

        for (size_t i = 0; i < columndoc->bool_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->bool_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->bool_array_idxs);

        for (size_t i = 0; i < columndoc->int8_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int8_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int8_array_idxs);

        for (size_t i = 0; i < columndoc->int16_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int16_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int16_array_idxs);

        for (size_t i = 0; i < columndoc->int32_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int32_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int32_array_idxs);

        for (size_t i = 0; i < columndoc->int64_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->int64_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->int64_array_idxs);

        for (size_t i = 0; i < columndoc->uint8_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint8_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint8_array_idxs);

        for (size_t i = 0; i < columndoc->uint16_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint16_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint16_array_idxs);

        for (size_t i = 0; i < columndoc->uint32_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint32_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint32_array_idxs);

        for (size_t i = 0; i < columndoc->uint64_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->uint64_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->uint64_array_idxs);

        for (size_t i = 0; i < columndoc->float_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->float_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->float_array_idxs);

        for (size_t i = 0; i < columndoc->string_array_idxs.num_elems; i++) {
                vec *v = VEC_GET(&columndoc->string_array_idxs, i, vec);
                vec_drop(v);
        }
        vec_drop(&columndoc->string_array_idxs);

        for (size_t i = 0; i < columndoc->obj_prop_vals.num_elems; i++) {
                column_doc_obj *object = VEC_GET(&columndoc->obj_prop_vals, i, column_doc_obj);
                object_meta_model_free(object);
        }
        vec_drop(&columndoc->obj_prop_vals);

        object_array_key_columns_drop(&columndoc->obj_array_props);
}

bool columndoc_free(column_doc *doc)
{
        object_meta_model_free(&doc->columndoc);
        return true;
}

#define PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, suffix)                                             \
{                                                                                                                      \
    fprintf(file, "\"%s\": { ", type_name);                                                                            \
    if(!vec_is_empty((key_vector))) {                                                                           \
        fprintf(file, "\"Keys\": [ ");                                                                                 \
        for (size_t i = 0; i < (key_vector)->num_elems; i++) {                                                         \
            archive_field_sid_t string_id = *VEC_GET((key_vector), i, archive_field_sid_t);                    \
            fprintf(file, "%"PRIu64"%s", string_id, i + 1 < (key_vector)->num_elems ? ", " : "");                      \
        }                                                                                                              \
        fprintf(file, "], ");                                                                                          \
        fprintf(file, "\"Keys Decoded\": [ ");                                                                         \
        for (size_t i = 0; i < (key_vector)->num_elems; i++) {                                                         \
            archive_field_sid_t string_id = *VEC_GET((key_vector), i, archive_field_sid_t);                    \
            char **encString = string_dict_extract(dic, &string_id, 1);                                              \
            fprintf(file, "\"%s\"%s", encString[0], i + 1 < (key_vector)->num_elems ? ", " : "");                      \
            string_dict_free(dic, encString);                                                                        \
        }                                                                                                              \
        fprintf(file, "]%s", suffix);                                                                                  \
    }                                                                                                                  \
}                                                                                                                      \

#define PRINT_PRIMITIVE_COLUMN(file, type_name, key_vector, value_vector, keyIndicesVector, dic, TYPE, FORMAT_STR)     \
{                                                                                                                      \
    PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")                                                   \
    if(!vec_is_empty((key_vector))) {                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (value_vector)->num_elems; i++) {                                                       \
            TYPE value = *VEC_GET(value_vector, i, TYPE);                                                    \
            fprintf(file, FORMAT_STR "%s", value, i + 1 < (value_vector)->num_elems ? ", " : "");                      \
        }                                                                                                              \
        fprintf(file, "] ");                                                                                           \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

#define PRINT_PRIMITIVE_BOOLEAN_COLUMN(file, type_name, key_vector, value_vector, dic)                                 \
{                                                                                                                      \
    PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")                                                   \
    if(!vec_is_empty((key_vector))) {                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (value_vector)->num_elems; i++) {                                                       \
            archive_field_boolean_t value = *VEC_GET(value_vector, i, archive_field_boolean_t);                                  \
            fprintf(file, "%s%s", value == 0 ? "false" : "true", i + 1 < (value_vector)->num_elems ? ", " : "");       \
        }                                                                                                              \
        fprintf(file, "]");                                                                                            \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

static void print_primitive_null(FILE *file, const char *type_name,
                                 const vec ofType(archive_field_sid_t) *key_vector,
                                 string_dict *dic)
{
        PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, "")
        fprintf(file, "}, ");
}

static bool print_primitive_objects(FILE *file, const char *type_name,
                                    const vec ofType(archive_field_sid_t) *key_vector,
                                    const vec ofType(column_doc_obj) *value_vector,
                                    string_dict *dic)
{
        PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")
        if (!vec_is_empty((key_vector))) {
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        const column_doc_obj *object = VEC_GET(value_vector, i, column_doc_obj);
                        if (!_column_doc_print_object(file, object, dic)) {
                                return false;
                        }
                        fprintf(file, "%s", i + 1 < (value_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "]");
        }
        fprintf(file, "}");
        return true;
}

#define PRINT_ARRAY(file, type_name, key_vector, value_vector, TYPE, TYPE_FORMAT, nonnull_expr)                        \
{                                                                                                                      \
    fprintf(file, "\"%s\": { ", type_name);                                                                            \
    if(!vec_is_empty((&key_vector))) {                                                                          \
        fprintf(file, "\"Keys\": [ ");                                                                                 \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            archive_field_sid_t string_id = *VEC_GET((&key_vector), i, archive_field_sid_t);                   \
            fprintf(file, "%"PRIu64"%s", string_id, i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
        }                                                                                                              \
        fprintf(file, "], ");                                                                                          \
        fprintf(file, "\"Keys Decoded\": [ ");                                                                         \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            archive_field_sid_t string_id = *VEC_GET((&key_vector), i, archive_field_sid_t);                   \
            char **encString = string_dict_extract(dic, &string_id, 1);                                              \
            fprintf(file, "\"%s\"%s", encString[0], i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
            string_dict_free(dic, encString);                                                                        \
        }                                                                                                              \
        fprintf(file, "],");                                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (&value_vector)->num_elems; i++) {                                                      \
            const vec ofType(TYPE) *values = VEC_GET(&value_vector, i, vec);               \
            fprintf(file, "[ ");                                                                                       \
            for (size_t j = 0; j < values->num_elems; j++) {                                                           \
                TYPE value = *VEC_GET(values, j, TYPE);                                                      \
                if (nonnull_expr) {                                                                                    \
                    fprintf(file, "" TYPE_FORMAT "%s", value, j + 1 < values->num_elems ? ", " : "");                  \
                } else {                                                                                               \
                    fprintf(file, NULL_TEXT "%s", j + 1 < values->num_elems ? ", " : "");                       \
                }                                                                                                      \
            }                                                                                                          \
            fprintf(file, "]%s ", i + 1 < (&value_vector)->num_elems ? "," : "");                                      \
        }                                                                                                              \
        fprintf(file, "]");                                                                                            \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

#define PRINT_BOOLEAN_ARRAY(file, type_name, key_vector, value_vector)                                                 \
{                                                                                                                      \
    fprintf(file, "\"%s\": { ", "Boolean");                                                                            \
    if(!vec_is_empty((&key_vector))) {                                                                          \
        fprintf(file, "\"Keys\": [ ");                                                                                 \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            archive_field_sid_t string_id = *VEC_GET((&key_vector), i, archive_field_sid_t);                   \
            fprintf(file, "%"PRIu64"%s", string_id, i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
        }                                                                                                              \
        fprintf(file, "], ");                                                                                          \
        fprintf(file, "\"Keys Decoded\": [ ");                                                                         \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            archive_field_sid_t string_id = *VEC_GET((&key_vector), i, archive_field_sid_t);                   \
            char **encString = string_dict_extract(dic, &string_id, 1);                                              \
            fprintf(file, "\"%s\"%s", encString[0], i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
            string_dict_free(dic, encString);                                                                        \
        }                                                                                                              \
        fprintf(file, "],");                                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (&value_vector)->num_elems; i++) {                                                      \
            const vec ofType(archive_field_boolean_t) *values = VEC_GET(&value_vector, i, vec);      \
            fprintf(file, "[ ");                                                                                       \
            for (size_t j = 0; j < values->num_elems; j++) {                                                           \
                archive_field_boolean_t value = *VEC_GET(values, j, archive_field_boolean_t);                                    \
                fprintf(file, "%s%s", value == 0 ? "false" : "true", j + 1 < values->num_elems ? ", " : "");           \
            }                                                                                                          \
            fprintf(file, "]%s ", i + 1 < (&value_vector)->num_elems ? "," : "");                                      \
        }                                                                                                              \
        fprintf(file, "]");                                                                                            \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

static void
print_array_null(FILE *file, const char *type_name, const vec ofType(archive_field_sid_t) *key_vector,
                 const vec ofType(u16) *value_vector, string_dict *dic)
{
        fprintf(file, "\"%s\": { ", type_name);
        if (!vec_is_empty((key_vector))) {
                fprintf(file, "\"Keys\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        archive_field_sid_t string_id = *VEC_GET((key_vector), i, archive_field_sid_t);
                        fprintf(file, "%"PRIu64"%s", string_id, i + 1 < (key_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "], ");
                fprintf(file, "\"Keys Decoded\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        archive_field_sid_t string_id = *VEC_GET((key_vector), i, archive_field_sid_t);
                        char **encString = string_dict_extract(dic, &string_id, 1);
                        fprintf(file, "\"%s\"%s", encString[0], i + 1 < (key_vector)->num_elems ? ", " : "");
                        string_dict_free(dic, encString);
                }
                fprintf(file, "],");
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        u16 amount = *VEC_GET(value_vector, i, u16);
                        fprintf(file, "%d%s", amount, i + 1 < value_vector->num_elems ? ", " : "");
                }
                fprintf(file, "]");
        }
        fprintf(file, "}, ");
}

static void print_array_strings(FILE *file, const char *type_name,
                                const vec ofType(archive_field_sid_t) *key_vector,
                                const vec ofType(Vector
                                                                       ofType(archive_field_sid_t)) *value_vector,
                                string_dict *dic)
{
        fprintf(file, "\"%s\": { ", type_name);
        if (!vec_is_empty((key_vector))) {
                fprintf(file, "\"Keys\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        archive_field_sid_t string_id = *VEC_GET((key_vector), i, archive_field_sid_t);
                        fprintf(file, "%"PRIu64"%s", string_id, i + 1 < (key_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "], ");
                fprintf(file, "\"Keys Decoded\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        archive_field_sid_t string_id_t = *VEC_GET((key_vector), i, archive_field_sid_t);
                        char **encString = string_dict_extract(dic, &string_id_t, 1);
                        fprintf(file, "\"%s\"%s", encString[0], i + 1 < (key_vector)->num_elems ? ", " : "");
                        string_dict_free(dic, encString);
                }
                fprintf(file, "],");
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        const vec ofType(archive_field_sid_t) *values = VEC_GET(value_vector, i,
                                                                                                  vec);
                        fprintf(file, "[");
                        for (size_t j = 0; j < values->num_elems; j++) {
                                archive_field_sid_t value = *VEC_GET(values, j, archive_field_sid_t);
                                fprintf(file, "%"PRIu64"%s", value, j + 1 < values->num_elems ? ", " : "");
                        }
                        fprintf(file, "]%s", i + 1 < (value_vector)->num_elems ? ", " : "");

                }
                fprintf(file, "], ");
                fprintf(file, "\"Values Decoded\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        const vec ofType(archive_field_sid_t) *values = VEC_GET(value_vector, i,
                                                                                                  vec);
                        fprintf(file, "[");
                        for (size_t j = 0; j < values->num_elems; j++) {
                                archive_field_sid_t value = *VEC_GET(values, j, archive_field_sid_t);

                                if (LIKELY(value != NULL_ENCODED_STRING)) {
                                        char **decoded = string_dict_extract(dic, &value, 1);
                                        fprintf(file, "\"%s\"%s", *decoded, j + 1 < values->num_elems ? ", " : "");
                                        string_dict_free(dic, decoded);
                                } else {
                                        fprintf(file, "null%s", j + 1 < values->num_elems ? ", " : "");
                                }

                        }
                        fprintf(file, "]%s", i + 1 < (value_vector)->num_elems ? ", " : "");

                }
                fprintf(file, "]");
        }
        fprintf(file, "}, ");
}

static void print_primitive_strings(FILE *file, const char *type_name,
                                    const vec ofType(archive_field_sid_t) *key_vector,
                                    const vec ofType(archive_field_sid_t) *value_vector,
                                    string_dict *dic)
{
        PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")
        if (!vec_is_empty((key_vector))) {
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        archive_field_sid_t string_id_t = *VEC_GET(value_vector, i, archive_field_sid_t);
                        fprintf(file, "%"PRIu64"%s", string_id_t, i + 1 < (value_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "], ");
                fprintf(file, "\"Values Decoded\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        archive_field_sid_t string_id_t = *VEC_GET(value_vector, i, archive_field_sid_t);
                        char **values = string_dict_extract(dic, &string_id_t, 1);
                        fprintf(file, "\"%s\"%s", *values, i + 1 < (value_vector)->num_elems ? ", " : "");
                        string_dict_free(dic, values);
                }
                fprintf(file, "]");
        }
        fprintf(file, "}, ");

}

#define PRINT_COLUMN(file, columnTable, array_idx, type, format_string)                                                \
{                                                                                                                      \
    const vec *column = VEC_GET(&columnTable->values, array_idx, vec);                     \
    fprintf(file, "%s", column->num_elems > 1 ? "[" : "");                                                             \
    for (size_t i = 0; i < column->num_elems; i++) {                                                                   \
        fprintf(file, format_string, *VEC_GET(column, i, type));                                             \
        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");                                                    \
    }                                                                                                                  \
    fprintf(file, "%s", column->num_elems > 1 ? "]" : "");                                                             \
}

static bool print_array_objects(FILE *file, const char *type_name,
                                const vec ofType(column_doc_group) *key_columns,
                                string_dict *dic)
{
        fprintf(file, "\"%s\": {", type_name);
        fprintf(file, "\"Keys\": [");
        for (size_t array_key_idx = 0; array_key_idx < key_columns->num_elems; array_key_idx++) {
                const column_doc_group
                        *arrayKeyColumns = VEC_GET(key_columns, array_key_idx, column_doc_group);
                fprintf(file,
                        "%"PRIu64"%s",
                        arrayKeyColumns->key,
                        array_key_idx + 1 < key_columns->num_elems ? ", " : "");
        }
        fprintf(file, "], \"Keys Decoded\": [");
        for (size_t array_key_idx = 0; array_key_idx < key_columns->num_elems; array_key_idx++) {
                const column_doc_group
                        *arrayKeyColumns = VEC_GET(key_columns, array_key_idx, column_doc_group);
                archive_field_sid_t encKeyName = arrayKeyColumns->key;
                char **decKeyName = string_dict_extract(dic, &encKeyName, 1);
                fprintf(file, "\"%s\"%s", *decKeyName, array_key_idx + 1 < key_columns->num_elems ? ", " : "");
                string_dict_free(dic, decKeyName);
        }
        fprintf(file, "], ");
        fprintf(file, "\"Tables\": [");
        for (size_t array_key_idx = 0; array_key_idx < key_columns->num_elems; array_key_idx++) {
                fprintf(file, "[");
                const column_doc_group
                        *arrayKeyColumns = VEC_GET(key_columns, array_key_idx, column_doc_group);
                for (size_t columnIdx = 0; columnIdx < arrayKeyColumns->columns.num_elems; columnIdx++) {
                        fprintf(file, "{");
                        const column_doc_column
                                *columnTable = VEC_GET(&arrayKeyColumns->columns, columnIdx,
                                                       column_doc_column);
                        char **decColumnKeyName = string_dict_extract(dic, &columnTable->key_name, 1);

                        const char *column_type_name = get_type_name(columnTable->type);
                        if (!column_type_name) {
                                return false;
                        }

                        fprintf(file,
                                "\"Column Name\": %"PRIu64", "
                                "\"Column Name Decoded\": \"%s\", "
                                "\"Unique Column Name Decoded\": \"{'%s'}$%s\", "
                                "\"Type\": \"%s\",",
                                columnTable->key_name,
                                *decColumnKeyName,
                                *decColumnKeyName,
                                column_type_name,
                                column_type_name);

                        fprintf(file, "\"Values\": [");
                        for (size_t array_idx = 0; array_idx < columnTable->values.num_elems; array_idx++) {
                                switch (columnTable->type) {
                                        case ARCHIVE_FIELD_NULL: {
                                                const vec
                                                        *column = VEC_GET(&columnTable->values, array_idx,
                                                                          vec);
                                                fprintf(file, "%s", column->num_elems > 1 ? "[" : "");
                                                for (size_t i = 0; i < column->num_elems; i++) {
                                                        fprintf(file, "null");
                                                        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");
                                                }
                                                fprintf(file, "%s", column->num_elems > 1 ? "]" : "");
                                        }
                                                break;
                                        case ARCHIVE_FIELD_INT8: PRINT_COLUMN(file, columnTable, array_idx,
                                                                          archive_field_i8_t, "%d")
                                                break;
                                        case ARCHIVE_FIELD_INT16: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           archive_field_i16_t, "%d")
                                                break;
                                        case ARCHIVE_FIELD_INT32: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           archive_field_i32_t, "%d")
                                                break;
                                        case ARCHIVE_FIELD_INT64: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           archive_field_i64_t, "%"
                                                                                   PRIi64)
                                                break;
                                        case ARCHIVE_FIELD_UINT8: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           archive_field_u8_t, "%d")
                                                break;
                                        case ARCHIVE_FIELD_UINT16: PRINT_COLUMN(file, columnTable, array_idx,
                                                                            archive_field_u16_t, "%d")
                                                break;
                                        case ARCHIVE_FIELD_UINT32: PRINT_COLUMN(file, columnTable, array_idx,
                                                                            archive_field_u32_t, "%d")
                                                break;
                                        case ARCHIVE_FIELD_UINT64: PRINT_COLUMN(file, columnTable, array_idx,
                                                                            archive_field_u64_t, "%"
                                                                                    PRIu64)
                                                break;
                                        case ARCHIVE_FIELD_FLOAT: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           archive_field_number_t,
                                                                           "%f")
                                                break;
                                        case ARCHIVE_FIELD_STRING: {
                                                const vec
                                                        *column = VEC_GET(&columnTable->values, array_idx,
                                                                          vec);
                                                fprintf(file, "%s", column->num_elems > 1 ? "[" : "");
                                                for (size_t i = 0; i < column->num_elems; i++) {
                                                        archive_field_sid_t encodedString = *VEC_GET(column, i,
                                                                                                         archive_field_sid_t);
                                                        char **decodedString = string_dict_extract(dic, &encodedString, 1);
                                                        fprintf(file,
                                                                "{\"Encoded\": %"PRIu64", \"Decoded\": \"%s\"}",
                                                                encodedString,
                                                                *decodedString);
                                                        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");
                                                        string_dict_free(dic, decodedString);
                                                }
                                                fprintf(file, "%s", column->num_elems > 1 ? "]" : "");
                                        }
                                                break;
                                        case ARCHIVE_FIELD_OBJECT: {
                                                // column_doc_obj *doc = VEC_GET(&column->values, valueIdx, column_doc_obj);
                                                //  _column_doc_print_object(file, doc, encode);
                                                const vec
                                                        *column = VEC_GET(&columnTable->values, array_idx,
                                                                          vec);
                                                fprintf(file, "%s", column->num_elems > 1 ? "[" : "");
                                                for (size_t i = 0; i < column->num_elems; i++) {
                                                        const column_doc_obj
                                                                *object = VEC_GET(column, i, column_doc_obj);
                                                        if (!_column_doc_print_object(file, object, dic)) {
                                                                return false;
                                                        }
                                                        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");
                                                }
                                                fprintf(file, "%s", column->num_elems > 1 ? "]" : "");
                                        }
                                                break;
                                        default: return ERROR(ERR_NOTYPE, NULL);
                                }
                                fprintf(file, array_idx + 1 < columnTable->values.num_elems ? ", " : "");
                        }
                        fprintf(file, "],");
                        fprintf(file, "\"Positions\": [");
                        for (size_t positionIdx = 0; positionIdx < columnTable->array_positions.num_elems;
                             positionIdx++) {
                                fprintf(file,
                                        "%d%s",
                                        *VEC_GET(&columnTable->array_positions, positionIdx, i16),
                                        (positionIdx + 1 < columnTable->array_positions.num_elems ? ", " : ""));
                        }
                        fprintf(file, "]");
                        string_dict_free(dic, decColumnKeyName);
                        fprintf(file, "}%s", columnIdx + 1 < arrayKeyColumns->columns.num_elems ? ", " : "");
                }
                fprintf(file, "]%s", array_key_idx + 1 < key_columns->num_elems ? ", " : "");
        }
        fprintf(file, "]");

        fprintf(file, "}");
        return true;
}

static bool
_column_doc_print_object(FILE *file, const column_doc_obj *object, string_dict *dic)
{
        char **parentKey = string_dict_extract(dic, &object->parent_key, 1);
        fprintf(file, "{ ");
        fprintf(file,
                "\"Parent\": { \"Key\": %"PRIu64", \"Key Decoded\": \"%s\", \"Index\": %zu }, ",
                object->parent_key,
                parentKey[0],
                object->index);
        fprintf(file, "\"Pairs\": { ");
        fprintf(file, "\"Primitives\": { ");
        PRINT_PRIMITIVE_BOOLEAN_COLUMN(file, "Boolean", &object->bool_prop_keys, &object->bool_prop_vals, dic)
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt8",
                               &object->uint8_prop_keys,
                               &object->uint8_prop_vals,
                               &object->uint8_val_idxs,
                               dic,
                               archive_field_u8_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt16",
                               &object->uint16_prop_keys,
                               &object->uint16_prop_vals,
                               &object->uint16_val_idxs,
                               dic,
                               archive_field_u16_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt32",
                               &object->uin32_prop_keys,
                               &object->uint32_prop_vals,
                               &object->uint32_val_idxs,
                               dic,
                               archive_field_u32_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt64",
                               &object->uint64_prop_keys,
                               &object->uint64_prop_vals,
                               &object->uint64_val_idxs,
                               dic,
                               archive_field_u64_t,
                               "%"
                                       PRIu64)
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int8",
                               &object->int8_prop_keys,
                               &object->int8_prop_vals,
                               &object->int8_val_idxs,
                               dic,
                               archive_field_i8_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int16",
                               &object->int16_prop_keys,
                               &object->int16_prop_vals,
                               &object->int16_val_idxs,
                               dic,
                               archive_field_i16_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int32",
                               &object->int32_prop_keys,
                               &object->int32_prop_vals,
                               &object->int32_val_idxs,
                               dic,
                               archive_field_i32_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int64",
                               &object->int64_prop_keys,
                               &object->int64_prop_vals,
                               &object->int64_val_idxs,
                               dic,
                               archive_field_i64_t,
                               "%"
                                       PRIi64)
        PRINT_PRIMITIVE_COLUMN(file,
                               "Real",
                               &object->float_prop_keys,
                               &object->float_prop_vals,
                               &object->float_val_idxs,
                               dic,
                               archive_field_number_t,
                               "%f")
        print_primitive_strings(file, "Strings", &object->string_prop_keys, &object->string_prop_vals, dic);
        print_primitive_null(file, "Null", &object->null_prop_keys, dic);
        if (print_primitive_objects(file, "Objects", &object->obj_prop_keys, &object->obj_prop_vals, dic)) {
                return false;
        }
        fprintf(file, "}, ");
        fprintf(file, "\"Arrays\": { ");
        PRINT_BOOLEAN_ARRAY(file, "Boolean", object->bool_array_prop_keys, object->bool_array_prop_vals);
        PRINT_ARRAY(file,
                    "UInt8",
                    object->uint8_array_prop_keys,
                    object->uint8_array_prop_vals,
                    archive_field_u8_t,
                    "%d",
                    (value != NULL_UINT8));
        PRINT_ARRAY(file,
                    "UInt16",
                    object->uint16_array_prop_keys,
                    object->uint16_array_prop_vals,
                    archive_field_u16_t,
                    "%d",
                    (value != NULL_UINT16));
        PRINT_ARRAY(file,
                    "UInt32",
                    object->uint32_array_prop_keys,
                    object->uint32_array_prop_vals,
                    archive_field_u32_t,
                    "%d",
                    (value != NULL_UINT32));
        PRINT_ARRAY(file, "UInt64", object->uint64_array_prop_keys, object->ui64_array_prop_vals,
                    archive_field_u64_t, "%"
                            PRIu64, (value != NULL_UINT64));
        PRINT_ARRAY(file,
                    "Int8",
                    object->int8_array_prop_keys,
                    object->int8_array_prop_vals,
                    archive_field_i8_t,
                    "%d",
                    (value != NULL_INT8));
        PRINT_ARRAY(file,
                    "Int16",
                    object->int16_array_prop_keys,
                    object->int16_array_prop_vals,
                    archive_field_i16_t,
                    "%d",
                    (value != NULL_INT16));
        PRINT_ARRAY(file,
                    "Int32",
                    object->int32_array_prop_keys,
                    object->int32_array_prop_vals,
                    archive_field_i32_t,
                    "%d",
                    (value != NULL_INT32));
        PRINT_ARRAY(file, "Int64", object->int64_array_prop_keys, object->int64_array_prop_vals,
                    archive_field_i64_t, "%"
                            PRIi64, (value != NULL_INT64));
        PRINT_ARRAY(file,
                    "Real",
                    object->float_array_prop_keys,
                    object->float_array_prop_vals,
                    archive_field_number_t,
                    "%f",
                    (!isnan(value)));
        print_array_strings(file, "Strings", &object->string_array_prop_keys, &object->string_array_prop_vals, dic);
        print_array_null(file, "Null", &object->null_array_prop_keys, &object->null_array_prop_vals, dic);
        if (!print_array_objects(file, "Objects", &object->obj_array_props, dic)) {
                return false;
        }
        fprintf(file, "} ");
        fprintf(file, " }");
        fprintf(file, " }");
        string_dict_free(dic, parentKey);
        return true;
}

bool columndoc_print(FILE *file, column_doc *doc)
{
        return _column_doc_print_object(file, &doc->columndoc, doc->dic);
}

bool columndoc_drop(column_doc *doc)
{
        UNUSED(doc);
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return false;
}

static void object_array_key_columns_create(vec ofType(column_doc_group) *columns)
{
        vec_create(columns, sizeof(column_doc_group), 20000);
}

static void object_array_key_columns_drop(vec ofType(column_doc_group) *columns)
{
        for (size_t i = 0; i < columns->num_elems; i++) {
                column_doc_group *array_columns = VEC_GET(columns, i, column_doc_group);
                for (size_t j = 0; j < array_columns->columns.num_elems; j++) {

                        column_doc_column *column = VEC_GET(&array_columns->columns, j,
                                                                       column_doc_column);

                        vec ofType(u32) *array_indices = &column->array_positions;
                        vec ofType(vec ofType(<T>)) *values_for_indicies = &column->values;

                        assert (array_indices->num_elems == values_for_indicies->num_elems);

                        for (size_t k = 0; k < array_indices->num_elems; k++) {

                                vec ofType(<T>)
                                        *values_for_index = VEC_GET(values_for_indicies, k, vec);
                                if (column->type == ARCHIVE_FIELD_OBJECT) {
                                        for (size_t l = 0; l < values_for_index->num_elems; l++) {
                                                column_doc_obj *nested_object =
                                                        VEC_GET(values_for_index, l, column_doc_obj);
                                                object_meta_model_free(nested_object);
                                        }
                                }
                                vec_drop(values_for_index);
                        }

                        vec_drop(array_indices);
                        vec_drop(values_for_indicies);
                }
                vec_drop(&array_columns->columns);
        }
        vec_drop(columns);
}

static const char *get_type_name(archive_field_e type)
{
        switch (type) {
                case ARCHIVE_FIELD_NULL:
                        return "Null";
                case ARCHIVE_FIELD_INT8:
                        return "Int8";
                case ARCHIVE_FIELD_INT16:
                        return "Int16";
                case ARCHIVE_FIELD_INT32:
                        return "Int32";
                case ARCHIVE_FIELD_INT64:
                        return "Int64";
                case ARCHIVE_FIELD_UINT8:
                        return "UInt8";
                case ARCHIVE_FIELD_UINT16:
                        return "UInt16";
                case ARCHIVE_FIELD_UINT32:
                        return "UInt32";
                case ARCHIVE_FIELD_UINT64:
                        return "UInt64";
                case ARCHIVE_FIELD_FLOAT:
                        return "Real";
                case ARCHIVE_FIELD_STRING:
                        return "String";
                case ARCHIVE_FIELD_OBJECT:
                        return "Object";
                default: {
                        ERROR(ERR_NOTYPE, NULL);
                        return NULL;
                }
        }
}

static column_doc_column *object_array_key_columns_find_or_new(
        vec ofType(column_doc_group) *columns, archive_field_sid_t array_key,
        archive_field_sid_t nested_object_entry_key, archive_field_e nested_object_entry_type)
{
        column_doc_group *key_columns;
        column_doc_column *key_column, *new_column;

        for (size_t i = 0; i < columns->num_elems; i++) {
                /** Find object array pair having the key `key` */
                key_columns = VEC_GET(columns, i, column_doc_group);
                if (key_columns->key == array_key) {
                        /** In case such a pair is found, find column that matches the desired type */
                        for (size_t j = 0; j < key_columns->columns.num_elems; j++) {
                                key_column = VEC_GET(&key_columns->columns, j, column_doc_column);
                                if (key_column->key_name == nested_object_entry_key
                                    && key_column->type == nested_object_entry_type) {
                                        /** Column for the object array with the desired key, the nested object entry with the desired key
                                         * and a matching type is found */
                                        return key_column;
                                }
                        }
                        /** In this case, the requested array_key is found, but the nested object entry does not match, hence
                         * create a new one */
                        goto objectArrayKeyColumnsNewColumn;
                }
        }
        /** In this case, the array key is also not known. Create a new one array entry with the fitting key column and
         * return that newly created column */
        key_columns = VEC_NEW_AND_GET(columns, column_doc_group);
        key_columns->key = array_key;
        vec_create(&key_columns->columns, sizeof(column_doc_column), 10);

        objectArrayKeyColumnsNewColumn:
        new_column = VEC_NEW_AND_GET(&key_columns->columns, column_doc_column);
        new_column->key_name = nested_object_entry_key;
        new_column->type = nested_object_entry_type;
        vec_create(&new_column->values, sizeof(vec), 10);
        vec_create(&new_column->array_positions, sizeof(u32), 10);

        return new_column;
}

static bool object_array_key_column_push(column_doc_column *col, const doc_entries *entry,
                                         u32 array_idx, string_dict *dic,
                                         column_doc_obj *model)
{
        assert(col->type == entry->type);

        u32 *entry_array_idx = VEC_NEW_AND_GET(&col->array_positions, u32);
        *entry_array_idx = array_idx;

        vec ofType(<T>) *values_for_entry = VEC_NEW_AND_GET(&col->values, vec);
        vec_create(values_for_entry, GET_TYPE_SIZE(entry->type), entry->values.num_elems);

        bool is_null_by_def = entry->values.num_elems == 0;
        u32 num_elements = (u32) entry->values.num_elems;

        archive_field_e entryType = is_null_by_def ? ARCHIVE_FIELD_NULL : entry->type;
        num_elements = is_null_by_def ? 1 : num_elements;

        switch (entryType) {
                case ARCHIVE_FIELD_NULL: {
                        vec_push(values_for_entry, &num_elements, 1);
                }
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                case ARCHIVE_FIELD_INT8:
                case ARCHIVE_FIELD_INT16:
                case ARCHIVE_FIELD_INT32:
                case ARCHIVE_FIELD_INT64:
                case ARCHIVE_FIELD_UINT8:
                case ARCHIVE_FIELD_UINT16:
                case ARCHIVE_FIELD_UINT32:
                case ARCHIVE_FIELD_UINT64:
                case ARCHIVE_FIELD_FLOAT:
                        assert(!is_null_by_def);
                        vec_push(values_for_entry, entry->values.base, num_elements);
                        break;
                case ARCHIVE_FIELD_STRING: {
                        assert(!is_null_by_def);
                        char **strings = VEC_ALL(&entry->values, char *);
                        archive_field_sid_t *string_ids;
                        string_dict_locate_fast(&string_ids, dic, (char *const *) strings, num_elements);
                        vec_push(values_for_entry, string_ids, num_elements);
                        string_dict_free(dic, string_ids);
                        //string_dict_free(encode, strings);
                }
                        break;
                case ARCHIVE_FIELD_OBJECT:
                        assert(!is_null_by_def);

                        archive_field_sid_t *array_key;
                        string_dict_locate_fast(&array_key, dic, (char *const *) &entry->key, 1);

                        for (size_t array_idx = 0; array_idx < num_elements; array_idx++) {
                                column_doc_obj
                                        *nested_object = VEC_NEW_AND_GET(values_for_entry, column_doc_obj);
                                setup_object(nested_object, model->parent, *array_key, array_idx);
                                if (!import_object(nested_object,
                                                   VEC_GET(&entry->values, array_idx, doc_obj),
                                                   dic)) {
                                        return false;
                                }
                        }
                        string_dict_free(dic, array_key);
                        break;
                default: ERROR(ERR_NOTYPE, NULL);
                        return false;
        }
        return true;
}

static void
setup_object(column_doc_obj *model, column_doc *parent, archive_field_sid_t key, size_t idx)
{
        model->parent = parent;
        model->parent_key = key;
        model->index = idx;

        vec_create(&model->bool_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int8_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int16_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int32_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int64_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint8_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint16_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uin32_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint64_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->string_prop_keys, sizeof(archive_field_sid_t), 50);
        vec_create(&model->float_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->null_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->obj_prop_keys, sizeof(archive_field_sid_t), 10);

        vec_create(&model->bool_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int8_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int16_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int32_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->int64_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint8_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint16_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint32_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->uint64_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->string_array_prop_keys, sizeof(archive_field_sid_t), 50);
        vec_create(&model->float_array_prop_keys, sizeof(archive_field_sid_t), 10);
        vec_create(&model->null_array_prop_keys, sizeof(archive_field_sid_t), 10);

        vec_create(&model->bool_prop_vals, sizeof(archive_field_boolean_t), 10);
        vec_create(&model->int8_prop_vals, sizeof(archive_field_i8_t), 10);
        vec_create(&model->int16_prop_vals, sizeof(archive_field_i16_t), 10);
        vec_create(&model->int32_prop_vals, sizeof(archive_field_i32_t), 10);
        vec_create(&model->int64_prop_vals, sizeof(archive_field_i64_t), 10);
        vec_create(&model->uint8_prop_vals, sizeof(archive_field_u8_t), 10);
        vec_create(&model->uint16_prop_vals, sizeof(archive_field_u16_t), 10);
        vec_create(&model->uint32_prop_vals, sizeof(archive_field_u32_t), 10);
        vec_create(&model->uint64_prop_vals, sizeof(archive_field_u64_t), 10);
        vec_create(&model->float_prop_vals, sizeof(archive_field_number_t), 10);
        vec_create(&model->string_prop_vals, sizeof(archive_field_sid_t), 50);

        vec_create(&model->bool_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->int8_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->int16_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->int32_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->int64_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->uint8_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->uint16_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->uint32_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->ui64_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->float_array_prop_vals, sizeof(vec), 10);
        vec_create(&model->string_array_prop_vals, sizeof(vec), 50);
        vec_create(&model->null_array_prop_vals, sizeof(u16), 10);

        vec_create(&model->bool_val_idxs, sizeof(u32), 10);
        vec_create(&model->int8_val_idxs, sizeof(u32), 10);
        vec_create(&model->int16_val_idxs, sizeof(u32), 10);
        vec_create(&model->int32_val_idxs, sizeof(u32), 10);
        vec_create(&model->int64_val_idxs, sizeof(u32), 10);
        vec_create(&model->uint8_val_idxs, sizeof(u32), 10);
        vec_create(&model->uint16_val_idxs, sizeof(u32), 10);
        vec_create(&model->uint32_val_idxs, sizeof(u32), 10);
        vec_create(&model->uint64_val_idxs, sizeof(u32), 10);
        vec_create(&model->float_val_idxs, sizeof(u32), 10);
        vec_create(&model->string_val_idxs, sizeof(u32), 50);

        vec_create(&model->bool_array_idxs, sizeof(vec), 10);
        vec_create(&model->int8_array_idxs, sizeof(vec), 10);
        vec_create(&model->int16_array_idxs, sizeof(vec), 10);
        vec_create(&model->int32_array_idxs, sizeof(vec), 10);
        vec_create(&model->int64_array_idxs, sizeof(vec), 10);
        vec_create(&model->uint8_array_idxs, sizeof(vec), 10);
        vec_create(&model->uint16_array_idxs, sizeof(vec), 10);
        vec_create(&model->uint32_array_idxs, sizeof(vec), 10);
        vec_create(&model->uint64_array_idxs, sizeof(vec), 10);
        vec_create(&model->float_array_idxs, sizeof(vec), 10);
        vec_create(&model->string_array_idxs, sizeof(vec), 50);

        vec_create(&model->obj_prop_vals, sizeof(column_doc_obj), 10);

        object_array_key_columns_create(&model->obj_array_props);
}

static bool
object_put_primitive(column_doc_obj *columndoc, const doc_entries *entry,
                     string_dict *dic, const archive_field_sid_t *key_id)
{
        switch (entry->type) {
                case ARCHIVE_FIELD_NULL:
                        vec_push(&columndoc->null_prop_keys, key_id, 1);
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                        vec_push(&columndoc->bool_prop_keys, key_id, 1);
                        vec_push(&columndoc->bool_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_INT8:
                        vec_push(&columndoc->int8_prop_keys, key_id, 1);
                        vec_push(&columndoc->int8_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_INT16:
                        vec_push(&columndoc->int16_prop_keys, key_id, 1);
                        vec_push(&columndoc->int16_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_INT32:
                        vec_push(&columndoc->int32_prop_keys, key_id, 1);
                        vec_push(&columndoc->int32_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_INT64:
                        vec_push(&columndoc->int64_prop_keys, key_id, 1);
                        vec_push(&columndoc->int64_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_UINT8:
                        vec_push(&columndoc->uint8_prop_keys, key_id, 1);
                        vec_push(&columndoc->uint8_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_UINT16:
                        vec_push(&columndoc->uint16_prop_keys, key_id, 1);
                        vec_push(&columndoc->uint16_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_UINT32:
                        vec_push(&columndoc->uin32_prop_keys, key_id, 1);
                        vec_push(&columndoc->uint32_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_UINT64:
                        vec_push(&columndoc->uint64_prop_keys, key_id, 1);
                        vec_push(&columndoc->uint64_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_FLOAT:
                        vec_push(&columndoc->float_prop_keys, key_id, 1);
                        vec_push(&columndoc->float_prop_vals, entry->values.base, 1);
                        break;
                case ARCHIVE_FIELD_STRING: {
                        archive_field_sid_t *value;
                        string_dict_locate_fast(&value, dic, (char *const *) entry->values.base, 1);
                        vec_push(&columndoc->string_prop_keys, key_id, 1);
                        vec_push(&columndoc->string_prop_vals, value, 1);
                        string_dict_free(dic, value);
                }
                        break;
                case ARCHIVE_FIELD_OBJECT: {
                        column_doc_obj template, *nested_object;
                        size_t position = VEC_LENGTH(&columndoc->obj_prop_keys);
                        vec_push(&columndoc->obj_prop_keys, key_id, 1);
                        vec_push(&columndoc->obj_prop_vals, &template, 1);
                        nested_object = VEC_GET(&columndoc->obj_prop_vals, position, column_doc_obj);
                        setup_object(nested_object, columndoc->parent, *key_id, 0);
                        if (!import_object(nested_object, VEC_GET(&entry->values, 0, doc_obj), dic)) {
                                return false;
                        }
                } break;
                default:
                        return ERROR(ERR_NOTYPE, NULL);
        }
        return true;
}

static void object_push_array(vec ofType(Vector
                                                               ofType( < T >)) *values, size_t TSize,
                              u32 num_elements,
                              const void *data, archive_field_sid_t key_id,
                              vec ofType(archive_field_sid_t) *key_vector)
{
        vec ofType(<T>) template, *vec;
        size_t idx = VEC_LENGTH(values);
        vec_push(values, &template, 1);
        vec = VEC_GET(values, idx, struct vec);
        vec_create(vec, TSize, num_elements);
        vec_push(vec, data, num_elements);
        vec_push(key_vector, &key_id, 1);
}

static bool
object_put_array(column_doc_obj *model, const doc_entries *entry,
                 string_dict *dic, const archive_field_sid_t *key_id)
{
        UNUSED(dic);
        u32 num_elements = (u32) VEC_LENGTH(&entry->values);

        switch (entry->type) {
                case ARCHIVE_FIELD_NULL: {
                        vec_push(&model->null_array_prop_vals, &num_elements, 1);
                        vec_push(&model->null_array_prop_keys, key_id, 1);
                }
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                        object_push_array(&model->bool_array_prop_vals,
                                          sizeof(archive_field_boolean_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->bool_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_INT8:
                        object_push_array(&model->int8_array_prop_vals,
                                          sizeof(archive_field_i8_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int8_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_INT16:
                        object_push_array(&model->int16_array_prop_vals,
                                          sizeof(archive_field_i16_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int16_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_INT32:
                        object_push_array(&model->int32_array_prop_vals,
                                          sizeof(archive_field_i32_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int32_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_INT64:
                        object_push_array(&model->int64_array_prop_vals,
                                          sizeof(archive_field_i64_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int64_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_UINT8:
                        object_push_array(&model->uint8_array_prop_vals,
                                          sizeof(archive_field_u8_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint8_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_UINT16:
                        object_push_array(&model->uint16_array_prop_vals,
                                          sizeof(archive_field_u16_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint16_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_UINT32:
                        object_push_array(&model->uint32_array_prop_vals,
                                          sizeof(archive_field_u32_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint32_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_UINT64:
                        object_push_array(&model->ui64_array_prop_vals,
                                          sizeof(archive_field_u64_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint64_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_FLOAT:
                        object_push_array(&model->float_array_prop_vals,
                                          sizeof(archive_field_number_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->float_array_prop_keys);
                        break;
                case ARCHIVE_FIELD_STRING: {
                        const char **strings = VEC_ALL(&entry->values, const char *);
                        archive_field_sid_t *string_ids;
                        string_dict_locate_fast(&string_ids, dic, (char *const *) strings, num_elements);
                        object_push_array(&model->string_array_prop_vals,
                                          sizeof(archive_field_sid_t),
                                          num_elements,
                                          string_ids,
                                          *key_id,
                                          &model->string_array_prop_keys);
                        string_dict_free(dic, string_ids);
                }
                        break;
                case ARCHIVE_FIELD_OBJECT: {
                        archive_field_sid_t *nested_object_key_name;
                        for (u32 array_idx = 0; array_idx < num_elements; array_idx++) {
                                const doc_obj *object = VEC_GET(&entry->values, array_idx,
                                                                           doc_obj);
                                for (size_t pair_idx = 0; pair_idx < object->entries.num_elems; pair_idx++) {
                                        const doc_entries
                                                *pair = VEC_GET(&object->entries, pair_idx, doc_entries);
                                        string_dict_locate_fast(&nested_object_key_name, dic, (char *const *) &pair->key, 1);
                                        column_doc_column *key_column =
                                                object_array_key_columns_find_or_new(&model->obj_array_props,
                                                                                     *key_id,
                                                                                     *nested_object_key_name,
                                                                                     pair->type);
                                        if (!object_array_key_column_push(key_column, pair, array_idx, dic,
                                                                          model)) {
                                                return false;
                                        }
                                        string_dict_free(dic, nested_object_key_name);
                                }
                        }
                }
                        break;
                default: {
                        return ERROR(ERR_NOTYPE, NULL);
                }
                        break;
        }
        return true;
}

static bool object_put(column_doc_obj *model, const doc_entries *entry,
                       string_dict *dic)
{
        archive_field_sid_t *key_id;
        enum EntryType {
                ENTRY_TYPE_NULL, ENTRY_TYPE_PRIMITIVE, ENTRY_TYPE_ARRAY
        } entryType;

        string_dict_locate_fast(&key_id, dic, (char *const *) &entry->key, 1);
        entryType =
                entry->values.num_elems == 0 ? ENTRY_TYPE_NULL : (entry->values.num_elems == 1 ? ENTRY_TYPE_PRIMITIVE
                                                                                               : ENTRY_TYPE_ARRAY);

        switch (entryType) {
                case ENTRY_TYPE_NULL:
                        /** For a key which does not async_map_exec to any value, the value is defined as 'null'  */
                        vec_push(&model->null_prop_keys, key_id, 1);
                        break;
                case ENTRY_TYPE_PRIMITIVE:
                        if (!object_put_primitive(model, entry, dic, key_id)) {
                                return false;
                        }
                        break;
                case ENTRY_TYPE_ARRAY:
                        if (!object_put_array(model, entry, dic, key_id)) {
                                return false;
                        }
                        break;
                default:
                        return ERROR(ERR_NOTYPE, NULL);
        }

        string_dict_free(dic, key_id);
        return true;
}

static bool import_object(column_doc_obj *dst, const doc_obj *doc,
                          string_dict *dic)
{
        const vec ofType(doc_entries) *objectEntries = doc_get_entries(doc);
        const doc_entries *entries = VEC_ALL(objectEntries, doc_entries);
        for (size_t i = 0; i < objectEntries->num_elems; i++) {
                const doc_entries *entry = entries + i;
                if (!object_put(dst, entry, dic)) {
                        return false;
                }
        }
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/stdinc.h>
#include <karbonit/archive/visitor.h>
#include <karbonit/archive/converter.h>

struct converter_capture {
        encoded_doc_list *collection;
};

#define IMPORT_BASIC_PAIR(name)                                                                                        \
{                                                                                                                      \
    UNUSED(archive);                                                                                            \
    UNUSED(path_stack);                                                                                         \
    assert(capture);                                                                                                   \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
    encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, oid);                          \
    for (u32 i = 0; i < num_pairs; i++) {                                                                         \
        encoded_doc_add_prop_##name(doc, keys[i], values[i]);                                                   \
    }                                                                                                                  \
}

#define DECLARE_VISIT_BASIC_TYPE_PAIR(name, built_in_type)                                                             \
static void                                                                                                            \
visit_##name##_pairs (archive *archive, path_stack_t path_stack, unique_id_t oid,                      \
                  const archive_field_sid_t *keys, const built_in_type *values, u32 num_pairs, void *capture)      \
{                                                                                                                      \
    IMPORT_BASIC_PAIR(name)                                                                                            \
}

#define DECLARE_VISIT_ARRAY_TYPE(name, built_in_type)                                                                  \
static visit_policy_e                                                                                         \
visit_enter_##name##_array_pairs(archive *archive, path_stack_t path, unique_id_t id,                  \
                                 const archive_field_sid_t *keys, u32 num_pairs, void *capture)                    \
{                                                                                                                      \
    UNUSED(archive);                                                                                            \
    UNUSED(path);                                                                                               \
    UNUSED(id);                                                                                                 \
    UNUSED(keys);                                                                                               \
    UNUSED(num_pairs);                                                                                          \
    UNUSED(capture);                                                                                            \
                                                                                                                       \
    assert(capture);                                                                                                   \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
    encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, id);                           \
    for (u32 i = 0; i < num_pairs; i++)                                                                           \
    {                                                                                                                  \
        encoded_doc_add_prop_array_##name(doc, keys[i]);                                                        \
    }                                                                                                                  \
                                                                                                                       \
    return VISIT_INCLUDE;                                                                              \
}                                                                                                                      \
                                                                                                                       \
static void                                                                                                            \
visit_##name##_array_pair(archive *archive, path_stack_t path, unique_id_t id,                         \
                          const archive_field_sid_t key, u32 entry_idx, u32 max_entries,                      \
                          const built_in_type *array, u32 array_length, void *capture)                            \
{                                                                                                                      \
    UNUSED(archive);                                                                                            \
    UNUSED(path);                                                                                               \
    UNUSED(id);                                                                                                 \
    UNUSED(key);                                                                                                \
    UNUSED(entry_idx);                                                                                          \
    UNUSED(max_entries);                                                                                        \
    UNUSED(capture);                                                                                            \
                                                                                                                       \
    assert(capture);                                                                                                   \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
    encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, id);                           \
    encoded_doc_array_push_##name(doc, key, array, array_length);                                               \
}                                                                                                                      \


static void visit_root_object(archive *archive, unique_id_t id, void *capture)
{
        UNUSED(archive);
        assert(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        encoded_doc_collection_get_or_append(extra->collection, id);
}

DECLARE_VISIT_BASIC_TYPE_PAIR(int8, archive_field_i8_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(int16, archive_field_i16_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(int32, archive_field_i32_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(int64, archive_field_i64_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint8, archive_field_u8_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint16, archive_field_u16_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint32, archive_field_u32_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint64, archive_field_u64_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(number, archive_field_number_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(boolean, archive_field_boolean_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(string, archive_field_sid_t)

static void visit_null_pairs(archive *archive, path_stack_t path, unique_id_t oid,
                             const archive_field_sid_t *keys,
                             u32 num_pairs, void *capture)
{
        UNUSED(archive);
        UNUSED(path);
        assert(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, oid);
        for (u32 i = 0; i < num_pairs; i++) {
                encoded_doc_add_prop_null(doc, keys[i]);
        }
}

static visit_policy_e
before_object_visit(archive *archive, path_stack_t path_stack, unique_id_t parent_id,
                    unique_id_t value_id, u32 object_idx, u32 num_objects, archive_field_sid_t key,
                    void *capture)
{
        UNUSED(archive);
        UNUSED(path_stack);
        UNUSED(object_idx);
        UNUSED(num_objects);
        UNUSED(key);
        UNUSED(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        encoded_doc *parent_doc = encoded_doc_collection_get_or_append(extra->collection, parent_id);
        encoded_doc *child_doc = encoded_doc_collection_get_or_append(extra->collection, value_id);
        encoded_doc_add_prop_object(parent_doc, key, child_doc);

        return VISIT_INCLUDE;
}

DECLARE_VISIT_ARRAY_TYPE(int8, archive_field_i8_t)

DECLARE_VISIT_ARRAY_TYPE(int16, archive_field_i16_t)

DECLARE_VISIT_ARRAY_TYPE(int32, archive_field_i32_t)

DECLARE_VISIT_ARRAY_TYPE(int64, archive_field_i64_t)

DECLARE_VISIT_ARRAY_TYPE(uint8, archive_field_u8_t)

DECLARE_VISIT_ARRAY_TYPE(uint16, archive_field_u16_t)

DECLARE_VISIT_ARRAY_TYPE(uint32, archive_field_u32_t)

DECLARE_VISIT_ARRAY_TYPE(uint64, archive_field_u64_t)

DECLARE_VISIT_ARRAY_TYPE(number, archive_field_number_t)

DECLARE_VISIT_ARRAY_TYPE(boolean, archive_field_boolean_t)

DECLARE_VISIT_ARRAY_TYPE(string, archive_field_sid_t)

static visit_policy_e
visit_enter_null_array_pairs(archive *archive, path_stack_t path, unique_id_t id,
                             const archive_field_sid_t *keys, u32 num_pairs, void *capture)
{
        UNUSED(archive);
        UNUSED(path);
        UNUSED(id);
        UNUSED(keys);
        UNUSED(num_pairs);
        UNUSED(capture);

        assert(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, id);
        for (u32 i = 0; i < num_pairs; i++) {
                encoded_doc_add_prop_array_null(doc, keys[i]);
        }

        return VISIT_INCLUDE;
}

static void visit_null_array_pair(archive *archive, path_stack_t path, unique_id_t id,
                                  const archive_field_sid_t key,
                                  u32 entry_idx, u32 max_entries, u32 num_nulls, void *capture)
{
        UNUSED(archive);
        UNUSED(path);
        UNUSED(id);
        UNUSED(key);
        UNUSED(entry_idx);
        UNUSED(max_entries);
        UNUSED(num_nulls);
        UNUSED(capture);

        assert(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, id);
        encoded_doc_array_push_null(doc, key, &num_nulls, 1);
}

static void
before_visit_object_array_objects(bool *skip_group_object_ids, archive *archive, path_stack_t path,
                                  unique_id_t parent_id, archive_field_sid_t key,
                                  const unique_id_t *group_object_ids, u32 num_group_object_ids,
                                  void *capture)
{
        UNUSED(archive);
        UNUSED(path);
        UNUSED(parent_id);
        UNUSED(capture);
        UNUSED(group_object_ids);
        UNUSED(skip_group_object_ids);
        UNUSED(num_group_object_ids);

        struct converter_capture *extra = (struct converter_capture *) capture;
        encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, parent_id);
        encoded_doc_add_prop_array_object(doc, key);
        for (u32 i = 0; i < num_group_object_ids; i++) {
                encoded_doc_array_push_object(doc, key, group_object_ids[i]);
        }
}

#define DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(name, built_in_type)                                             \
static void                                                                                                            \
visit_object_array_object_property_##name(archive *archive, path_stack_t path,                                \
                                           unique_id_t parent_id,                                               \
                                           archive_field_sid_t key,                                                     \
                                           unique_id_t nested_object_id,                                        \
                                           archive_field_sid_t nested_key,                                              \
                                           const built_in_type *nested_values,                                         \
                                           u32 num_nested_values, void *capture)                                  \
{                                                                                                                      \
    UNUSED(archive);                                                                                            \
    UNUSED(path);                                                                                               \
    UNUSED(parent_id);                                                                                          \
    UNUSED(key);                                                                                                \
    UNUSED(nested_key);                                                                                         \
    UNUSED(nested_values);                                                                                      \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
        encoded_doc *doc = encoded_doc_collection_get_or_append(extra->collection, nested_object_id);             \
        encoded_doc_add_prop_array_##name(doc, nested_key);                                                                                                   \
        encoded_doc_array_push_##name(doc, nested_key, nested_values, num_nested_values);                           \
}

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int8, archive_field_i8_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int16, archive_field_i16_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int32, archive_field_i32_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int64, archive_field_i64_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint8, archive_field_u8_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint16, archive_field_u16_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint32, archive_field_u32_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint64, archive_field_u64_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(number, archive_field_number_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(string, archive_field_sid_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(boolean, archive_field_boolean_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(null, archive_field_u32_t);

bool archive_converter(encoded_doc_list *collection, archive *archive)
{

        encoded_doc_collection_create(collection, archive);

        visitor visitor = {0};
        archive_visitor_desc desc = {.visit_mask = ARCHIVE_ITER_MASK_ANY};
        struct converter_capture capture = {.collection = collection};

        visitor.visit_root_object = visit_root_object;
        visitor.before_object_visit = before_object_visit;
        visitor.visit_int8_pairs = visit_int8_pairs;
        visitor.visit_int16_pairs = visit_int16_pairs;
        visitor.visit_int32_pairs = visit_int32_pairs;
        visitor.visit_int64_pairs = visit_int64_pairs;
        visitor.visit_uint8_pairs = visit_uint8_pairs;
        visitor.visit_uint16_pairs = visit_uint16_pairs;
        visitor.visit_uint32_pairs = visit_uint32_pairs;
        visitor.visit_uint64_pairs = visit_uint64_pairs;
        visitor.visit_number_pairs = visit_number_pairs;
        visitor.visit_string_pairs = visit_string_pairs;
        visitor.visit_boolean_pairs = visit_boolean_pairs;
        visitor.visit_null_pairs = visit_null_pairs;

        visitor.visit_enter_int8_array_pairs = visit_enter_int8_array_pairs;
        visitor.visit_int8_array_pair = visit_int8_array_pair;
        visitor.visit_enter_int16_array_pairs = visit_enter_int16_array_pairs;
        visitor.visit_int16_array_pair = visit_int16_array_pair;
        visitor.visit_enter_int32_array_pairs = visit_enter_int32_array_pairs;
        visitor.visit_int32_array_pair = visit_int32_array_pair;
        visitor.visit_enter_int64_array_pairs = visit_enter_int64_array_pairs;
        visitor.visit_int64_array_pair = visit_int64_array_pair;
        visitor.visit_enter_uint8_array_pairs = visit_enter_uint8_array_pairs;
        visitor.visit_uint8_array_pair = visit_uint8_array_pair;
        visitor.visit_enter_uint16_array_pairs = visit_enter_uint16_array_pairs;
        visitor.visit_uint16_array_pair = visit_uint16_array_pair;
        visitor.visit_enter_uint32_array_pairs = visit_enter_uint32_array_pairs;
        visitor.visit_uint32_array_pair = visit_uint32_array_pair;
        visitor.visit_enter_uint64_array_pairs = visit_enter_uint64_array_pairs;
        visitor.visit_uint64_array_pair = visit_uint64_array_pair;
        visitor.visit_enter_boolean_array_pairs = visit_enter_boolean_array_pairs;
        visitor.visit_boolean_array_pair = visit_boolean_array_pair;
        visitor.visit_enter_number_array_pairs = visit_enter_number_array_pairs;
        visitor.visit_number_array_pair = visit_number_array_pair;
        visitor.visit_enter_null_array_pairs = visit_enter_null_array_pairs;
        visitor.visit_null_array_pair = visit_null_array_pair;
        visitor.visit_enter_string_array_pairs = visit_enter_string_array_pairs;
        visitor.visit_string_array_pair = visit_string_array_pair;

        visitor.before_visit_object_array_objects = before_visit_object_array_objects;

        visitor.visit_object_array_object_property_int8s = visit_object_array_object_property_int8;
        visitor.visit_object_array_object_property_int16s = visit_object_array_object_property_int16;
        visitor.visit_object_array_object_property_int32s = visit_object_array_object_property_int32;
        visitor.visit_object_array_object_property_int64s = visit_object_array_object_property_int64;
        visitor.visit_object_array_object_property_uint8s = visit_object_array_object_property_uint8;
        visitor.visit_object_array_object_property_uint16s = visit_object_array_object_property_uint16;
        visitor.visit_object_array_object_property_uint32s = visit_object_array_object_property_uint32;
        visitor.visit_object_array_object_property_uint64s = visit_object_array_object_property_uint64;
        visitor.visit_object_array_object_property_numbers = visit_object_array_object_property_number;
        visitor.visit_object_array_object_property_strings = visit_object_array_object_property_string;
        visitor.visit_object_array_object_property_booleans = visit_object_array_object_property_boolean;
        visitor.visit_object_array_object_property_nulls = visit_object_array_object_property_null;

        archive_visit_archive(archive, &desc, &visitor, &capture);

        return true;
}


/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>
#include <inttypes.h>
#include <karbonit/json/json-parser.h>
#include <karbonit/archive/doc.h>
#include <karbonit/archive/column_doc.h>
#include <karbonit/json/json-parser.h>
#include <karbonit/utils/sort.h>

char VALUE_NULL = '\0';

static void create_doc(doc_obj *model, doc *doc);

static void create_typed_vector(doc_entries *entry);

static void entries_drop(doc_entries *entry);

static bool print_value(FILE *file, archive_field_e type, const vec ofType(<T>) *values);

static void _doc_print_object(FILE *file, const doc_obj *model);

static bool
import_json_object(doc_obj *target, const json_object *json_obj);

static void sort_columndoc_entries(column_doc_obj *columndoc);

bool doc_bulk_create(doc_bulk *bulk, string_dict *dic)
{
        bulk->dic = dic;
        vec_create(&bulk->keys, sizeof(char *), 500);
        vec_create(&bulk->values, sizeof(char *), 1000);
        vec_create(&bulk->models, sizeof(doc), 50);
        return true;
}

doc_obj *doc_bulk_new_obj(doc *model)
{
        if (!model) {
                return NULL;
        } else {
                doc_obj *retval = VEC_NEW_AND_GET(&model->obj_model, doc_obj);
                create_doc(retval, model);
                return retval;
        }
}

bool doc_bulk_get_dic_contents(vec ofType (const char *) **strings,
                               vec ofType(archive_field_sid_t) **string_ids,
                               const doc_bulk *context)
{
        size_t num_distinct_values;
        string_dict_num_distinct(&num_distinct_values, context->dic);
        vec ofType (const char *) *result_strings = MALLOC(sizeof(vec));
        vec ofType (archive_field_sid_t) *resultstring_id_ts = MALLOC(sizeof(vec));
        vec_create(result_strings, sizeof(const char *), num_distinct_values);
        vec_create(resultstring_id_ts, sizeof(archive_field_sid_t), num_distinct_values);

        int status = string_dict_get_contents(result_strings, resultstring_id_ts, context->dic);
        CHECK_SUCCESS(status);
        *strings = result_strings;
        *string_ids = resultstring_id_ts;

        return status;
}

doc *doc_bulk_new_doc(doc_bulk *context, archive_field_e type)
{
        if (!context) {
                return NULL;
        }

        doc template, *model;
        size_t idx = VEC_LENGTH(&context->models);
        vec_push(&context->models, &template, 1);
        model = VEC_GET(&context->models, idx, doc);
        model->context = context;
        model->type = type;

        vec_create(&model->obj_model, sizeof(doc_obj), 500);

        return model;
}

bool doc_bulk_drop(doc_bulk *bulk)
{
        for (size_t i = 0; i < bulk->keys.num_elems; i++) {
                char *string = *VEC_GET(&bulk->keys, i, char *);
                free(string);
        }
        for (size_t i = 0; i < bulk->values.num_elems; i++) {
                char *string = *VEC_GET(&bulk->values, i, char *);
                free(string);
        }
        for (size_t i = 0; i < bulk->models.num_elems; i++) {
                doc *model = VEC_GET(&bulk->models, i, doc);
                for (size_t j = 0; j < model->obj_model.num_elems; j++) {
                        doc_obj *doc = VEC_GET(&model->obj_model, j, doc_obj);
                        doc_drop(doc);
                }
                vec_drop(&model->obj_model);
        }

        vec_drop(&bulk->keys);
        vec_drop(&bulk->values);
        vec_drop(&bulk->models);
        return true;
}

bool doc_bulk_shrink(doc_bulk *bulk)
{
        vec_shrink(&bulk->keys);
        vec_shrink(&bulk->values);
        return true;
}

bool doc_bulk_print(FILE *file, doc_bulk *bulk)
{
        fprintf(file, "{");
        char **key_strings = VEC_ALL(&bulk->keys, char *);
        fprintf(file, "\"Key Strings\": [");
        for (size_t i = 0; i < bulk->keys.num_elems; i++) {
                fprintf(file, "\"%s\"%s", key_strings[i], i + 1 < bulk->keys.num_elems ? ", " : "");
        }
        fprintf(file, "], ");

        char **valueStrings = VEC_ALL(&bulk->values, char *);
        fprintf(file, "\"Value Strings\": [");
        for (size_t i = 0; i < bulk->values.num_elems; i++) {
                fprintf(file, "\"%s\"%s", valueStrings[i], i + 1 < bulk->values.num_elems ? ", " : "");
        }
        fprintf(file, "]}");

        return true;
}

bool doc_print(FILE *file, const doc *doc)
{
        if (doc->obj_model.num_elems == 0) {
                fprintf(file, "{ }");
        }

        if (doc->obj_model.num_elems > 1) {
                fprintf(file, "[");
        }

        for (size_t num_entries = 0; num_entries < doc->obj_model.num_elems; num_entries++) {
                doc_obj *object = VEC_GET(&doc->obj_model, num_entries, doc_obj);
                _doc_print_object(file, object);
                fprintf(file, "%s", num_entries + 1 < doc->obj_model.num_elems ? ", " : "");
        }

        if (doc->obj_model.num_elems > 1) {
                fprintf(file, "]");
        }

        return true;
}

const vec ofType(doc_entries) *doc_get_entries(const doc_obj *model)
{
        return &model->entries;
}

void doc_print_entries(FILE *file, const doc_entries *entries)
{
        fprintf(file, "{\"Key\": \"%s\"", entries->key);
}

void doc_drop(doc_obj *model)
{
        for (size_t i = 0; i < model->entries.num_elems; i++) {
                doc_entries *entry = VEC_GET(&model->entries, i, doc_entries);
                entries_drop(entry);
        }
        vec_drop(&model->entries);
}

bool doc_obj_add_key(doc_entries **out, doc_obj *obj, const char *key, archive_field_e type)
{
        size_t entry_idx;
        char *key_dup = strdup(key);

        doc_entries entry_model = {.type = type, .key = key_dup, .context = obj};

        create_typed_vector(&entry_model);
        vec_push(&obj->doc->context->keys, &key_dup, 1);

        entry_idx = VEC_LENGTH(&obj->entries);
        vec_push(&obj->entries, &entry_model, 1);

        *out = VEC_GET(&obj->entries, entry_idx, doc_entries);

        return true;
}

bool doc_obj_push_primtive(doc_entries *entry, const void *value)
{
        switch (entry->type) {
                case ARCHIVE_FIELD_NULL:
                        vec_push(&entry->values, &VALUE_NULL, 1);
                        break;
                case ARCHIVE_FIELD_STRING: {
                        char *string = value ? strdup((char *) value) : NULL;
                        vec_push(&entry->context->doc->context->values, &string, 1);
                        vec_push(&entry->values, &string, 1);
                }
                        break;
                default:
                        vec_push(&entry->values, value, 1);
                        break;
        }
        return true;
}

bool doc_obj_push_object(doc_obj **out, doc_entries *entry)
{
        assert(entry->type == ARCHIVE_FIELD_OBJECT);

        doc_obj objectModel;

        create_doc(&objectModel, entry->context->doc);
        size_t length = VEC_LENGTH(&entry->values);
        vec_push(&entry->values, &objectModel, 1);

        *out = VEC_GET(&entry->values, length, doc_obj);

        return true;
}

static archive_field_e
value_type_for_json_number(bool *success, const json_number *number)
{
        *success = true;
        switch (number->value_type) {
                case JSON_NUMBER_FLOAT:
                        return ARCHIVE_FIELD_FLOAT;
                case JSON_NUMBER_UNSIGNED: {
                        u64 test = number->value.unsigned_integer;
                        if (test <= LIMITS_UINT8_MAX) {
                                return ARCHIVE_FIELD_UINT8;
                        } else if (test <= LIMITS_UINT16_MAX) {
                                return ARCHIVE_FIELD_UINT16;
                        } else if (test <= LIMITS_UINT32_MAX) {
                                return ARCHIVE_FIELD_UINT32;
                        } else {
                                return ARCHIVE_FIELD_UINT64;
                        }
                }
                case JSON_NUMBER_SIGNED: {
                        i64 test = number->value.signed_integer;
                        if (test >= LIMITS_INT8_MIN && test <= LIMITS_INT8_MAX) {
                                return ARCHIVE_FIELD_INT8;
                        } else if (test >= LIMITS_INT16_MIN && test <= LIMITS_INT16_MAX) {
                                return ARCHIVE_FIELD_INT16;
                        } else if (test >= LIMITS_INT32_MIN && test <= LIMITS_INT32_MAX) {
                                return ARCHIVE_FIELD_INT32;
                        } else {
                                return ARCHIVE_FIELD_INT64;
                        }
                }
                default: ERROR(ERR_NOJSONNUMBERT, NULL);
                        *success = false;
                        return ARCHIVE_FIELD_INT8;
        }
}

static void
import_json_object_string_prop(doc_obj *target, const char *key, const json_string *string)
{
        doc_entries *entry;
        doc_obj_add_key(&entry, target, key, ARCHIVE_FIELD_STRING);
        doc_obj_push_primtive(entry, string->value);
}

static bool import_json_object_number_prop(doc_obj *target, const char *key,
                                           const json_number *number)
{
        doc_entries *entry;
        bool success;
        archive_field_e number_type = value_type_for_json_number(&success, number);
        if (!success) {
                return false;
        }
        doc_obj_add_key(&entry, target, key, number_type);
        doc_obj_push_primtive(entry, &number->value);
        return true;
}

static void import_json_object_bool_prop(doc_obj *target, const char *key, archive_field_boolean_t value)
{
        doc_entries *entry;
        doc_obj_add_key(&entry, target, key, ARCHIVE_FIELD_BOOLEAN);
        doc_obj_push_primtive(entry, &value);
}

static void import_json_object_null_prop(doc_obj *target, const char *key)
{
        doc_entries *entry;
        doc_obj_add_key(&entry, target, key, ARCHIVE_FIELD_NULL);
        doc_obj_push_primtive(entry, NULL);
}

static bool import_json_object_object_prop(doc_obj *target, const char *key,
                                           const json_object *object)
{
        doc_entries *entry;
        doc_obj *nested_object = NULL;
        doc_obj_add_key(&entry, target, key, ARCHIVE_FIELD_OBJECT);
        doc_obj_push_object(&nested_object, entry);
        return import_json_object(nested_object, object);
}

static bool import_json_object_array_prop(doc_obj *target, const char *key, const json_array *array)
{
        doc_entries *entry;

        if (!vec_is_empty(&array->elements.elements)) {
                size_t num_elements = array->elements.elements.num_elems;

                /** Find first type that is not null unless the entire array is of type null */
                json_value_type_e array_data_type = JSON_VALUE_NULL;
                archive_field_e field_type;

                for (size_t i = 0; i < num_elements && array_data_type == JSON_VALUE_NULL; i++) {
                        const json_element *element = VEC_GET(&array->elements.elements, i,
                                                                         json_element);
                        array_data_type = element->value.value_type;
                }

                switch (array_data_type) {
                        case JSON_VALUE_OBJECT:
                                field_type = ARCHIVE_FIELD_OBJECT;
                                break;
                        case JSON_VALUE_STRING:
                                field_type = ARCHIVE_FIELD_STRING;
                                break;
                        case JSON_VALUE_NUMBER: {
                                /** find smallest fitting physical number type */
                                archive_field_e array_number_type = ARCHIVE_FIELD_NULL;
                                for (size_t i = 0; i < num_elements; i++) {
                                        const json_element
                                                *element = VEC_GET(&array->elements.elements, i,
                                                                   json_element);
                                        if (UNLIKELY(element->value.value_type == JSON_VALUE_NULL)) {
                                                continue;
                                        } else {
                                                bool success;
                                                archive_field_e element_number_type =
                                                        value_type_for_json_number(&success,
                                                                                   element->value.value.number);
                                                if (!success) {
                                                        return false;
                                                }
                                                assert(element_number_type == ARCHIVE_FIELD_INT8 ||
                                                           element_number_type == ARCHIVE_FIELD_INT16
                                                           || element_number_type == ARCHIVE_FIELD_INT32
                                                           || element_number_type == ARCHIVE_FIELD_INT64
                                                           || element_number_type == ARCHIVE_FIELD_UINT8
                                                           || element_number_type == ARCHIVE_FIELD_UINT16
                                                           || element_number_type == ARCHIVE_FIELD_UINT32
                                                           || element_number_type == ARCHIVE_FIELD_UINT64
                                                           || element_number_type == ARCHIVE_FIELD_FLOAT);
                                                if (UNLIKELY(array_number_type == ARCHIVE_FIELD_NULL)) {
                                                        array_number_type = element_number_type;
                                                } else {
                                                        if (array_number_type == ARCHIVE_FIELD_INT8) {
                                                                array_number_type = element_number_type;
                                                        } else if (array_number_type == ARCHIVE_FIELD_INT16) {
                                                                if (element_number_type != ARCHIVE_FIELD_INT8) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == ARCHIVE_FIELD_INT32) {
                                                                if (element_number_type != ARCHIVE_FIELD_INT8
                                                                    && element_number_type != ARCHIVE_FIELD_INT16) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == ARCHIVE_FIELD_INT64) {
                                                                if (element_number_type != ARCHIVE_FIELD_INT8
                                                                    && element_number_type != ARCHIVE_FIELD_INT16
                                                                    && element_number_type != ARCHIVE_FIELD_INT32) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == ARCHIVE_FIELD_UINT8) {
                                                                array_number_type = element_number_type;
                                                        } else if (array_number_type == ARCHIVE_FIELD_UINT16) {
                                                                if (element_number_type != ARCHIVE_FIELD_UINT16) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == ARCHIVE_FIELD_UINT32) {
                                                                if (element_number_type != ARCHIVE_FIELD_UINT8
                                                                    && element_number_type != ARCHIVE_FIELD_UINT16) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == ARCHIVE_FIELD_UINT64) {
                                                                if (element_number_type != ARCHIVE_FIELD_UINT8
                                                                    && element_number_type != ARCHIVE_FIELD_UINT16
                                                                    && element_number_type != ARCHIVE_FIELD_UINT32) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == ARCHIVE_FIELD_FLOAT) {
                                                                break;
                                                        }
                                                }
                                        }
                                }
                                assert(array_number_type != ARCHIVE_FIELD_NULL);
                                field_type = array_number_type;
                        }
                                break;
                        case JSON_VALUE_FALSE:
                        case JSON_VALUE_TRUE:
                                field_type = ARCHIVE_FIELD_BOOLEAN;
                                break;
                        case JSON_VALUE_NULL:
                                field_type = ARCHIVE_FIELD_NULL;
                                break;
                        case JSON_VALUE_ARRAY:
                                return ERROR(ERR_ERRINTERNAL, NULL) /** array type is illegal here */;
                        default:
                                return ERROR(ERR_NOTYPE, NULL);
                }

                doc_obj_add_key(&entry, target, key, field_type);

                for (size_t i = 0; i < num_elements; i++) {
                        const json_element *element = VEC_GET(&array->elements.elements, i,
                                                                         json_element);
                        json_value_type_e ast_node_data_type = element->value.value_type;

                        switch (field_type) {
                                case ARCHIVE_FIELD_OBJECT: {
                                        doc_obj *nested_object = NULL;
                                        doc_obj_push_object(&nested_object, entry);
                                        if (ast_node_data_type != JSON_VALUE_NULL) {
                                                /** the object is null by definition, if no entries are contained */
                                                if (!import_json_object(nested_object, element->value.value.object)) {
                                                        return false;
                                                }
                                        }
                                }
                                        break;
                                case ARCHIVE_FIELD_STRING: {
                                        assert(ast_node_data_type == array_data_type ||
                                                   ast_node_data_type == JSON_VALUE_NULL);
                                        doc_obj_push_primtive(entry,
                                                              ast_node_data_type == JSON_VALUE_NULL
                                                              ? NULL_ENCODED_STRING : element->value
                                                                      .value.string->value);
                                }
                                        break;
                                case ARCHIVE_FIELD_INT8:
                                case ARCHIVE_FIELD_INT16:
                                case ARCHIVE_FIELD_INT32:
                                case ARCHIVE_FIELD_INT64:
                                case ARCHIVE_FIELD_UINT8:
                                case ARCHIVE_FIELD_UINT16:
                                case ARCHIVE_FIELD_UINT32:
                                case ARCHIVE_FIELD_UINT64:
                                case ARCHIVE_FIELD_FLOAT: {
                                        assert(ast_node_data_type == array_data_type ||
                                                   ast_node_data_type == JSON_VALUE_NULL);
                                        switch (field_type) {
                                                case ARCHIVE_FIELD_INT8: {
                                                        archive_field_i8_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_INT8
                                                                                                      : (archive_field_i8_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_INT16: {
                                                        archive_field_i16_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_INT16
                                                                                                      : (archive_field_i16_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_INT32: {
                                                        archive_field_i32_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_INT32
                                                                                                      : (archive_field_i32_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_INT64: {
                                                        archive_field_i64_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_INT64
                                                                                                      : (archive_field_i64_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_UINT8: {
                                                        archive_field_u8_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_UINT8
                                                                                                      : (archive_field_u8_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_UINT16: {
                                                        archive_field_u16_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_UINT16
                                                                                                      : (archive_field_u16_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_UINT32: {
                                                        archive_field_u32_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_UINT32
                                                                                                      : (archive_field_u32_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_UINT64: {
                                                        archive_field_u64_t value =
                                                                ast_node_data_type == JSON_VALUE_NULL ? NULL_UINT64
                                                                                                      : (archive_field_u64_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case ARCHIVE_FIELD_FLOAT: {
                                                        archive_field_number_t value = NULL_FLOAT;
                                                        if (ast_node_data_type != JSON_VALUE_NULL) {
                                                                json_number_type_e
                                                                        element_number_type = element->value.value.number->value_type;
                                                                if (element_number_type == JSON_NUMBER_FLOAT) {
                                                                        value = element->value.value.number->value.float_number;
                                                                } else if (element_number_type ==
                                                                           JSON_NUMBER_UNSIGNED) {
                                                                        value = element->value.value.number->value.unsigned_integer;
                                                                } else if (element_number_type == JSON_NUMBER_SIGNED) {
                                                                        value = element->value.value.number->value.signed_integer;
                                                                } else {
                                                                        return ERROR(ERR_INTERNALERR, NULL) /** type mismatch */;
                                                                }
                                                        }
                                                        doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                default:
                                                        return ERROR(ERR_INTERNALERR, NULL) /** not a number type  */;
                                        }
                                }
                                        break;
                                case ARCHIVE_FIELD_BOOLEAN:
                                        if (LIKELY(ast_node_data_type == JSON_VALUE_TRUE
                                                       || ast_node_data_type == JSON_VALUE_FALSE)) {
                                                archive_field_boolean_t value =
                                                        ast_node_data_type == JSON_VALUE_TRUE ? BOOLEAN_TRUE
                                                                                              : BOOLEAN_FALSE;
                                                doc_obj_push_primtive(entry, &value);
                                        } else {
                                                assert(ast_node_data_type == JSON_VALUE_NULL);
                                                archive_field_boolean_t value = NULL_BOOLEAN;
                                                doc_obj_push_primtive(entry, &value);
                                        }
                                        break;
                                case ARCHIVE_FIELD_NULL:
                                        assert(ast_node_data_type == array_data_type);
                                        doc_obj_push_primtive(entry, NULL);
                                        break;
                                default:
                                        return ERROR(ERR_NOTYPE, NULL);
                        }
                }
        } else {
                import_json_object_null_prop(target, key);
        }
        return true;
}

static bool
import_json_object(doc_obj *target, const json_object *json_obj)
{
        for (size_t i = 0; i < json_obj->value->members.num_elems; i++) {
                json_prop *member = VEC_GET(&json_obj->value->members, i, json_prop);
                json_value_type_e value_type = member->value.value.value_type;
                switch (value_type) {
                        case JSON_VALUE_STRING:
                                import_json_object_string_prop(target, member->key.value,
                                                               member->value.value.value.string);
                                break;
                        case JSON_VALUE_NUMBER:
                                if (!import_json_object_number_prop(target,
                                                                    member->key.value,
                                                                    member->value.value.value.number)) {
                                        return false;
                                }
                                break;
                        case JSON_VALUE_TRUE:
                        case JSON_VALUE_FALSE: {
                                archive_field_boolean_t value =
                                        value_type == JSON_VALUE_TRUE ? BOOLEAN_TRUE : BOOLEAN_FALSE;
                                import_json_object_bool_prop(target, member->key.value, value);
                        }
                                break;
                        case JSON_VALUE_NULL:
                                import_json_object_null_prop(target, member->key.value);
                                break;
                        case JSON_VALUE_OBJECT:
                                if (!import_json_object_object_prop(target,
                                                                    member->key.value,
                                                                    member->value.value.value.object)) {
                                        return false;
                                }
                                break;
                        case JSON_VALUE_ARRAY:
                                if (!import_json_object_array_prop(target,
                                                                   member->key.value,
                                                                   member->value.value.value.array)) {
                                        return false;
                                }
                                break;
                        default: ERROR(ERR_NOTYPE, NULL);
                                return false;
                }
        }
        return true;
}

static bool
import_json(doc_obj *target, const json *json,
            doc_entries *partition)
{
        json_value_type_e value_type = json->element->value.value_type;
        switch (value_type) {
                case JSON_VALUE_OBJECT:
                        if (!import_json_object(target, json->element->value.value.object)) {
                                return false;
                        }
                        break;
                case JSON_VALUE_ARRAY: {
                        const vec ofType(json_element)
                                *arrayContent = &json->element->value.value.array->elements.elements;
                        if (!vec_is_empty(arrayContent)) {
                                const json_element *first = VEC_GET(arrayContent, 0,
                                                                               json_element);
                                switch (first->value.value_type) {
                                        case JSON_VALUE_OBJECT:
                                                if (!import_json_object(target, first->value.value.object)) {
                                                        return false;
                                                }
                                                for (size_t i = 1; i < arrayContent->num_elems; i++) {
                                                        const json_element
                                                                *element = VEC_GET(arrayContent, i,
                                                                                   json_element);
                                                        doc_obj *nested;
                                                        doc_obj_push_object(&nested, partition);
                                                        if (!import_json_object(nested, element->value.value.object)) {
                                                                return false;
                                                        }
                                                }
                                                break;
                                        case JSON_VALUE_ARRAY:
                                        case JSON_VALUE_STRING:
                                        case JSON_VALUE_NUMBER:
                                        case JSON_VALUE_TRUE:
                                        case JSON_VALUE_FALSE:
                                        case JSON_VALUE_NULL:
                                        default: return ERROR(ERR_INTERNALERR, NULL); /** Unsupported operation in arrays */
                                }
                        }
                }
                        break;
                case JSON_VALUE_STRING:
                case JSON_VALUE_NUMBER:
                case JSON_VALUE_TRUE:
                case JSON_VALUE_FALSE:
                case JSON_VALUE_NULL:
                default: return ERROR(ERR_JSONTYPE, NULL);
        }
        return true;
}

doc_obj *doc_bulk_add_json(doc_entries *partition, json *json)
{
        if (!partition || !json) {
                return NULL;
        }

        doc_obj *converted_json;
        doc_obj_push_object(&converted_json, partition);
        if (!import_json(converted_json, json, partition)) {
                return NULL;
        }

        return converted_json;
}

doc_obj *doc_entries_get_root(const doc_entries *partition)
{
        return partition ? partition->context : NULL;
}

doc_entries *doc_bulk_new_entries(doc_bulk *dst)
{
        doc_entries *partition = NULL;
        doc *model = doc_bulk_new_doc(dst, ARCHIVE_FIELD_OBJECT);
        doc_obj *object = doc_bulk_new_obj(model);
        doc_obj_add_key(&partition, object, "/", ARCHIVE_FIELD_OBJECT);
        return partition;
}

#define DEFINE_TYPE_LQ_FUNC(type)                                                                               \
static bool compare_##type##_leq(const void *lhs, const void *rhs)                                                \
{                                                                                                                      \
    archive_##type a = *(archive_##type *) lhs;                                                                                            \
    archive_##type b = *(archive_##type *) rhs;                                                                                            \
    return (a <= b);                                                                                                   \
}

DEFINE_TYPE_LQ_FUNC(field_boolean_t)

DEFINE_TYPE_LQ_FUNC(field_number_t)

DEFINE_TYPE_LQ_FUNC(field_i8_t)

DEFINE_TYPE_LQ_FUNC(field_i16_t)

DEFINE_TYPE_LQ_FUNC(field_i32_t)

DEFINE_TYPE_LQ_FUNC(field_i64_t)

DEFINE_TYPE_LQ_FUNC(field_u8_t)

DEFINE_TYPE_LQ_FUNC(field_u16_t)

DEFINE_TYPE_LQ_FUNC(field_u32_t)

DEFINE_TYPE_LQ_FUNC(field_u64_t)

static bool compare_encoded_string_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        string_dict *dic = (string_dict *) args;
        archive_field_sid_t *a = (archive_field_sid_t *) lhs;
        archive_field_sid_t *b = (archive_field_sid_t *) rhs;
        char **a_string = string_dict_extract(dic, a, 1);
        char **b_string = string_dict_extract(dic, b, 1);
        bool lq = strcmp(*a_string, *b_string) <= 0;
        string_dict_free(dic, a_string);
        string_dict_free(dic, b_string);
        return lq;
}

static void sort_nested_primitive_object(column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                for (size_t i = 0; i < columndoc->obj_prop_vals.num_elems; i++) {
                        column_doc_obj *nestedModel = VEC_GET(&columndoc->obj_prop_vals, i,
                                                                         column_doc_obj);
                        sort_columndoc_entries(nestedModel);
                }
        }
}

#define DEFINE_ARRAY_TYPE_LQ_FUNC(type)                                                                         \
static bool compare_##type##_array_leq(const void *lhs, const void *rhs)                                           \
{                                                                                                                      \
    vec ofType(archive_##type) *a = (vec *) lhs;                                                               \
    vec ofType(archive_##type) *b = (vec *) rhs;                                                               \
    const archive_##type *aValues = VEC_ALL(a, archive_##type);                                                                  \
    const archive_##type *bValues = VEC_ALL(b, archive_##type);                                                                  \
    size_t max_compare_idx = a->num_elems < b->num_elems ? a->num_elems : b->num_elems;                                \
    for (size_t i = 0; i < max_compare_idx; i++) {                                                                     \
        if (aValues[i] > bValues[i]) {                                                                                 \
            return false;                                                                                              \
        }                                                                                                              \
    }                                                                                                                  \
    return true;                                                                                                       \
}

DEFINE_ARRAY_TYPE_LQ_FUNC(field_boolean_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_i8_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_i16_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_i32_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_i64_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_u8_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_u16_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_u32_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_u64_t)

DEFINE_ARRAY_TYPE_LQ_FUNC(field_number_t)

static bool compare_encoded_string_array_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        string_dict *dic = (string_dict *) args;
        vec ofType(archive_field_sid_t) *a = (vec *) lhs;
        vec ofType(archive_field_sid_t) *b = (vec *) rhs;
        const archive_field_sid_t *aValues = VEC_ALL(a, archive_field_sid_t);
        const archive_field_sid_t *bValues = VEC_ALL(b, archive_field_sid_t);
        size_t max_compare_idx = a->num_elems < b->num_elems ? a->num_elems : b->num_elems;
        for (size_t i = 0; i < max_compare_idx; i++) {
                char **aString = string_dict_extract(dic, aValues + i, 1);
                char **bString = string_dict_extract(dic, bValues + i, 1);
                bool greater = strcmp(*aString, *bString) > 0;
                string_dict_free(dic, aString);
                string_dict_free(dic, bString);
                if (greater) {
                        return false;
                }
        }
        return true;
}

static void sorted_nested_array_objects(column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                for (size_t i = 0; i < columndoc->obj_array_props.num_elems; i++) {
                        column_doc_group
                                *array_columns = VEC_GET(&columndoc->obj_array_props, i, column_doc_group);
                        for (size_t j = 0; j < array_columns->columns.num_elems; j++) {
                                column_doc_column
                                        *column = VEC_GET(&array_columns->columns, j, column_doc_column);
                                vec ofType(u32) *array_indices = &column->array_positions;
                                vec ofType(
                                        vec ofType(<T>)) *values_for_indicies = &column->values;
                                assert (array_indices->num_elems == values_for_indicies->num_elems);

                                for (size_t k = 0; k < array_indices->num_elems; k++) {
                                        vec ofType(<T>)
                                                *values_for_index = VEC_GET(values_for_indicies, k, vec);
                                        if (column->type == ARCHIVE_FIELD_OBJECT) {
                                                for (size_t l = 0; l < values_for_index->num_elems; l++) {
                                                        column_doc_obj *nested_object =
                                                                VEC_GET(values_for_index, l, column_doc_obj);
                                                        sort_columndoc_entries(nested_object);
                                                }
                                        }
                                }
                        }
                }
        }
}

#define SORT_META_MODEL_VALUES(key_vector, value_vector, value_type, compareValueFunc)                                 \
{                                                                                                                      \
    size_t num_elements = VEC_LENGTH(&key_vector);                                                              \
                                                                                                                       \
    if (num_elements > 0) {                                                                                            \
        size_t *value_indicies = MALLOC(sizeof(size_t) * num_elements);                                                \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            value_indicies[i] = i;                                                                                     \
        }                                                                                                              \
                                                                                                                       \
        vec ofType(archive_field_sid_t) key_cpy;                                                               \
        vec ofType(value_type) value_cpy;                                                                     \
                                                                                                                       \
        vec_cpy(&key_cpy, &key_vector);                                                                         \
        vec_cpy(&value_cpy, &value_vector);                                                                     \
                                                                                                                       \
        value_type *values = VEC_ALL(&value_cpy, value_type);                                                \
                                                                                                                       \
        sort_qsort_indicies(value_indicies, values, sizeof(value_type), compareValueFunc, num_elements);                                                                           \
                                                                                                                       \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            vec_set(&key_vector, i, VEC_GET(&key_cpy, value_indicies[i], archive_field_sid_t));        \
            vec_set(&value_vector, i, VEC_GET(&value_cpy, value_indicies[i], value_type));            \
        }                                                                                                              \
                                                                                                                       \
                                                                                                                       \
        free(value_indicies);                                                                                          \
        vec_drop(&key_cpy);                                                                                     \
        vec_drop(&value_cpy);                                                                                   \
    }                                                                                                                  \
}

static void sort_meta_model_string_values(vec ofType(archive_field_sid_t) *key_vector,
                                          vec ofType(archive_field_sid_t) *value_vector,
                                          string_dict *dic)
{
        size_t num_elements = VEC_LENGTH(key_vector);

        if (num_elements > 0) {
                size_t *value_indicies = MALLOC(sizeof(size_t) * num_elements);
                for (size_t i = 0; i < num_elements; i++) {
                        value_indicies[i] = i;
                }

                vec ofType(archive_field_sid_t) key_cpy;
                vec ofType(archive_field_sid_t) value_cpy;

                vec_cpy(&key_cpy, key_vector);
                vec_cpy(&value_cpy, value_vector);

                archive_field_sid_t *values = VEC_ALL(&value_cpy, archive_field_sid_t);

                sort_qsort_indicies_wargs(value_indicies,
                                          values,
                                          sizeof(archive_field_sid_t),
                                          compare_encoded_string_less_eq_func,
                                          num_elements,
                                          dic);

                for (size_t i = 0; i < num_elements; i++) {
                        vec_set(key_vector, i, VEC_GET(&key_cpy, value_indicies[i], archive_field_sid_t));
                        vec_set(value_vector, i, VEC_GET(&value_cpy, value_indicies[i], archive_field_sid_t));
                }

                free(value_indicies);
                vec_drop(&key_cpy);
                vec_drop(&value_cpy);
        }
}

#define SORT_META_MODEL_ARRAYS(key_vector, value_array_vector, compare_func)                                           \
{                                                                                                                      \
    size_t num_elements = VEC_LENGTH(&key_vector);                                                              \
                                                                                                                       \
    if (num_elements > 0) {                                                                                            \
        size_t *value_indicies = MALLOC(sizeof(size_t) * num_elements);                                                \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            value_indicies[i] = i;                                                                                     \
        }                                                                                                              \
                                                                                                                       \
        vec ofType(archive_field_sid_t) key_cpy;                                                               \
        vec ofType(vec) value_cpy;                                                                   \
                                                                                                                       \
        vec_cpy(&key_cpy, &key_vector);                                                                         \
        vec_cpy(&value_cpy, &value_array_vector);                                                               \
                                                                                                                       \
        const vec *values = VEC_ALL(&value_array_vector, vec);                             \
                                                                                                                       \
        sort_qsort_indicies(value_indicies, values, sizeof(vec), compare_func, num_elements);                                                                           \
                                                                                                                       \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            vec_set(&key_vector, i, VEC_GET(&key_cpy, value_indicies[i], archive_field_sid_t));        \
            vec_set(&value_array_vector, i, VEC_GET(&value_cpy, value_indicies[i], vec));    \
        }                                                                                                              \
                                                                                                                       \
        free(value_indicies);                                                                                          \
        vec_drop(&key_cpy);                                                                                     \
        vec_drop(&value_cpy);                                                                                   \
    }                                                                                                                  \
}

static void sort_columndoc_strings_arrays(vec ofType(archive_field_sid_t) *key_vector,
                                          vec ofType(archive_field_sid_t) *value_array_vector,
                                          string_dict *dic)
{
        size_t num_elements = VEC_LENGTH(key_vector);

        if (num_elements > 0) {
                size_t *value_indicies = MALLOC(sizeof(size_t) * num_elements);
                for (size_t i = 0; i < num_elements; i++) {
                        value_indicies[i] = i;
                }

                vec ofType(archive_field_sid_t) key_cpy;
                vec ofType(vec) value_cpy;

                vec_cpy(&key_cpy, key_vector);
                vec_cpy(&value_cpy, value_array_vector);

                const vec *values = VEC_ALL(value_array_vector, vec);

                sort_qsort_indicies_wargs(value_indicies,
                                          values,
                                          sizeof(vec),
                                          compare_encoded_string_array_less_eq_func,
                                          num_elements,
                                          dic);

                for (size_t i = 0; i < num_elements; i++) {
                        vec_set(key_vector, i, VEC_GET(&key_cpy, value_indicies[i], archive_field_sid_t));
                        vec_set(value_array_vector, i, VEC_GET(&value_cpy, value_indicies[i], vec));
                }

                free(value_indicies);
                vec_drop(&key_cpy);
                vec_drop(&value_cpy);
        }
}

static bool compare_object_array_key_columns_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        string_dict *dic = (string_dict *) args;
        column_doc_group *a = (column_doc_group *) lhs;
        column_doc_group *b = (column_doc_group *) rhs;
        char **a_column_name = string_dict_extract(dic, &a->key, 1);
        char **b_column_name = string_dict_extract(dic, &b->key, 1);
        bool column_name_leq = strcmp(*a_column_name, *b_column_name) <= 0;
        string_dict_free(dic, a_column_name);
        string_dict_free(dic, b_column_name);
        return column_name_leq;
}

static bool compare_object_array_key_column_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        string_dict *dic = (string_dict *) args;
        column_doc_column *a = (column_doc_column *) lhs;
        column_doc_column *b = (column_doc_column *) rhs;
        char **a_column_name = string_dict_extract(dic, &a->key_name, 1);
        char **b_column_name = string_dict_extract(dic, &b->key_name, 1);
        int cmpResult = strcmp(*a_column_name, *b_column_name);
        bool column_name_leq = cmpResult < 0 ? true : (cmpResult == 0 ? (a->type <= b->type) : false);
        string_dict_free(dic, a_column_name);
        string_dict_free(dic, b_column_name);
        return column_name_leq;
}

struct com_column_leq_arg {
        string_dict *dic;
        archive_field_e value_type;
};

#define ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, type, valueVectorAPtr, valueVectorBPtr)                                 \
{                                                                                                                      \
    for (size_t i = 0; i < max_num_elem; i++) {                                                                        \
        type o1 = *VEC_GET(valueVectorAPtr, i, type);                                                        \
        type o2 = *VEC_GET(valueVectorBPtr, i, type);                                                        \
        if (o1 > o2) {                                                                                                 \
            return false;                                                                                              \
        }                                                                                                              \
    }                                                                                                                  \
    return true;                                                                                                       \
}

static bool compare_column_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        vec ofType(<T>) *a = (vec *) lhs;
        vec ofType(<T>) *b = (vec *) rhs;
        struct com_column_leq_arg *func_arg = (struct com_column_leq_arg *) args;

        size_t max_num_elem = JAK_MIN(a->num_elems, b->num_elems);

        switch (func_arg->value_type) {
                case ARCHIVE_FIELD_NULL:
                        return (a->num_elems <= b->num_elems);
                        break;
                case ARCHIVE_FIELD_BOOLEAN: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_boolean_t, a, b);
                        break;
                case ARCHIVE_FIELD_INT8: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_i8_t, a, b);
                        break;
                case ARCHIVE_FIELD_INT16: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_i16_t, a, b);
                        break;
                case ARCHIVE_FIELD_INT32: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_i32_t, a, b);
                        break;
                case ARCHIVE_FIELD_INT64: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_i64_t, a, b);
                        break;
                case ARCHIVE_FIELD_UINT8: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_u8_t, a, b);
                        break;
                case ARCHIVE_FIELD_UINT16: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_u16_t, a, b);
                        break;
                case ARCHIVE_FIELD_UINT32: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_u32_t, a, b);
                        break;
                case ARCHIVE_FIELD_UINT64: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_u64_t, a, b);
                        break;
                case ARCHIVE_FIELD_FLOAT: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, archive_field_number_t, a, b);
                        break;
                case ARCHIVE_FIELD_STRING:
                        for (size_t i = 0; i < max_num_elem; i++) {
                                archive_field_sid_t o1 = *VEC_GET(a, i, archive_field_sid_t);
                                archive_field_sid_t o2 = *VEC_GET(b, i, archive_field_sid_t);
                                char **o1_string = string_dict_extract(func_arg->dic, &o1, 1);
                                char **o2_string = string_dict_extract(func_arg->dic, &o2, 1);
                                bool greater = strcmp(*o1_string, *o2_string) > 0;
                                string_dict_free(func_arg->dic, o1_string);
                                string_dict_free(func_arg->dic, o2_string);
                                if (greater) {
                                        return false;
                                }
                        }
                        return true;
                case ARCHIVE_FIELD_OBJECT:
                        return true;
                        break;
                default:
                        return ERROR(ERR_NOTYPE, NULL);
        }
}

static void sort_columndoc_column(column_doc_column *column, string_dict *dic)
{
        /** Sort column by its value, and re-arrange the array position list according this new order */
        vec ofType(u32) array_position_cpy;
        vec ofType(vec ofType(<T>)) values_cpy;

        vec_cpy(&array_position_cpy, &column->array_positions);
        vec_cpy(&values_cpy, &column->values);

        assert(column->array_positions.num_elems == column->values.num_elems);
        assert(array_position_cpy.num_elems == values_cpy.num_elems);
        assert(values_cpy.num_elems == column->array_positions.num_elems);

        size_t *indices = MALLOC(values_cpy.num_elems * sizeof(size_t));
        for (size_t i = 0; i < values_cpy.num_elems; i++) {
                indices[i] = i;
        }

        struct com_column_leq_arg func_arg = {.dic = dic, .value_type = column->type};

        sort_qsort_indicies_wargs(indices,
                                  values_cpy.base,
                                  values_cpy.elem_size,
                                  compare_column_less_eq_func,
                                  values_cpy.num_elems,
                                  &func_arg);

        for (size_t i = 0; i < values_cpy.num_elems; i++) {
                vec_set(&column->values, i, vec_at(&values_cpy, indices[i]));
                vec_set(&column->array_positions, i, vec_at(&array_position_cpy, indices[i]));
        }

        free(indices);
        vec_drop(&array_position_cpy);
        vec_drop(&values_cpy);
}

static void sort_columndoc_column_arrays(column_doc_obj *columndoc)
{
        vec ofType(column_doc_group) cpy;
        vec_cpy(&cpy, &columndoc->obj_array_props);
        size_t *indices = MALLOC(cpy.num_elems * sizeof(size_t));
        for (size_t i = 0; i < cpy.num_elems; i++) {
                indices[i] = i;
        }
        sort_qsort_indicies_wargs(indices,
                                  cpy.base,
                                  sizeof(column_doc_group),
                                  compare_object_array_key_columns_less_eq_func,
                                  cpy.num_elems,
                                  columndoc->parent->dic);
        for (size_t i = 0; i < cpy.num_elems; i++) {
                vec_set(&columndoc->obj_array_props, i, VEC_GET(&cpy, indices[i], column_doc_group));
        }
        free(indices);

        for (size_t i = 0; i < cpy.num_elems; i++) {
                column_doc_group *key_columns = VEC_GET(&columndoc->obj_array_props, i,
                                                                   column_doc_group);
                size_t *columnIndices = MALLOC(key_columns->columns.num_elems * sizeof(size_t));
                vec ofType(column_doc_column) columnCpy;
                vec_cpy(&columnCpy, &key_columns->columns);
                for (size_t i = 0; i < key_columns->columns.num_elems; i++) {
                        columnIndices[i] = i;
                }

                /** First, sort by column name; Then, sort by columns with same name by type */
                sort_qsort_indicies_wargs(columnIndices,
                                          columnCpy.base,
                                          sizeof(column_doc_column),
                                          compare_object_array_key_column_less_eq_func,
                                          key_columns->columns.num_elems,
                                          columndoc->parent->dic);
                for (size_t i = 0; i < key_columns->columns.num_elems; i++) {
                        vec_set(&key_columns->columns,
                                i,
                                VEC_GET(&columnCpy, columnIndices[i], column_doc_column));
                        column_doc_column *column = VEC_GET(&key_columns->columns, i,
                                                                       column_doc_column);
                        sort_columndoc_column(column, columndoc->parent->dic);
                }

                vec_drop(&columnCpy);
                free(columnIndices);
        }
        vec_drop(&cpy);
}

static void sort_columndoc_values(column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                SORT_META_MODEL_VALUES(columndoc->bool_prop_keys,
                                       columndoc->bool_prop_vals,
                                       archive_field_boolean_t,
                                       compare_field_boolean_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int8_prop_keys,
                                       columndoc->int8_prop_vals,
                                       archive_field_i8_t,
                                       compare_field_i8_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int16_prop_keys,
                                       columndoc->int16_prop_vals,
                                       archive_field_i16_t,
                                       compare_field_i16_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int32_prop_keys,
                                       columndoc->int32_prop_vals,
                                       archive_field_i32_t,
                                       compare_field_i32_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int64_prop_keys,
                                       columndoc->int64_prop_vals,
                                       archive_field_i64_t,
                                       compare_field_i64_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uint8_prop_keys,
                                       columndoc->uint8_prop_vals,
                                       archive_field_u8_t,
                                       compare_field_u8_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uint16_prop_keys,
                                       columndoc->uint16_prop_vals,
                                       archive_field_u16_t,
                                       compare_field_u16_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uin32_prop_keys,
                                       columndoc->uint32_prop_vals,
                                       archive_field_u32_t,
                                       compare_field_u32_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uint64_prop_keys,
                                       columndoc->uint64_prop_vals,
                                       archive_field_u64_t,
                                       compare_field_u64_t_leq);
                SORT_META_MODEL_VALUES(columndoc->float_prop_keys,
                                       columndoc->float_prop_vals,
                                       archive_field_number_t,
                                       compare_field_number_t_leq);
                sort_meta_model_string_values(&columndoc->string_prop_keys,
                                              &columndoc->string_prop_vals,
                                              columndoc->parent->dic);

                SORT_META_MODEL_ARRAYS(columndoc->bool_array_prop_keys,
                                       columndoc->bool_array_prop_vals,
                                       compare_field_boolean_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int8_array_prop_keys,
                                       columndoc->int8_array_prop_vals,
                                       compare_field_i8_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int16_array_prop_keys,
                                       columndoc->int16_array_prop_vals,
                                       compare_field_i16_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int32_array_prop_keys,
                                       columndoc->int32_array_prop_vals,
                                       compare_field_i32_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int64_array_prop_keys,
                                       columndoc->int64_array_prop_vals,
                                       compare_field_i64_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint8_array_prop_keys,
                                       columndoc->uint8_array_prop_vals,
                                       compare_field_u8_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint16_array_prop_keys,
                                       columndoc->uint16_array_prop_vals,
                                       compare_field_u16_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint32_array_prop_keys,
                                       columndoc->uint32_array_prop_vals,
                                       compare_field_u32_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint64_array_prop_keys,
                                       columndoc->ui64_array_prop_vals,
                                       compare_field_u64_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->float_array_prop_keys,
                                       columndoc->float_array_prop_vals,
                                       compare_field_number_t_array_leq);
                sort_columndoc_strings_arrays(&columndoc->string_array_prop_keys,
                                              &columndoc->string_array_prop_vals,
                                              columndoc->parent->dic);

                sort_columndoc_column_arrays(columndoc);
        }
}

static void sort_columndoc_entries(column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                sort_columndoc_values(columndoc);
                sort_nested_primitive_object(columndoc);
                sorted_nested_array_objects(columndoc);
        }
}

column_doc *doc_entries_columndoc(const doc_bulk *bulk, const doc_entries *partition,
                                             bool read_optimized)
{
        if (!bulk || !partition) {
                return NULL;
        }

        // Step 1: encode all strings at once in a bulk
        char *const *key_strings = VEC_ALL(&bulk->keys, char *);
        char *const *valueStrings = VEC_ALL(&bulk->values, char *);
        string_dict_insert(bulk->dic, NULL, key_strings, VEC_LENGTH(&bulk->keys), 0);
        string_dict_insert(bulk->dic, NULL, valueStrings, VEC_LENGTH(&bulk->values), 0);

        // Step 2: for each document doc, create a meta doc, and construct a binary compressed document
        const doc *models = VEC_ALL(&bulk->models, doc);
        assert (bulk->models.num_elems == 1);

        const doc *model = models;

        column_doc *columndoc = MALLOC(sizeof(column_doc));
        columndoc->read_optimized = read_optimized;
        if (!columndoc_create(columndoc, model, bulk, partition, bulk->dic)) {
                error_print(stderr);
        }

        if (columndoc->read_optimized) {
                sort_columndoc_entries(&columndoc->columndoc);
        }

        return columndoc;
}

bool doc_entries_drop(doc_entries *partition)
{
        UNUSED(partition);
        return true;
}

static void create_doc(doc_obj *model, doc *doc)
{
        vec_create(&model->entries, sizeof(doc_entries), 50);
        model->doc = doc;
}

static void create_typed_vector(doc_entries *entry)
{
        size_t size;
        switch (entry->type) {
                case ARCHIVE_FIELD_NULL:
                        size = sizeof(field_null_t);
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                        size = sizeof(archive_field_boolean_t);
                        break;
                case ARCHIVE_FIELD_INT8:
                        size = sizeof(archive_field_i8_t);
                        break;
                case ARCHIVE_FIELD_INT16:
                        size = sizeof(archive_field_i16_t);
                        break;
                case ARCHIVE_FIELD_INT32:
                        size = sizeof(archive_field_i32_t);
                        break;
                case ARCHIVE_FIELD_INT64:
                        size = sizeof(archive_field_i64_t);
                        break;
                case ARCHIVE_FIELD_UINT8:
                        size = sizeof(archive_field_u8_t);
                        break;
                case ARCHIVE_FIELD_UINT16:
                        size = sizeof(archive_field_u16_t);
                        break;
                case ARCHIVE_FIELD_UINT32:
                        size = sizeof(archive_field_u32_t);
                        break;
                case ARCHIVE_FIELD_UINT64:
                        size = sizeof(archive_field_u64_t);
                        break;
                case ARCHIVE_FIELD_FLOAT:
                        size = sizeof(archive_field_number_t);
                        break;
                case ARCHIVE_FIELD_STRING:
                        size = sizeof(field_string_t);
                        break;
                case ARCHIVE_FIELD_OBJECT:
                        size = sizeof(doc_obj);
                        break;
                default: ERROR(ERR_INTERNALERR, "unknown type"); /** unknown type */
                        return;
        }
        vec_create(&entry->values, size, 50);
}

static void entries_drop(doc_entries *entry)
{
        if (entry->type == ARCHIVE_FIELD_OBJECT) {
                for (size_t i = 0; i < entry->values.num_elems; i++) {
                        doc_obj *model = VEC_GET(&entry->values, i, doc_obj);
                        doc_drop(model);
                }
        }
        vec_drop(&entry->values);
}

static bool print_value(FILE *file, archive_field_e type, const vec ofType(<T>) *values)
{
        size_t num_values = values->num_elems;
        if (num_values == 0) {
                fprintf(file, "null");
                return true;
        }
        if (num_values > 1) {
                fprintf(file, "[");
        }
        switch (type) {
                case ARCHIVE_FIELD_NULL: {
                        for (size_t i = 0; i < num_values; i++) {
                                fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                        }
                }
                        break;
                case ARCHIVE_FIELD_BOOLEAN: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_boolean_t value = *(VEC_GET(values, i, archive_field_boolean_t));
                                if (value != NULL_BOOLEAN) {
                                        fprintf(file, "%s%s", value == 0 ? "false" : "true",
                                                i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_INT8: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_i8_t value = *(VEC_GET(values, i, archive_field_i8_t));
                                if (value != NULL_INT8) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_INT16: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_i16_t value = *(VEC_GET(values, i, archive_field_i16_t));
                                if (value != NULL_INT16) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_INT32: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_i32_t value = *(VEC_GET(values, i, archive_field_i32_t));
                                if (value != NULL_INT32) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_INT64: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_i64_t value = *(VEC_GET(values, i, archive_field_i64_t));
                                if (value != NULL_INT64) {
                                        fprintf(file, "%" PRIi64 "%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_UINT8: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_u8_t value = *(VEC_GET(values, i, archive_field_u8_t));
                                if (value != NULL_UINT8) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_UINT16: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_u16_t value = *(VEC_GET(values, i, archive_field_u16_t));
                                if (value != NULL_UINT16) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_UINT32: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_u32_t value = *(VEC_GET(values, i, archive_field_u32_t));
                                if (value != NULL_UINT32) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_UINT64: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_u64_t value = *(VEC_GET(values, i, archive_field_u64_t));
                                if (value != NULL_UINT64) {
                                        fprintf(file, "%" PRIu64 "%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_FLOAT: {
                        for (size_t i = 0; i < num_values; i++) {
                                archive_field_number_t value = *(VEC_GET(values, i, archive_field_number_t));
                                if (!isnan(value)) {
                                        fprintf(file, "%f%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_STRING: {
                        for (size_t i = 0; i < num_values; i++) {
                                field_string_t value = *(VEC_GET(values, i, field_string_t));
                                if (value) {
                                        fprintf(file, "\"%s\"%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case ARCHIVE_FIELD_OBJECT: {
                        for (size_t i = 0; i < num_values; i++) {
                                doc_obj *obj = VEC_GET(values, i, doc_obj);
                                if (!NULL_OBJECT_MODEL(obj)) {
                                        _doc_print_object(file, obj);
                                } else {
                                        fprintf(file, "null");
                                }
                                fprintf(file, "%s", i + 1 < num_values ? ", " : "");
                        }
                }
                        break;
                default: ERROR(ERR_NOTIMPLEMENTED, NULL);
        }
        if (num_values > 1) {
                fprintf(file, "]");
        }
        return true;
}

static void _doc_print_object(FILE *file, const doc_obj *model)
{
        fprintf(file, "{");
        for (size_t i = 0; i < model->entries.num_elems; i++) {
                doc_entries *entry = VEC_GET(&model->entries, i, doc_entries);
                fprintf(file, "\"%s\": ", entry->key);
                print_value(file, entry->type, &entry->values);
                fprintf(file, "%s", i + 1 < model->entries.num_elems ? ", " : "");
        }
        fprintf(file, "}");
}

/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/vec.h>
#include <karbonit/archive/encode_sync.h>
#include <karbonit/archive/encode_async.h>
#include <karbonit/std/spinlock.h>
#include <karbonit/std/str_hash.h>
#include <karbonit/utils/time.h>
#include <karbonit/std/async.h>
#include <karbonit/stdx/slicelist.h>
#include <karbonit/std/hash.h>

#define STRING_DIC_ASYNC_TAG "string_dict_async"

#define HASH_FUNCTION                  HASH_SAX

struct carrier {
        string_dict local_dictionary;
        pthread_t thread;
        size_t id;
};

struct async_extra {
        vec ofType(carrier) carriers;
        vec ofType(struct carrier *) carrier_mapping;
        spinlock lock;
};

struct parallel_insert_arg {
        vec ofType(char *) strings;
        archive_field_sid_t *out;
        struct carrier *carrier;
        bool enable_write_out;
        bool did_work;
        uint_fast16_t insert_num_threads;
};

struct parallel_remove_arg {
        vec ofType(archive_field_sid_t) *local_ids;
        struct carrier *carrier;
        int result;
        bool did_work;
};

struct parallel_locate_arg {
        struct carrier *carrier;
        archive_field_sid_t *ids_out;
        bool *found_mask_out;
        size_t num_not_found_out;
        vec ofType(char *) keys_in;
        int result;
        bool did_work;
};

struct parallel_extract_arg {
        vec ofType(archive_field_sid_t) local_ids_in;
        char **strings_out;
        struct carrier *carrier;
        bool did_work;
};

#define _ENCODE_ASYNC_HASHCODE_OF(string)                                                                                            \
    HASH_FUNCTION(strlen(string), string)

#define MAKE_GLOBAL(thread_id, localstring_id_t)                                                                \
    ((thread_id << 54) | localstring_id_t)

#define GET_OWNER(globalId)                                                                                            \
    (globalId >> 54)

#define GET_string_id_t(globalId)                                                                               \
    ((~((archive_field_sid_t) 0)) >> 10 & global_string_id);

static bool _encode_async_drop(string_dict *self);

static bool
_encode_async_insert(string_dict *self, archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t __num_threads);

static bool _encode_async_remove(string_dict *self, archive_field_sid_t *strings, size_t num_strings);

static bool
_encode_async_locate_safe(string_dict *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys);

static bool
_encode_async_locate_fast(string_dict *self, archive_field_sid_t **out, char *const *keys, size_t num_keys);

static char **_encode_async_locate_extract(string_dict *self, const archive_field_sid_t *ids, size_t num_ids);

static bool _encode_async_free(string_dict *self, void *ptr);

static bool _encode_async_num_distinct(string_dict *self, size_t *num);

static bool _encode_async_get_contents(string_dict *self, vec ofType (char *) *strings,
                              vec ofType(archive_field_sid_t) *string_ids);

static bool _encode_async_reset_counters(string_dict *self);

static bool _encode_async_counters(string_dict *self, str_hash_counters *counters);

static bool this_lock(string_dict *self);

static bool this_unlock(string_dict *self);

static bool _encode_async_create_extra(string_dict *self, size_t capacity, size_t num_index_buckets,
                              size_t approx_num_unique_str, size_t num_threads);

static bool this_setup_carriers(string_dict *self, size_t capacity, size_t num_index_buckets,
                                size_t approx_num_unique_str, size_t num_threads);

#define THIS_EXTRAS(self)                                                                                              \
({                                                                                                                     \
    (struct async_extra *) self->extra;                                                                                       \
})

int encode_async_create(string_dict *dic, size_t capacity, size_t num_index_buckets,
                        size_t approx_num_unique_strs, size_t num_threads)
{
        dic->tag = ASYNC;
        dic->drop = _encode_async_drop;
        dic->insert = _encode_async_insert;
        dic->remove = _encode_async_remove;
        dic->locate_safe = _encode_async_locate_safe;
        dic->locate_fast = _encode_async_locate_fast;
        dic->extract = _encode_async_locate_extract;
        dic->free = _encode_async_free;
        dic->resetCounters = _encode_async_reset_counters;
        dic->counters = _encode_async_counters;
        dic->num_distinct = _encode_async_num_distinct;
        dic->get_contents = _encode_async_get_contents;

        CHECK_SUCCESS(_encode_async_create_extra(dic, capacity, num_index_buckets, approx_num_unique_strs, num_threads));
        return true;
}

static bool _encode_async_create_extra(string_dict *self, size_t capacity, size_t num_index_buckets,
                              size_t approx_num_unique_str, size_t num_threads)
{
        assert(self);

        self->extra = MALLOC(sizeof(struct async_extra));
        struct async_extra *extra = THIS_EXTRAS(self);
        spinlock_init(&extra->lock);
        vec_create(&extra->carriers, sizeof(struct carrier), num_threads);
        this_setup_carriers(self, capacity, num_index_buckets, approx_num_unique_str, num_threads);
        vec_create(&extra->carrier_mapping, sizeof(struct carrier *), capacity);

        return true;
}

static bool _encode_async_drop(string_dict *self)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        for (size_t i = 0; i < extra->carriers.num_elems; i++) {
                struct carrier *carrier = VEC_GET(&extra->carriers, i, struct carrier);
                string_dict_drop(&carrier->local_dictionary);
        }
        CHECK_SUCCESS(vec_drop(&extra->carriers));
        CHECK_SUCCESS(vec_drop(&extra->carrier_mapping));
        free(extra);
        return true;
}

void *parallel_remove_function(void *args)
{
        struct parallel_remove_arg *carrier_arg = (struct parallel_remove_arg *) args;
        archive_field_sid_t len = VEC_LENGTH(carrier_arg->local_ids);
        carrier_arg->did_work = len > 0;

        DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for remove task (%zu elements)",
                  carrier_arg->carrier->id,
                  VEC_LENGTH(carrier_arg->local_ids));
        if (len > 0) {
                string_dict *dic = &carrier_arg->carrier->local_dictionary;
                archive_field_sid_t *ids = VEC_ALL(carrier_arg->local_ids, archive_field_sid_t);
                carrier_arg->result = string_dict_remove(dic, ids, len);
                DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu task done", carrier_arg->carrier->id);
        } else {
                carrier_arg->result = true;
                WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", carrier_arg->carrier->id);
        }

        return NULL;
}

void *parallel_insert_function(void *args)
{
        struct parallel_insert_arg *restrict this_args = (struct parallel_insert_arg *restrict) args;
        this_args->did_work = this_args->strings.num_elems > 0;

        TRACE(STRING_DIC_ASYNC_TAG, "thread-local insert function started (thread %zu)", this_args->carrier->id);
        DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for insert task (%zu elements)",
                  this_args->carrier->id,
                  VEC_LENGTH(&this_args->strings));

        if (this_args->did_work) {
                TRACE(STRING_DIC_ASYNC_TAG,
                          "thread %zu starts insertion of %zu strings",
                          this_args->carrier->id,
                          VEC_LENGTH(&this_args->strings));
                char **data = (char **) vec_data(&this_args->strings);

                int status = string_dict_insert(&this_args->carrier->local_dictionary,
                                           this_args->enable_write_out ? &this_args->out : NULL,
                                           data,
                                           VEC_LENGTH(&this_args->strings),
                                           this_args->insert_num_threads);

                /** internal ERROR during thread-local string dictionary building process */
                ERROR_IF_AND_RETURN(status != true, ERR_INTERNALERR, NULL);
                DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu done", this_args->carrier->id);
        } else {
                WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", this_args->carrier->id);
        }

        return NULL;
}

void *parallel_locate_safe_function(void *args)
{
        struct parallel_locate_arg *restrict this_args = (struct parallel_locate_arg *restrict) args;
        this_args->did_work = VEC_LENGTH(&this_args->keys_in) > 0;

        TRACE(STRING_DIC_ASYNC_TAG,
                  "thread-local 'locate' function invoked for thread %zu...",
                  this_args->carrier->id)

        DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for locate (safe) task (%zu elements)",
                  this_args->carrier->id,
                  VEC_LENGTH(&this_args->keys_in));

        if (this_args->did_work) {
                this_args->result = string_dict_locate_safe(&this_args->ids_out,
                                                       &this_args->found_mask_out,
                                                       &this_args->num_not_found_out,
                                                       &this_args->carrier->local_dictionary,
                                                       VEC_ALL(&this_args->keys_in, char *),
                                                       VEC_LENGTH(&this_args->keys_in));

                DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu done", this_args->carrier->id);
        } else {
                WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", this_args->carrier->id);
        }

        return NULL;
}

void *parallel_extract_function(void *args)
{
        struct parallel_extract_arg *restrict this_args = (struct parallel_extract_arg *restrict) args;
        this_args->did_work = VEC_LENGTH(&this_args->local_ids_in) > 0;

        DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for extract task (%zu elements)",
                  this_args->carrier->id,
                  VEC_LENGTH(&this_args->local_ids_in));

        if (this_args->did_work) {
                this_args->strings_out = string_dict_extract(&this_args->carrier->local_dictionary,
                                                        VEC_ALL(&this_args->local_ids_in, archive_field_sid_t),
                                                        VEC_LENGTH(&this_args->local_ids_in));
                DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu done", this_args->carrier->id);
        } else {
                WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", this_args->carrier->id);
        }

        return NULL;
}

static void synchronize(vec ofType(carrier) *carriers, size_t num_threads)
{
        DEBUG(STRING_DIC_ASYNC_TAG, "barrier installed for %d threads", num_threads);

        timestamp begin = wallclock();
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                volatile struct carrier *carrier = VEC_GET(carriers, thread_id, struct carrier);
                pthread_join(carrier->thread, NULL);
                DEBUG(STRING_DIC_ASYNC_TAG, "thread %d joined", carrier->id);
        }
        timestamp end = wallclock();
        timestamp duration = (end - begin);
        UNUSED(duration);

        DEBUG(STRING_DIC_ASYNC_TAG,
                  "barrier passed for %d threads after %f seconds",
                  num_threads,
                  duration / 1000.0f);
}

static void create_thread_assignment(atomic_uint_fast16_t **str_carrier_mapping, atomic_size_t **carrier_num_strings,
                                     size_t **str_carrier_idx_mapping, size_t num_strings,
                                     size_t num_threads)
{
        /** async_map_exec string depending on hash values to a particular carrier */
        *str_carrier_mapping = MALLOC(num_strings * sizeof(atomic_uint_fast16_t));
        memset(*str_carrier_mapping, 0, num_strings * sizeof(atomic_uint_fast16_t));

        /** counters to compute how many strings go to a particular carrier */
        *carrier_num_strings = MALLOC(num_threads * sizeof(atomic_size_t));
        memset(*carrier_num_strings, 0, num_threads * sizeof(atomic_size_t));

        /** an inverted index that contains the i-th position for string k that was assigned to carrier m.
         * With this, given a (global) string and and its carrier, one can have directly the position of the
         * string in the carriers "thread-local locate" args */
        *str_carrier_idx_mapping = MALLOC(num_strings * sizeof(size_t));
}

static void drop_thread_assignment(atomic_uint_fast16_t *str_carrier_mapping,
                                   atomic_size_t *carrier_num_strings, size_t *str_carrier_idx_mapping)
{
        free(carrier_num_strings);
        free(str_carrier_mapping);
        free(str_carrier_idx_mapping);
}

struct thread_assign_arg {
        atomic_uint_fast16_t *str_carrier_mapping;
        size_t num_threads;
        atomic_size_t *carrier_num_strings;
        char *const *base_strings;
};

static void parallel_compute_thread_assignment_function(const void *restrict start, size_t width, size_t len,
                                                        void *restrict args, thread_id_t tid)
{
        UNUSED(tid);
        UNUSED(width);

        char *const *strings = (char *const *) start;

        struct thread_assign_arg *func_args = (struct thread_assign_arg *) args;

        while (len--) {
                size_t i = strings - func_args->base_strings;
                const char *key = *strings;
                /** re-using this hashcode for the thread-local dictionary is more costly than to compute it fresh
                 * (due to more I/O with the RAM) */
                size_t thread_id = _ENCODE_ASYNC_HASHCODE_OF(key) % func_args->num_threads;
                atomic_fetch_add(&func_args->str_carrier_mapping[i], thread_id);
                atomic_fetch_add(&func_args->carrier_num_strings[thread_id], 1);
                strings++;
        }
}

static void compute_thread_assignment(atomic_uint_fast16_t *str_carrier_mapping, atomic_size_t *carrier_num_strings,
                                      char *const *strings, size_t num_strings, size_t num_threads)
{
        struct thread_assign_arg args =
                {.base_strings = strings, .carrier_num_strings = carrier_num_strings, .num_threads = num_threads, .str_carrier_mapping = str_carrier_mapping};
        foreach(strings,
                sizeof(char *const *),
                num_strings,
                parallel_compute_thread_assignment_function,
                &args,
                THREADING_HINT_MULTI,
                num_threads);

}

static bool
_encode_async_insert(string_dict *self, archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t __num_threads)
{
        timestamp begin = wallclock();
        INFO(STRING_DIC_ASYNC_TAG, "insert operation invoked: %zu strings in total", num_strings)

        /** parameter 'num_threads' must be set to 0 for async dictionary */
        ERROR_IF_AND_RETURN(__num_threads != 0, ERR_INTERNALERR, NULL);

        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        uint_fast16_t num_threads = VEC_LENGTH(&extra->carriers);

        atomic_uint_fast16_t *str_carrier_mapping;
        size_t *str_carrier_idx_mapping;
        atomic_size_t *carrier_num_strings;

        create_thread_assignment(&str_carrier_mapping,
                                 &carrier_num_strings,
                                 &str_carrier_idx_mapping,
                                 num_strings,
                                 num_threads);

        vec ofType(struct parallel_insert_arg *) carrier_args;
        vec_create(&carrier_args, sizeof(struct parallel_insert_arg *), num_threads);

        /** compute which carrier is responsible for which string */
        compute_thread_assignment(str_carrier_mapping, carrier_num_strings, strings, num_strings, num_threads);

        /** prepare to move string subsets to carriers */
        for (uint_fast16_t i = 0; i < num_threads; i++) {
                struct parallel_insert_arg *entry = MALLOC(sizeof(struct parallel_insert_arg));
                entry->carrier = VEC_GET(&extra->carriers, i, struct carrier);
                entry->insert_num_threads = num_threads;

                vec_create(&entry->strings, sizeof(char *), JAK_MAX(1, carrier_num_strings[i]));
                vec_push(&carrier_args, &entry, 1);
                assert (entry->strings.base != NULL);

                struct parallel_insert_arg *carrier_arg = *VEC_GET(&carrier_args, i, struct parallel_insert_arg *);
                carrier_arg->out = NULL;
        }

        /** create per-carrier string subset */
        /** parallizing this makes no sense but waste of resources and energy */
        for (size_t i = 0; i < num_strings; i++) {
                uint_fast16_t thread_id = str_carrier_mapping[i];
                struct parallel_insert_arg
                        *carrier_arg = *VEC_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                carrier_arg->enable_write_out = out != NULL;

                /** store local index of string i inside the thread */
                str_carrier_idx_mapping[i] = VEC_LENGTH(&carrier_arg->strings);

                vec_push(&carrier_arg->strings, &strings[i], 1);
        }


        /** schedule insert operation per carrier */
        TRACE(STRING_DIC_ASYNC_TAG, "schedule insert operation to %zu threads", num_threads)
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_insert_arg
                        *carrier_arg = *VEC_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);
                TRACE(STRING_DIC_ASYNC_TAG, "create thread %zu...", thread_id)
                pthread_create(&carrier->thread, NULL, parallel_insert_function, carrier_arg);
                TRACE(STRING_DIC_ASYNC_TAG, "thread %zu created", thread_id)
        }
        TRACE(STRING_DIC_ASYNC_TAG, "scheduling done for %zu threads", num_threads)

        /** synchronize */
        TRACE(STRING_DIC_ASYNC_TAG, "start synchronizing %zu threads", num_threads)
        synchronize(&extra->carriers, num_threads);
        TRACE(STRING_DIC_ASYNC_TAG, "%zu threads in sync", num_threads)

        /** compute string ids; the string id produced by this implementation is a compound identifier encoding
         * both the owning thread id and the thread-local string id. For this, the returned (global) string identifier
         * is split into 10bits encoded the thread (given a maximum of 1024 threads that can be handled by this
         * implementation), and 54bits used to encode the thread-local string id
         *
         * TECHNICAL LIMIT: 1024 threads
         */

        /** optionally, return the created string ids. In case 'out' is NULL, nothing has to be done (especially
         * none of the carrier threads allocated thread-local 'out's which mean that no cleanup must be done */

        /** parallelizing the following block makes no sense but waste of compute power and energy */
        if (LIKELY(out != NULL)) {
                archive_field_sid_t *total_out = MALLOC(num_strings * sizeof(archive_field_sid_t));
                size_t currentOut = 0;

                for (size_t string_idx = 0; string_idx < num_strings; string_idx++) {
                        uint_fast16_t thread_id = str_carrier_mapping[string_idx];
                        size_t localIdx = str_carrier_idx_mapping[string_idx];
                        struct parallel_insert_arg
                                *carrier_arg = *VEC_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                        archive_field_sid_t global_string_owner_id = thread_id;
                        archive_field_sid_t global_string_local_id = carrier_arg->out[localIdx];
                        archive_field_sid_t global_string_id = MAKE_GLOBAL(global_string_owner_id,
                                                                               global_string_local_id);
                        total_out[currentOut++] = global_string_id;
                }

                *out = total_out;
        }

        /** cleanup */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_insert_arg
                        *carrier_arg = *VEC_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                if (carrier_arg->did_work) {
                        string_dict_free(&carrier_arg->carrier->local_dictionary, carrier_arg->out);
                }
                vec_drop(&carrier_arg->strings);
                free(carrier_arg);
        }

        /** cleanup */
        drop_thread_assignment(str_carrier_mapping, carrier_num_strings, str_carrier_idx_mapping);
        vec_drop(&carrier_args);

        this_unlock(self);

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        INFO(STRING_DIC_ASYNC_TAG, "insertion operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static bool _encode_async_remove(string_dict *self, archive_field_sid_t *strings, size_t num_strings)
{
        timestamp begin = wallclock();
        INFO(STRING_DIC_ASYNC_TAG, "remove operation started: %zu strings to remove", num_strings);

        this_lock(self);

        struct parallel_remove_arg empty;
        struct async_extra *extra = THIS_EXTRAS(self);
        uint_fast16_t num_threads = VEC_LENGTH(&extra->carriers);
        size_t approx_num_strings_per_thread = JAK_MAX(1, num_strings / num_threads);
        vec ofType(archive_field_sid_t) *string_map = MALLOC(num_threads * sizeof(vec));

        vec ofType(struct parallel_remove_arg) carrier_args;
        vec_create(&carrier_args, sizeof(struct parallel_remove_arg), num_threads);

        /** prepare thread-local subset of string ids */
        vec_repeated_push(&carrier_args, &empty, num_threads);
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                vec_create(string_map + thread_id, sizeof(archive_field_sid_t), approx_num_strings_per_thread);
        }

        /** compute subset of string ids per thread  */
        for (size_t i = 0; i < num_strings; i++) {
                archive_field_sid_t global_string_id = strings[i];
                uint_fast16_t owning_thread_id = GET_OWNER(global_string_id);
                archive_field_sid_t localstring_id_t = GET_string_id_t(global_string_id);
                assert(owning_thread_id < num_threads);

                vec_push(string_map + owning_thread_id, &localstring_id_t, 1);
        }

        /** schedule remove operation per carrier */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);
                struct parallel_remove_arg *carrier_arg = VEC_GET(&carrier_args, thread_id, struct parallel_remove_arg);
                carrier_arg->carrier = carrier;
                carrier_arg->local_ids = string_map + thread_id;

                pthread_create(&carrier->thread, NULL, parallel_remove_function, carrier_arg);
        }

        /** synchronize */
        synchronize(&extra->carriers, num_threads);

        /** cleanup */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                vec_drop(string_map + thread_id);
        }

        free(string_map);
        vec_data(&carrier_args);

        this_unlock(self);

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        INFO(STRING_DIC_ASYNC_TAG, "remove operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static bool
_encode_async_locate_safe(string_dict *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys)
{
        timestamp begin = wallclock();
        INFO(STRING_DIC_ASYNC_TAG, "locate (safe) operation started: %zu strings to locate", num_keys)

        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        uint_fast16_t num_threads = VEC_LENGTH(&extra->carriers);

        /** global result output */
        archive_field_sid_t *global_out = MALLOC(num_keys * sizeof(archive_field_sid_t));
        bool *global_found_mask = MALLOC(num_keys * sizeof(bool));

        size_t global_num_not_found = 0;

        atomic_uint_fast16_t *str_carrier_mapping;
        size_t *str_carrier_idx_mapping;
        atomic_size_t *carrier_num_strings;

        struct parallel_locate_arg carrier_args[num_threads];

        create_thread_assignment(&str_carrier_mapping,
                                 &carrier_num_strings,
                                 &str_carrier_idx_mapping,
                                 num_keys,
                                 num_threads);

        /** compute which carrier is responsible for which string */
        compute_thread_assignment(str_carrier_mapping, carrier_num_strings, keys, num_keys, num_threads);

        /** prepare to move string subsets to carriers */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                vec_create(&arg->keys_in, sizeof(char *), carrier_num_strings[thread_id]);
                assert (&arg->keys_in.base != NULL);
        }

        TRACE(STRING_DIC_ASYNC_TAG, "computing per-thread str_buf subset for %zu strings", num_keys)
        /** create per-carrier string subset */
        for (size_t i = 0; i < num_keys; i++) {
                /** get thread responsible for this particular string */
                uint_fast16_t thread_id = str_carrier_mapping[i];

                /** get the thread-local argument list for the thread that is responsible for this particular string */
                struct parallel_locate_arg *arg = carrier_args + thread_id;

                /** store local index of string i inside the thread */
                str_carrier_idx_mapping[i] = VEC_LENGTH(&arg->keys_in);

                /** push that string into the thread-local vec */
                vec_push(&arg->keys_in, &keys[i], 1);
        }

        TRACE(STRING_DIC_ASYNC_TAG, "schedule operation to threads to %zu threads...", num_threads)
        /** schedule operation to threads */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                carrier_args[thread_id].carrier = carrier;
                pthread_create(&carrier->thread, NULL, parallel_locate_safe_function, arg);
        }

        /** synchronize */
        TRACE(STRING_DIC_ASYNC_TAG, "start syncing %zu threads...", num_threads)
        synchronize(&extra->carriers, num_threads);
        TRACE(STRING_DIC_ASYNC_TAG, "%zu threads in sync.", num_threads)

        /** collect and merge results */
        TRACE(STRING_DIC_ASYNC_TAG, "merging results of %zu threads", num_threads)
        for (size_t i = 0; i < num_keys; i++) {
                /** get thread responsible for this particular string, and local position of that string inside the
                 * thread storage */
                uint_fast16_t thread_id = str_carrier_mapping[i];
                size_t local_thread_idx = str_carrier_idx_mapping[i];

                /** get the thread-local argument list for the thread that is responsible for this particular string */
                struct parallel_locate_arg *arg = carrier_args + thread_id;

                /** merge into global result */
                archive_field_sid_t string_id_owner = thread_id;
                archive_field_sid_t string_id_local_idx = arg->ids_out[local_thread_idx];
                archive_field_sid_t global_string_id = MAKE_GLOBAL(string_id_owner, string_id_local_idx);
                global_out[i] = global_string_id;
                global_found_mask[i] = arg->found_mask_out[local_thread_idx];
        }
        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                /** compute total number of not-found elements */
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                global_num_not_found += arg->num_not_found_out;

                /** cleanup */
                if (LIKELY(arg->did_work)) {
                        string_dict_free(&arg->carrier->local_dictionary, arg->found_mask_out);
                        string_dict_free(&arg->carrier->local_dictionary, arg->ids_out);
                }
        }

        TRACE(STRING_DIC_ASYNC_TAG, "cleanup%s", "...")

        /** cleanup */
        drop_thread_assignment(str_carrier_mapping, carrier_num_strings, str_carrier_idx_mapping);

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                vec_drop(&arg->keys_in);
        }

        /** return results */
        *out = global_out;
        *found_mask = global_found_mask;
        *num_not_found = global_num_not_found;

        this_unlock(self);

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        INFO(STRING_DIC_ASYNC_TAG, "locate (safe) operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static bool
_encode_async_locate_fast(string_dict *self, archive_field_sid_t **out, char *const *keys, size_t num_keys)
{
        this_lock(self);

        bool *found_mask;
        size_t num_not_found;
        int result;

        /** use safer but in principle more slower implementation */
        result = _encode_async_locate_safe(self, out, &found_mask, &num_not_found, keys, num_keys);

        /** cleanup */
        _encode_async_free(self, found_mask);

        this_unlock(self);

        return result;
}

static char **_encode_async_locate_extract(string_dict *self, const archive_field_sid_t *ids, size_t num_ids)
{
        timestamp begin = wallclock();
        INFO(STRING_DIC_ASYNC_TAG, "extract (safe) operation started: %zu strings to extract", num_ids)

        if (self->tag != ASYNC) {
                return NULL;
        }

        this_lock(self);

        char **globalResult = MALLOC(num_ids * sizeof(char *));

        struct async_extra *extra = (struct async_extra *) self->extra;
        uint_fast16_t num_threads = VEC_LENGTH(&extra->carriers);
        size_t approx_num_strings_per_thread = JAK_MAX(1, num_ids / num_threads);

        size_t *local_thread_idx = MALLOC(num_ids * sizeof(size_t));
        uint_fast16_t *owning_thread_ids = MALLOC(num_ids * sizeof(uint_fast16_t));
        struct parallel_extract_arg *thread_args = MALLOC(num_threads * sizeof(struct parallel_extract_arg));

        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_extract_arg *arg = thread_args + thread_id;
                vec_create(&arg->local_ids_in, sizeof(archive_field_sid_t), approx_num_strings_per_thread);
        }

        /** compute subset of string ids per thread  */
        for (size_t i = 0; i < num_ids; i++) {
                archive_field_sid_t global_string_id = ids[i];
                owning_thread_ids[i] = GET_OWNER(global_string_id);
                archive_field_sid_t localstring_id_t = GET_string_id_t(global_string_id);
                assert(owning_thread_ids[i] < num_threads);

                struct parallel_extract_arg *arg = thread_args + owning_thread_ids[i];
                local_thread_idx[i] = VEC_LENGTH(&arg->local_ids_in);
                vec_push(&arg->local_ids_in, &localstring_id_t, 1);
        }

        /** schedule remove operation per carrier */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);
                struct parallel_extract_arg *carrier_arg = thread_args + thread_id;
                carrier_arg->carrier = carrier;
                pthread_create(&carrier->thread, NULL, parallel_extract_function, carrier_arg);
        }

        /** synchronize */
        synchronize(&extra->carriers, num_threads);

        for (size_t i = 0; i < num_ids; i++) {
                uint_fast16_t owning_thread_id = owning_thread_ids[i];
                size_t localIdx = local_thread_idx[i];
                struct parallel_extract_arg *carrier_arg = thread_args + owning_thread_id;
                char *extractedString = carrier_arg->strings_out[localIdx];
                globalResult[i] = extractedString;
        }

        /** cleanup */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_extract_arg *carrier_arg = thread_args + thread_id;
                vec_drop(&carrier_arg->local_ids_in);
                if (LIKELY(carrier_arg->did_work)) {
                        string_dict_free(&carrier_arg->carrier->local_dictionary, carrier_arg->strings_out);
                }
        }

        free(local_thread_idx);
        free(owning_thread_ids);
        free(thread_args);

        this_unlock(self);

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        INFO(STRING_DIC_ASYNC_TAG, "extract (safe) operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return globalResult;
}

static bool _encode_async_free(string_dict *self, void *ptr)
{
        UNUSED(self)
        free(ptr);
        return true;
}

static bool _encode_async_num_distinct(string_dict *self, size_t *num)
{
        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_carriers = VEC_LENGTH(&extra->carriers);
        struct carrier *carriers = VEC_ALL(&extra->carriers, struct carrier);
        size_t num_distinct = 0;
        while (num_carriers--) {
                size_t local_distinct;
                string_dict_num_distinct(&local_distinct, &carriers->local_dictionary);
                num_distinct += local_distinct;
                carriers++;
        }
        *num = num_distinct;
        this_unlock(self);
        return true;
}

static bool _encode_async_get_contents(string_dict *self, vec ofType (char *) *strings,
                              vec ofType(archive_field_sid_t) *string_ids)
{
        this_lock(self);
        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_carriers = VEC_LENGTH(&extra->carriers);
        vec ofType (char *) local_string_results;
        vec ofType (archive_field_sid_t) local_string_id_results;
        size_t approx_num_distinct_local_values;
        _encode_async_num_distinct(self, &approx_num_distinct_local_values);
        approx_num_distinct_local_values = JAK_MAX(1, approx_num_distinct_local_values / extra->carriers.num_elems);
        approx_num_distinct_local_values *= 1.2f;

        vec_create(&local_string_results, sizeof(char *), approx_num_distinct_local_values);
        vec_create(&local_string_id_results, sizeof(archive_field_sid_t), approx_num_distinct_local_values);

        for (size_t thread_id = 0; thread_id < num_carriers; thread_id++) {
                vec_clear(&local_string_results);
                vec_clear(&local_string_id_results);

                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);

                string_dict_get_contents(&local_string_results, &local_string_id_results, &carrier->local_dictionary);

                assert(local_string_id_results.num_elems == local_string_results.num_elems);
                for (size_t k = 0; k < local_string_results.num_elems; k++) {
                        char *string = *VEC_GET(&local_string_results, k, char *);
                        archive_field_sid_t localstring_id_t = *VEC_GET(&local_string_id_results, k,
                                                                            archive_field_sid_t);
                        archive_field_sid_t global_string_id = MAKE_GLOBAL(thread_id, localstring_id_t);
                        vec_push(strings, &string, 1);
                        vec_push(string_ids, &global_string_id, 1);
                }
        }

        vec_drop(&local_string_results);
        vec_drop(&local_string_id_results);
        this_unlock(self);
        return true;
}

static bool _encode_async_reset_counters(string_dict *self)
{
        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_threads = VEC_LENGTH(&extra->carriers);

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);
                string_dict_reset_counters(&carrier->local_dictionary);
        }

        this_unlock(self);

        return true;
}

static bool _encode_async_counters(string_dict *self, str_hash_counters *counters)
{
        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_threads = VEC_LENGTH(&extra->carriers);

        CHECK_SUCCESS(str_hash_counters_init(counters));

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = VEC_GET(&extra->carriers, thread_id, struct carrier);
                str_hash_counters local_counters;
                string_dict_get_counters(&local_counters, &carrier->local_dictionary);
                str_hash_counters_add(counters, &local_counters);
        }

        this_unlock(self);

        return true;
}

struct create_carrier_arg {
        size_t local_capacity;
        size_t local_bucket_num;
        size_t local_bucket_cap;
        const allocator *alloc;
};

static void parallel_create_carrier(const void *restrict start, size_t width, size_t len, void *restrict args,
                                    thread_id_t tid)
{
        UNUSED(tid);
        UNUSED(width);

        struct carrier *carrier = (struct carrier *) start;
        const struct create_carrier_arg *createArgs = (const struct create_carrier_arg *) args;
        while (len--) {
                encode_sync_create(&carrier->local_dictionary,
                                   createArgs->local_capacity,
                                   createArgs->local_bucket_num,
                                   createArgs->local_bucket_cap,
                                   0);
                memset(&carrier->thread, 0, sizeof(pthread_t));
                carrier++;
        }
}

static bool this_setup_carriers(string_dict *self, size_t capacity, size_t num_index_buckets,
                                size_t approx_num_unique_str, size_t num_threads)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        size_t local_bucket_num = JAK_MAX(1, num_index_buckets / num_threads);
        struct carrier new_carrier;

        struct create_carrier_arg createArgs = {.local_capacity = JAK_MAX(1,
                                                                          capacity /
                                                                          num_threads), .local_bucket_num = local_bucket_num, .local_bucket_cap = JAK_MAX(
                1,
                approx_num_unique_str / num_threads / local_bucket_num / SLICE_KEY_COLUMN_MAX_ELEMS)
        };

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                new_carrier.id = thread_id;
                vec_push(&extra->carriers, &new_carrier, 1);
        }

        foreach(VEC_ALL(&extra->carriers, struct carrier),
                sizeof(struct carrier),
                num_threads,
                parallel_create_carrier,
                &createArgs,
                THREADING_HINT_MULTI,
                num_threads);

        return true;
}

static bool this_lock(string_dict *self)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        CHECK_SUCCESS(spinlock_acquire(&extra->lock));
        return true;
}

static bool this_unlock(string_dict *self)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        CHECK_SUCCESS(spinlock_release(&extra->lock));
        return true;
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/vec.h>
#include <karbonit/std/spinlock.h>
#include <karbonit/std/str_hash.h>
#include <karbonit/archive/encode_sync.h>
#include <karbonit/std/str_hash/mem.h>
#include <karbonit/utils/time.h>
#include <karbonit/std/bloom.h>
#include <karbonit/std/hash.h>

#define STRING_DIC_SYNC_TAG "string-dic-sync"

struct entry {
        char *str;
        bool in_use;
};

struct sync_extra {
        vec ofType(entry) contents;
        vec ofType(string_id_t_t) freelist;
        str_hash index;
        spinlock _encode_sync_lock;
};

static bool _encode_sync_drop(string_dict *self);

static bool
_encode_sync_insert(string_dict *self, archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t num_threads);

static bool _encode_sync_remove(string_dict *self, archive_field_sid_t *strings, size_t num_strings);

static bool
_encode_sync_locate_safe(string_dict *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys);

static bool
_encode_sync_locate_fast(string_dict *self, archive_field_sid_t **out, char *const *keys, size_t num_keys);

static char **_encode_sync_extract(string_dict *self, const archive_field_sid_t *ids, size_t num_ids);

static bool _encode_sync_free(string_dict *self, void *ptr);

static bool _encode_sync_reset_counters(string_dict *self);

static bool _encode_sync_counters(string_dict *self, str_hash_counters *counters);

static bool _encode_sync_num_distinct(string_dict *self, size_t *num);

static bool _encode_sync_get_contents(string_dict *self, vec ofType (char *) *strings,
                              vec ofType(archive_field_sid_t) *string_ids);

static void _encode_sync_lock(string_dict *self);

static void _encode_sync_unlock(string_dict *self);

static int
create_extra(string_dict *self, size_t capacity, size_t num_index_buckets, size_t num_index_bucket_cap,
             size_t num_threads);

static struct sync_extra *this_extra(string_dict *self);

static int freelist_pop(archive_field_sid_t *out, string_dict *self);

static int freelist_push(string_dict *self, archive_field_sid_t idx);

int
encode_sync_create(string_dict *dic, size_t capacity, size_t num_indx_buckets, size_t num_index_bucket_cap,
                   size_t num_threads)
{
        dic->tag = SYNC;
        dic->drop = _encode_sync_drop;
        dic->insert = _encode_sync_insert;
        dic->remove = _encode_sync_remove;
        dic->locate_safe = _encode_sync_locate_safe;
        dic->locate_fast = _encode_sync_locate_fast;
        dic->extract = _encode_sync_extract;
        dic->free = _encode_sync_free;
        dic->resetCounters = _encode_sync_reset_counters;
        dic->counters = _encode_sync_counters;
        dic->num_distinct = _encode_sync_num_distinct;
        dic->get_contents = _encode_sync_get_contents;

        CHECK_SUCCESS(create_extra(dic, capacity, num_indx_buckets, num_index_bucket_cap, num_threads));
        return true;
}

static void _encode_sync_lock(string_dict *self)
{
        assert(self->tag == SYNC);
        struct sync_extra *extra = this_extra(self);
        spinlock_acquire(&extra->_encode_sync_lock);
}

static void _encode_sync_unlock(string_dict *self)
{
        assert(self->tag == SYNC);
        struct sync_extra *extra = this_extra(self);
        spinlock_release(&extra->_encode_sync_lock);
}

static int
create_extra(string_dict *self, size_t capacity, size_t num_index_buckets, size_t num_index_bucket_cap,
             size_t num_threads)
{
        self->extra = MALLOC(sizeof(struct sync_extra));
        struct sync_extra *extra = this_extra(self);
        spinlock_init(&extra->_encode_sync_lock);
        CHECK_SUCCESS(vec_create(&extra->contents, sizeof(struct entry), capacity));
        CHECK_SUCCESS(vec_create(&extra->freelist, sizeof(archive_field_sid_t), capacity));
        struct entry empty = {.str    = NULL, .in_use = false};
        for (size_t i = 0; i < capacity; i++) {
                CHECK_SUCCESS(vec_push(&extra->contents, &empty, 1));
                freelist_push(self, i);
        }
        UNUSED(num_threads);

        CHECK_SUCCESS(str_hash_create_inmemory(&extra->index,
                                                  num_index_buckets,
                                                  num_index_bucket_cap));
        return true;
}

static struct sync_extra *this_extra(string_dict *self)
{
        assert (self->tag == SYNC);
        return (struct sync_extra *) self->extra;
}

static int freelist_pop(archive_field_sid_t *out, string_dict *self)
{
        assert (self->tag == SYNC);
        struct sync_extra *extra = this_extra(self);
        if (UNLIKELY(vec_is_empty(&extra->freelist))) {
                size_t num_new_pos;
                CHECK_SUCCESS(vec_grow(&num_new_pos, &extra->freelist));
                CHECK_SUCCESS(vec_grow(NULL, &extra->contents));
                assert (extra->freelist.cap_elems == extra->contents.cap_elems);
                struct entry empty = {.in_use = false, .str    = NULL};
                while (num_new_pos--) {
                        size_t new_pos = VEC_LENGTH(&extra->contents);
                        CHECK_SUCCESS(vec_push(&extra->freelist, &new_pos, 1));
                        CHECK_SUCCESS(vec_push(&extra->contents, &empty, 1));
                }
        }
        *out = *(archive_field_sid_t *) vec_pop(&extra->freelist);
        return true;
}

static int freelist_push(string_dict *self, archive_field_sid_t idx)
{
        assert (self->tag == SYNC);
        struct sync_extra *extra = this_extra(self);
        CHECK_SUCCESS(vec_push(&extra->freelist, &idx, 1));
        assert (extra->freelist.cap_elems == extra->contents.cap_elems);
        return true;
}

static bool _encode_sync_drop(string_dict *self)
{
        struct sync_extra *extra = this_extra(self);

        struct entry *entries = (struct entry *) extra->contents.base;
        for (size_t i = 0; i < extra->contents.num_elems; i++) {
                struct entry *entry = entries + i;
                if (entry->in_use) {
                        assert (entry->str);
                        free(entry->str);
                        entry->str = NULL;
                }
        }

        vec_drop(&extra->freelist);
        vec_drop(&extra->contents);
        str_hash_drop(&extra->index);
        free(self->extra);

        return true;
}

static bool
_encode_sync_insert(string_dict *self, archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t num_threads)
{
        TRACE(STRING_DIC_SYNC_TAG, "local str_buf dictionary insertion invoked for %zu strings", num_strings);
        timestamp begin = wallclock();

        UNUSED(num_threads);

        _encode_sync_lock(self);

        struct sync_extra *extra = this_extra(self);

        archive_field_sid_t *ids_out = MALLOC(num_strings * sizeof(archive_field_sid_t));
        bool *found_mask;
        archive_field_sid_t *values;
        size_t num_not_found;

        /** query index for strings to get a boolean mask which strings are new and which must be added */
        /** This is for the case that the string dictionary is not empty to skip processing of those new elements
         * which are already contained */
        TRACE(STRING_DIC_SYNC_TAG, "local str_buf dictionary check for new strings in insertion bulk%s", "...");

        /** NOTE: palatalization of the call to this function decreases performance */
        str_hash_get_bulk_safe(&values, &found_mask, &num_not_found, &extra->index, strings, num_strings);

        /** OPTIMIZATION: use a bitmap to check whether a string (which has not appeared in the
         * dictionary before this batch but might occur multiple times in the current batch) was seen
         * before (with a slight prob. of doing too much work) */
        bitmap bitmap;
        bloom_create(&bitmap, 22 * num_not_found);

        /** copy string ids for already known strings to their result position resp. add those which are new */
        for (size_t i = 0; i < num_strings; i++) {

                if (found_mask[i]) {
                        ids_out[i] = values[i];
                } else {
                        /** This path is taken only for strings that are not already contained in the dictionary. However,
                         * since this insertion batch may contain duplicate string, querying for already inserted strings
                         * must be done anyway for each string in the insertion batch that is inserted. */

                        archive_field_sid_t string_id = 0;
                        const char *key = (const char *) (strings[i]);

                        bool found = false;
                        archive_field_sid_t value;

                        /** Query the bitmap if the keys was already seend. If the filter returns "yes", a lookup
                         * is requried since the filter maybe made a mistake. Of the filter returns "no", the
                         * keys is new for sure. In this case, one can skip the lookup into the buckets. */
                        size_t key_length = strlen(key);
                        hash32_t bloom_key = key_length > 0 ? HASH_FNV(strlen(key), key)
                                                            : 0; /** using a hash of a keys instead of the string keys itself avoids reading the entire string for computing k hashes inside the bitmap */
                        if (BLOOM_TEST_AND_SET(&bitmap, &bloom_key, sizeof(hash32_t))) {
                                /** ensure that the string really was seen (due to collisions in the bloom filter the keys might not
                                 * been actually seen) */

                                /** query index for strings to get a boolean mask which strings are new and which must be added */
                                /** This is for the case that the string was not already contained in the string dictionary but may have
                                 * duplicates in this insertion batch that are already inserted */
                                str_hash_get_bulk_safe_exact(&value,
                                                            &found,
                                                            &extra->index,
                                                            key);  /** OPTIMIZATION: use specialized function for "exact" query to avoid unnessecary malloc calls to manage set of results if only a single result is needed */
                        }

                        if (found) {
                                ids_out[i] = value;
                        } else {

                                /** register in contents list */
                                bool pop_result = freelist_pop(&string_id, self);
                                ERROR_IF_AND_RETURN(!pop_result, ERR_SLOTBROKEN, NULL)
                                struct entry *entries = (struct entry *) vec_data(&extra->contents);
                                struct entry *entry = entries + string_id;
                                assert (!entry->in_use);
                                entry->in_use = true;
                                entry->str = strdup(strings[i]);
                                ids_out[i] = string_id;

                                /** add for not yet registered pairs to buffer for fast import */
                                str_hash_put_exact_fast(&extra->index, entry->str, string_id);
                        }
                }
        }

        /** set potential non-null out parameters */
        OPTIONAL_SET_OR_ELSE(out, ids_out, free(ids_out));

        /** cleanup */
        free(found_mask);
        free(values);
        bloom_drop(&bitmap);

        _encode_sync_unlock(self);

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        INFO(STRING_DIC_SYNC_TAG, "insertion operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;

}

static bool _encode_sync_remove(string_dict *self, archive_field_sid_t *strings, size_t num_strings)
{
        _encode_sync_lock(self);

        struct sync_extra *extra = this_extra(self);

        size_t num_strings_to_delete = 0;
        char **string_to_delete = MALLOC(num_strings * sizeof(char *));
        archive_field_sid_t *string_ids_to_delete = MALLOC(num_strings * sizeof(archive_field_sid_t));

        /** remove strings from contents vec, and skip duplicates */
        for (size_t i = 0; i < num_strings; i++) {
                archive_field_sid_t archive_field_sid_t = strings[i];
                struct entry *entry = (struct entry *) vec_data(&extra->contents) + archive_field_sid_t;
                if (LIKELY(entry->in_use)) {
                        string_to_delete[num_strings_to_delete] = entry->str;
                        string_ids_to_delete[num_strings_to_delete] = strings[i];
                        entry->str = NULL;
                        entry->in_use = false;
                        num_strings_to_delete++;
                        CHECK_SUCCESS(freelist_push(self, archive_field_sid_t));
                }
        }

        /** remove from index */
        CHECK_SUCCESS(str_hash_remove(&extra->index, string_to_delete, num_strings_to_delete));

        /** free up resources for strings that should be removed */
        for (size_t i = 0; i < num_strings_to_delete; i++) {
                free(string_to_delete[i]);
        }

        /** cleanup */
        free(string_to_delete);
        free(string_ids_to_delete);

        _encode_sync_unlock(self);
        return true;
}

static bool
_encode_sync_locate_safe(string_dict *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys)
{
        timestamp begin = wallclock();
        TRACE(STRING_DIC_SYNC_TAG, "'locate_safe' function invoked for %zu strings", num_keys)

        _encode_sync_lock(self);
        struct sync_extra *extra = this_extra(self);
        int status = str_hash_get_bulk_safe(out, found_mask, num_not_found, &extra->index, keys, num_keys);
        _encode_sync_unlock(self);

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        TRACE(STRING_DIC_SYNC_TAG, "'locate_safe' function done: %f seconds spent here", (end - begin) / 1000.0f)

        return status;
}

static bool
_encode_sync_locate_fast(string_dict *self, archive_field_sid_t **out, char *const *keys, size_t num_keys)
{
        bool *found_mask;
        size_t num_not_found;

        /** use safer but in principle more slower implementation */
        int result = _encode_sync_locate_safe(self, out, &found_mask, &num_not_found, keys, num_keys);

        /** cleanup */
        _encode_sync_free(self, found_mask);

        return result;
}

static char **_encode_sync_extract(string_dict *self, const archive_field_sid_t *ids, size_t num_ids)
{
        if (UNLIKELY(!self || !ids || num_ids == 0 || self->tag != SYNC)) {
                return NULL;
        }

        _encode_sync_lock(self);

        struct sync_extra *extra = this_extra(self);
        char **result = MALLOC(num_ids * sizeof(char *));
        struct entry *entries = (struct entry *) vec_data(&extra->contents);

        /** Optimization: notify the kernel that the content list is accessed randomly (since hash based access)*/
        vec_madvise(&extra->contents, MADV_RANDOM | MADV_WILLNEED);

        for (size_t i = 0; i < num_ids; i++) {
                archive_field_sid_t archive_field_sid_t = ids[i];
                assert(archive_field_sid_t < VEC_LENGTH(&extra->contents));
                assert(
                        archive_field_sid_t == NULL_ENCODED_STRING || entries[archive_field_sid_t].in_use);
                result[i] = archive_field_sid_t != NULL_ENCODED_STRING ? entries[archive_field_sid_t].str
                                                                               : NULL_TEXT;
        }

        _encode_sync_unlock(self);
        return result;
}

static bool _encode_sync_free(string_dict *self, void *ptr)
{
        UNUSED(self);
        free(ptr);
        return true;
}

static bool _encode_sync_reset_counters(string_dict *self)
{
        struct sync_extra *extra = this_extra(self);
        CHECK_SUCCESS(str_hash_reset_counters(&extra->index));
        return true;
}

static bool _encode_sync_counters(string_dict *self, str_hash_counters *counters)
{
        struct sync_extra *extra = this_extra(self);
        CHECK_SUCCESS(str_hash_get_counters(counters, &extra->index));
        return true;
}

static bool _encode_sync_num_distinct(string_dict *self, size_t *num)
{
        struct sync_extra *extra = this_extra(self);
        *num = VEC_LENGTH(&extra->contents);
        return true;
}

static bool _encode_sync_get_contents(string_dict *self, vec ofType (char *) *strings,
                              vec ofType(archive_field_sid_t) *string_ids)
{
        struct sync_extra *extra = this_extra(self);

        for (archive_field_sid_t i = 0; i < extra->contents.num_elems; i++) {
                const struct entry *e = VEC_GET(&extra->contents, i, struct entry);
                if (e->in_use) {
                        vec_push(strings, &e->str, 1);
                        vec_push(string_ids, &i, 1);
                }
        }
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>

#include <karbonit/archive/encoded_doc.h>

bool encoded_doc_collection_create(encoded_doc_list *collection, archive *archive)
{
        UNUSED(collection);
        UNUSED(archive);

        vec_create(&collection->flat_object_collection, sizeof(encoded_doc), 5000000);
        hashtable_create(&collection->index, sizeof(unique_id_t), sizeof(u32), 5000000);
        collection->archive = archive;

        return true;
}

bool encoded_doc_collection_drop(encoded_doc_list *collection)
{
        UNUSED(collection);

        hashtable_drop(&collection->index);
        for (u32 i = 0; i < collection->flat_object_collection.num_elems; i++) {
                encoded_doc *doc = VEC_GET(&collection->flat_object_collection, i, encoded_doc);
                encoded_doc_drop(doc);
        }
        vec_drop(&collection->flat_object_collection);
        return true;
}

static encoded_doc *
doc_create(unique_id_t object_id, encoded_doc_list *collection)
{
        if (collection) {
                u32 doc_position = collection->flat_object_collection.num_elems;
                encoded_doc
                        *new_doc = VEC_NEW_AND_GET(&collection->flat_object_collection, encoded_doc);
                new_doc->context = collection;
                new_doc->object_id = object_id;
                vec_create(&new_doc->props, sizeof(encoded_doc_prop), 20);
                vec_create(&new_doc->props_arrays, sizeof(encoded_doc_prop_array), 20);
                hashtable_create(&new_doc->prop_array_index, sizeof(archive_field_sid_t), sizeof(u32), 20);
                hashtable_insert_or_update(&collection->index, &object_id, &doc_position, 1);
                return new_doc;
        } else {
                ERROR(ERR_ILLEGALARG, NULL);
                return NULL;
        }
}

encoded_doc *encoded_doc_collection_get_or_append(encoded_doc_list *collection,
                                                             unique_id_t id)
{
        const u32 *doc_pos = hashtable_get_value(&collection->index, &id);
        if (doc_pos) {
                encoded_doc *result = VEC_GET(&collection->flat_object_collection, *doc_pos,
                                                         encoded_doc);
                ERROR_IF_AND_RETURN(result == NULL, ERR_INTERNALERR, NULL);
                return result;
        } else {
                encoded_doc *result = doc_create(id, collection);
                if (!result) {
                        ERROR(ERR_INTERNALERR, NULL);
                }
                return result;
        }
}

bool encoded_doc_collection_print(FILE *file, encoded_doc_list *collection)
{
        UNUSED(file);
        UNUSED(collection);

        if (collection->flat_object_collection.num_elems > 0) {
                encoded_doc *root = VEC_GET(&collection->flat_object_collection, 0, encoded_doc);
                encoded_doc_print(file, root);
        }

        return false;
}

bool encoded_doc_drop(encoded_doc *doc)
{
        UNUSED(doc);
        for (u32 i = 0; i < doc->props_arrays.num_elems; i++) {
                encoded_doc_prop_array *array = VEC_GET(&doc->props_arrays, i,
                                                                   encoded_doc_prop_array);
                vec_drop(&array->values);
        }
        for (u32 i = 0; i < doc->props.num_elems; i++) {
                encoded_doc_prop *single = VEC_GET(&doc->props, i, encoded_doc_prop);
                if (single->header.value_type == VALUE_DECODED_STRING) {
                        free(single->value.string);
                }
        }
        vec_drop(&doc->props);
        vec_drop(&doc->props_arrays);
        hashtable_drop(&doc->prop_array_index);
        return false;
}

#define DECLARE_ENCODED_DOC_ADD_PROP_BASIC(built_in_type, basic_type, value_name)                               \
bool                                                                                                    \
encoded_doc_add_prop_##value_name(encoded_doc *doc, archive_field_sid_t key, built_in_type value)       \
{                                                                                                                      \
    encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);                      \
    prop->header.context = doc;                                                                                        \
    prop->header.rec_key_type = STRING_ENCODED;                                        \
    prop->header.key.key_id = key;                                                                                     \
    prop->header.value_type = VALUE_BUILTIN;                                              \
    prop->header.type = basic_type;                                                                                    \
    prop->value.builtin.value_name = value;                                                                            \
    return true;                                                                                                       \
}

#define DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(built_in_type, basic_type, value_name)                       \
bool                                                                                                    \
encoded_doc_add_prop_##value_name##_decoded(encoded_doc *doc, const char *key, built_in_type value)    \
{                                                                                                                      \
    encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);                      \
    prop->header.context = doc;                                                                                        \
    prop->header.rec_key_type = STRING_DECODED;                                        \
    prop->header.key.key_str = strdup(key);                                                                            \
    prop->header.value_type = VALUE_BUILTIN;                                              \
    prop->header.type = basic_type;                                                                                    \
    prop->value.builtin.value_name = value;                                                                            \
    return true;                                                                                                       \
}

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_i8_t, ARCHIVE_FIELD_INT8, int8)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_i16_t, ARCHIVE_FIELD_INT16, int16)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_i32_t, ARCHIVE_FIELD_INT32, int32)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_i64_t, ARCHIVE_FIELD_INT64, int64)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_u8_t, ARCHIVE_FIELD_UINT8, uint8)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_u16_t, ARCHIVE_FIELD_UINT16, uint16)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_u32_t, ARCHIVE_FIELD_UINT32, uint32)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_u64_t, ARCHIVE_FIELD_UINT64, uint64)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_number_t, ARCHIVE_FIELD_FLOAT, number)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_boolean_t, ARCHIVE_FIELD_BOOLEAN, boolean)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC(archive_field_sid_t, ARCHIVE_FIELD_STRING, string)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_i8_t, ARCHIVE_FIELD_INT8, int8)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_i16_t, ARCHIVE_FIELD_INT16, int16)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_i32_t, ARCHIVE_FIELD_INT32, int32)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_i64_t, ARCHIVE_FIELD_INT64, int64)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_u8_t, ARCHIVE_FIELD_UINT8, uint8)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_u16_t, ARCHIVE_FIELD_UINT16, uint16)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_u32_t, ARCHIVE_FIELD_UINT32, uint32)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_u64_t, ARCHIVE_FIELD_UINT64, uint64)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_number_t, ARCHIVE_FIELD_FLOAT, number)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_boolean_t, ARCHIVE_FIELD_BOOLEAN, boolean)

DECLARE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(archive_field_sid_t, ARCHIVE_FIELD_STRING, string)

bool encoded_doc_add_prop_string_decoded_string_value_decoded(encoded_doc *doc, const char *key,
                                                              const char *value)
{
        encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);
        prop->header.context = doc;
        prop->header.rec_key_type = STRING_DECODED;
        prop->header.key.key_str = strdup(key);
        prop->header.type = ARCHIVE_FIELD_STRING;
        prop->value.string = strdup(value);
        return true;
}

bool encoded_doc_add_prop_null(encoded_doc *doc, archive_field_sid_t key)
{
        encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);
        prop->header.context = doc;
        prop->header.rec_key_type = STRING_ENCODED;
        prop->header.key.key_id = key;
        prop->header.type = ARCHIVE_FIELD_NULL;
        prop->value.builtin.null = 1;
        return true;
}

bool encoded_doc_add_prop_null_decoded(encoded_doc *doc, const char *key)
{
        encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);
        prop->header.context = doc;
        prop->header.rec_key_type = STRING_DECODED;
        prop->header.key.key_str = strdup(key);
        prop->header.type = ARCHIVE_FIELD_NULL;
        prop->value.builtin.null = 1;
        return true;
}

bool
encoded_doc_add_prop_object(encoded_doc *doc, archive_field_sid_t key, encoded_doc *value)
{
        encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);
        prop->header.context = doc;
        prop->header.rec_key_type = STRING_ENCODED;
        prop->header.key.key_id = key;
        prop->header.type = ARCHIVE_FIELD_OBJECT;
        prop->value.builtin.object = value->object_id;
        return true;
}

bool encoded_doc_add_prop_object_decoded(encoded_doc *doc, const char *key,
                                         encoded_doc *value)
{
        encoded_doc_prop *prop = VEC_NEW_AND_GET(&doc->props, encoded_doc_prop);
        prop->header.context = doc;
        prop->header.rec_key_type = STRING_DECODED;
        prop->header.key.key_str = strdup(key);
        prop->header.type = ARCHIVE_FIELD_OBJECT;
        prop->value.builtin.object = value->object_id;
        return true;
}

#define DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(name, basic_type)                                               \
bool                                                                                                    \
encoded_doc_add_prop_array_##name(encoded_doc *doc,                                                    \
                                       archive_field_sid_t key)                                                         \
{                                                                                                                      \
    u32 new_array_pos = doc->props_arrays.num_elems;                                                              \
    encoded_doc_prop_array *array = VEC_NEW_AND_GET(&doc->props_arrays, encoded_doc_prop_array);  \
    array->header.rec_key_type = STRING_ENCODED;                                          \
    array->header.key.key_id = key;                                                                                    \
    array->header.type = basic_type;                                                                                   \
    array->header.context = doc;                                                                                       \
    vec_create(&array->values, sizeof(encoded_doc_value_u), 10);                                   \
    hashtable_insert_or_update(&doc->prop_array_index, &key, &new_array_pos, 1);                                \
    return true;                                                                                                       \
}

#define DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(name, basic_type)                                       \
bool                                                                                                    \
encoded_doc_add_prop_array_##name##_decoded(encoded_doc *doc,                                          \
                                       const char *key)                                                                \
{                                                                                                                      \
    encoded_doc_prop_array *array = VEC_NEW_AND_GET(&doc->props_arrays, encoded_doc_prop_array);  \
    array->header.rec_key_type = STRING_DECODED;                                          \
    array->header.key.key_str = strdup(key);                                                                           \
    array->header.type = basic_type;                                                                                   \
    array->header.context = doc;                                                                                       \
    vec_create(&array->values, sizeof(encoded_doc_value_u), 10);                                   \
    return true;                                                                                                       \
}

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int8, ARCHIVE_FIELD_INT8)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int16, ARCHIVE_FIELD_INT16)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int32, ARCHIVE_FIELD_INT32)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int64, ARCHIVE_FIELD_INT64)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint8, ARCHIVE_FIELD_UINT8)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint16, ARCHIVE_FIELD_UINT16)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint32, ARCHIVE_FIELD_UINT32)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint64, ARCHIVE_FIELD_UINT64)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(number, ARCHIVE_FIELD_FLOAT)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(boolean, ARCHIVE_FIELD_BOOLEAN)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(string, ARCHIVE_FIELD_STRING)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(null, ARCHIVE_FIELD_NULL)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(object, ARCHIVE_FIELD_OBJECT)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int8, ARCHIVE_FIELD_INT8)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int16, ARCHIVE_FIELD_INT16)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int32, ARCHIVE_FIELD_INT32)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int64, ARCHIVE_FIELD_INT64)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint8, ARCHIVE_FIELD_UINT8)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint16, ARCHIVE_FIELD_UINT16)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint32, ARCHIVE_FIELD_UINT32)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint64, ARCHIVE_FIELD_UINT64)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(number, ARCHIVE_FIELD_FLOAT)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(boolean, ARCHIVE_FIELD_BOOLEAN)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(string, ARCHIVE_FIELD_STRING)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(null, ARCHIVE_FIELD_NULL)

DECALRE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(object, ARCHIVE_FIELD_OBJECT)

#define DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(name, built_in_type, basic_type)                                    \
bool                                                                                                    \
encoded_doc_array_push_##name(encoded_doc *doc, archive_field_sid_t key,                                \
                                     const built_in_type *values, u32 values_length)                              \
{                                                                                                                      \
    const u32 *prop_pos = hashtable_get_value(&doc->prop_array_index, &key);                               \
    ERROR_IF_AND_RETURN(prop_pos == NULL, ERR_NOTFOUND, NULL);                                                 \
    encoded_doc_prop_array *array = VEC_GET(&doc->props_arrays, *prop_pos,                          \
                                                               encoded_doc_prop_array);                       \
    ERROR_IF_AND_RETURN(array == NULL, ERR_INTERNALERR, NULL);                                                 \
    ERROR_IF_AND_RETURN(array->header.type != basic_type, ERR_TYPEMISMATCH, NULL);                             \
    for (u32 i = 0; i < values_length; i++) {                                                                     \
        encoded_doc_value_u *value = VEC_NEW_AND_GET(&array->values, encoded_doc_value_u);            \
        value->name = values[i];                                                                                       \
    }                                                                                                                  \
                                                                                                                       \
    return true;                                                                                                       \
}

#include <inttypes.h>

#define DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(name, built_in_type, basic_type)                            \
bool                                                                                                    \
encoded_doc_array_push_##name##_decoded(encoded_doc *doc, const char *key,                             \
                                     const built_in_type *values, u32 values_length)                              \
{                                                                                                                      \
    u32 prop_pos = (u32) -1;                                                                                 \
    for (u32 i = 0; i < doc->props_arrays.num_elems; i++)                                                         \
    {                                                                                                                  \
        encoded_doc_prop_array *prop = VEC_GET(&doc->props_arrays, i, encoded_doc_prop_array); \
        if (prop->header.rec_key_type == STRING_DECODED) {                                \
            if (strcmp(prop->header.key.key_str, key) == 0) {                                                          \
                prop_pos = i;                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }                                                                                                                  \
    ERROR_IF_AND_RETURN(prop_pos == (u32) -1, ERR_NOTFOUND, NULL);                                        \
    encoded_doc_prop_array *array = VEC_GET(&doc->props_arrays, prop_pos,                           \
                                                                   encoded_doc_prop_array);                   \
    ERROR_IF_AND_RETURN(array == NULL, ERR_INTERNALERR, NULL);                                                 \
    ERROR_IF_AND_RETURN(array->header.type != basic_type, ERR_TYPEMISMATCH, NULL);                             \
    for (u32 i = 0; i < values_length; i++) {                                                                     \
        encoded_doc_value_u *value = VEC_NEW_AND_GET(&array->values, encoded_doc_value_u);            \
        value->name = values[i];                                                                                       \
    }                                                                                                                  \
                                                                                                                       \
    return true;                                                                                                       \
}

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(int8, archive_field_i8_t, ARCHIVE_FIELD_INT8)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(int16, archive_field_i16_t, ARCHIVE_FIELD_INT16)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(int32, archive_field_i32_t, ARCHIVE_FIELD_INT32)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(int64, archive_field_i64_t, ARCHIVE_FIELD_INT64)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint8, archive_field_u8_t, ARCHIVE_FIELD_UINT8)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint16, archive_field_u16_t, ARCHIVE_FIELD_UINT16)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint32, archive_field_u32_t, ARCHIVE_FIELD_UINT32)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint64, archive_field_u64_t, ARCHIVE_FIELD_UINT64)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(number, archive_field_number_t, ARCHIVE_FIELD_FLOAT)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(boolean, archive_field_boolean_t, ARCHIVE_FIELD_BOOLEAN)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(string, archive_field_sid_t, ARCHIVE_FIELD_STRING)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE(null, archive_field_u32_t, ARCHIVE_FIELD_NULL)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int8, archive_field_i8_t, ARCHIVE_FIELD_INT8)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int16, archive_field_i16_t, ARCHIVE_FIELD_INT16)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int32, archive_field_i32_t, ARCHIVE_FIELD_INT32)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int64, archive_field_i64_t, ARCHIVE_FIELD_INT64)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint8, archive_field_u8_t, ARCHIVE_FIELD_UINT8)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint16, archive_field_u16_t, ARCHIVE_FIELD_UINT16)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint32, archive_field_u32_t, ARCHIVE_FIELD_UINT32)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint64, archive_field_u64_t, ARCHIVE_FIELD_UINT64)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(number, archive_field_number_t, ARCHIVE_FIELD_FLOAT)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(boolean, archive_field_boolean_t, ARCHIVE_FIELD_BOOLEAN)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(string, archive_field_sid_t, ARCHIVE_FIELD_STRING)

DECLARE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(null, archive_field_u32_t, ARCHIVE_FIELD_NULL)
//
//bool
//encoded_doc_array_push_null(encoded_doc *doc, archive_field_sid_t key, u32 how_many)
//{
//    DEBUG_ERROR_IF_NULL(doc)
//    const u32 *prop_pos = hashtable_get_value(&doc->prop_array_index, &key);
//    ERROR_IF_AND_RETURN(prop_pos == NULL, &doc->err, ERR_NOTFOUND);
//    encoded_doc_prop_array *array = VEC_GET(&doc->props_arrays, *prop_pos,
//                                                               encoded_doc_prop_array);
//    ERROR_IF_AND_RETURN(array == NULL, &doc->err, ERR_INTERNALERR);
//    ERROR_IF_AND_RETURN(array->header.type != ARCHIVE_FIELD_NULL, &doc->err, ERR_TYPEMISMATCH);
//    encoded_doc_value_u *value = VEC_NEW_AND_GET(&array->values, encoded_doc_value_u);
//    value->num_nulls = how_many;
//    return true;
//}


#include <inttypes.h>
#include <karbonit/archive/query.h>

bool encoded_doc_array_push_object(encoded_doc *doc, archive_field_sid_t key, unique_id_t id)
{
        UNUSED(doc);
        UNUSED(key);
        UNUSED(id);
        const u32 *prop_pos = hashtable_get_value(&doc->prop_array_index, &key);
        ERROR_IF_AND_RETURN(prop_pos == NULL, ERR_NOTFOUND, NULL);
        encoded_doc_prop_array *array = VEC_GET(&doc->props_arrays, *prop_pos,
                                                           encoded_doc_prop_array);
        ERROR_IF_AND_RETURN(array == NULL, ERR_INTERNALERR, NULL);
        ERROR_IF_AND_RETURN(array->header.type != ARCHIVE_FIELD_OBJECT, ERR_TYPEMISMATCH, NULL);
        encoded_doc_value_u *value = VEC_NEW_AND_GET(&array->values, encoded_doc_value_u);
        value->object = id;
        return true;
}

bool encoded_doc_array_push_object_decoded(encoded_doc *doc, const char *key, unique_id_t id)
{
        UNUSED(doc);
        UNUSED(key);
        UNUSED(id);

        u32 prop_pos = (u32) -1;
        for (u32 i = 0; i < doc->props_arrays.num_elems; i++) {
                encoded_doc_prop_array *prop = VEC_GET(&doc->props_arrays, i,
                                                                  encoded_doc_prop_array);
                if (prop->header.rec_key_type == STRING_DECODED) {
                        if (strcmp(prop->header.key.key_str, key) == 0) {
                                prop_pos = i;
                                break;
                        }
                }
        }
        ERROR_IF_AND_RETURN(prop_pos == (u32) -1, ERR_NOTFOUND, NULL);
        encoded_doc_prop_array *array = VEC_GET(&doc->props_arrays, prop_pos,
                                                           encoded_doc_prop_array);
        ERROR_IF_AND_RETURN(array == NULL, ERR_INTERNALERR, NULL);
        ERROR_IF_AND_RETURN(array->header.type != ARCHIVE_FIELD_OBJECT, ERR_TYPEMISMATCH, NULL);
        encoded_doc_value_u *value = VEC_NEW_AND_GET(&array->values, encoded_doc_value_u);
        value->object = id;
        return true;
}

static bool doc_print_pretty(FILE *file, encoded_doc *doc, unsigned level)
{
        query query;
        archive_query_run(&query, doc->context->archive);

        fprintf(file, "{\n");

        for (u32 i = 0; i < doc->props.num_elems; i++) {
                encoded_doc_prop *prop = VEC_GET(&doc->props, i, encoded_doc_prop);
                char *key_str = NULL;
                if (prop->header.rec_key_type == STRING_ENCODED) {
                        key_str = query_fetch_string_by_id(&query, prop->header.key.key_id);
                } else {
                        key_str = strdup(prop->header.key.key_str);
                }

                for (unsigned k = 0; k < level; k++) {
                        fprintf(file, "   ");
                }

                fprintf(file, "\"%s\": ", key_str);
                switch (prop->header.type) {
                        case ARCHIVE_FIELD_INT8:
                                fprintf(file, "%" PRIi8, prop->value.builtin.int8);
                                break;
                        case ARCHIVE_FIELD_INT16:
                                fprintf(file, "%" PRIi16, prop->value.builtin.int16);
                                break;
                        case ARCHIVE_FIELD_INT32:
                                fprintf(file, "%" PRIi32, prop->value.builtin.int32);
                                break;
                        case ARCHIVE_FIELD_INT64:
                                fprintf(file, "%" PRIi64, prop->value.builtin.int64);
                                break;
                        case ARCHIVE_FIELD_UINT8:
                                fprintf(file, "%" PRIu8, prop->value.builtin.uint8);
                                break;
                        case ARCHIVE_FIELD_UINT16:
                                fprintf(file, "%" PRIu16, prop->value.builtin.uint16);
                                break;
                        case ARCHIVE_FIELD_UINT32:
                                fprintf(file, "%" PRIu32, prop->value.builtin.uint32);
                                break;
                        case ARCHIVE_FIELD_UINT64:
                                fprintf(file, "%" PRIu64, prop->value.builtin.uint64);
                                break;
                        case ARCHIVE_FIELD_FLOAT:
                                fprintf(file, "%.2f", ceilf(prop->value.builtin.number * 100) / 100);
                                break;
                        case ARCHIVE_FIELD_STRING: {
                                if (prop->header.value_type == VALUE_BUILTIN) {
                                        char *value_str = query_fetch_string_by_id(&query,
                                                                                       prop->value.builtin.string);
                                        fprintf(file, "\"%s\"", value_str);
                                        free(value_str);
                                } else {
                                        fprintf(file, "\"%s\"", prop->value.string);
                                }
                        }
                                break;
                        case ARCHIVE_FIELD_BOOLEAN:
                                fprintf(file, "\"%s\"", prop->value.builtin.boolean ? "true" : "false");
                                break;
                        case ARCHIVE_FIELD_NULL:
                                fprintf(file, "null");
                                break;
                        case ARCHIVE_FIELD_OBJECT: {
                                encoded_doc *nested =
                                        encoded_doc_collection_get_or_append(doc->context, prop->value.builtin.object);
                                doc_print_pretty(file, nested, level + 1);
                        }
                                break;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                return false;
                }
                free(key_str);
                fprintf(file, "%s\n", i + 1 < doc->props.num_elems || doc->props_arrays.num_elems > 0 ? ", " : "");
        }

        for (u32 i = 0; i < doc->props_arrays.num_elems; i++) {
                encoded_doc_prop_array *prop = VEC_GET(&doc->props_arrays, i,
                                                                  encoded_doc_prop_array);
                char *key_str = NULL;
                if (prop->header.rec_key_type == STRING_ENCODED) {
                        key_str = query_fetch_string_by_id(&query, prop->header.key.key_id);
                } else {
                        key_str = strdup(prop->header.key.key_str);
                }

                for (unsigned k = 0; k < level; k++) {
                        fprintf(file, "   ");
                }

                fprintf(file, "\"%s\": ", key_str);

                if (prop->values.num_elems == 0) {
                        fprintf(file, "[ ]\n");
                        continue;
                }

                if (prop->values.num_elems > 1) {
                        fprintf(file, "[");
                }

                switch (prop->header.type) {
                        case ARCHIVE_FIELD_INT8:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_i8_t value = (VEC_GET(&prop->values, k,
                                                                                encoded_doc_value_u))->int8;
                                        if (IS_NULL_INT8(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi8 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_INT16:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_i16_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->int16;
                                        if (IS_NULL_INT16(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi16 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_INT32:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_i32_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->int32;
                                        if (IS_NULL_INT32(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi32 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_INT64:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_i64_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->int64;
                                        if (IS_NULL_INT64(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi64 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_UINT8:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_u8_t value = (VEC_GET(&prop->values, k,
                                                                                encoded_doc_value_u))->uint8;
                                        if (IS_NULL_UINT8(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu8 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_UINT16:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_u16_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->uint16;
                                        if (IS_NULL_UINT16(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu16 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_UINT32:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_u32_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->uint32;
                                        if (IS_NULL_UINT32(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu32 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_UINT64:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_u64_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->uint64;
                                        if (IS_NULL_UINT64(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu64 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_FLOAT:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_number_t value = (VEC_GET(&prop->values, k,
                                                                                    encoded_doc_value_u))->number;
                                        if (IS_NULL_NUMBER(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%.2f%s",
                                                        ceilf(value * 100) / 100,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_STRING: {
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_sid_t value = (VEC_GET(&prop->values, k,
                                                                                 encoded_doc_value_u))->string;
                                        if (IS_NULL_STRING(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                char *value_str = query_fetch_string_by_id(&query, value);
                                                fprintf(file,
                                                        "\"%s\"%s",
                                                        value_str,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                                free(value_str);
                                        }
                                }
                        }
                                break;
                        case ARCHIVE_FIELD_BOOLEAN:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        archive_field_boolean_t
                                                value = (VEC_GET(&prop->values, k, encoded_doc_value_u))->boolean;
                                        if (IS_NULL_BOOL(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%s%s",
                                                        value ? "true" : "false",
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case ARCHIVE_FIELD_NULL:
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                }
                                break;
                        case ARCHIVE_FIELD_OBJECT: {
                                for (u32 k = 0; k < prop->values.num_elems; k++) {
                                        unique_id_t nested_oid = (VEC_GET(&prop->values, k,
                                                                              encoded_doc_value_u))->object;
                                        encoded_doc
                                                *nested_doc = encoded_doc_collection_get_or_append(doc->context,
                                                                                                   nested_oid);
                                        fprintf(file, "\n");
                                        for (unsigned k = 0; k < level + 1; k++) {
                                                fprintf(file, "   ");
                                        }
                                        doc_print_pretty(file, nested_doc, level + 2);
                                        fprintf(file, "%s", k + 1 < prop->values.num_elems ? "," : "");
                                }
                                fprintf(file, "\n");
                                for (unsigned k = 0; k < level; k++) {
                                        fprintf(file, "   ");
                                }
                        }
                                break;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                return false;
                }
                free(key_str);
                if (prop->values.num_elems > 1) {
                        fprintf(file, "]");
                }
                fprintf(file, "%s\n", i + 1 < doc->props_arrays.num_elems ? ", " : "");
        }

        for (unsigned k = 0; k < level - 1; k++) {
                fprintf(file, "   ");
        }

        fprintf(file, "}");

        query_drop(&query);

        return true;
}

bool encoded_doc_print(FILE *file, encoded_doc *doc)
{
        return doc_print_pretty(file, doc, 1);
}

/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>

#include <karbonit/std/bitmap.h>
#include <karbonit/archive/pack.h>
#include <karbonit/archive/huffman.h>

#define  MARKER_SYMBOL_HUFFMAN_DIC_ENTRY   'd'

bool pack_huffman_init(packer *self)
{
        self->extra = MALLOC(sizeof(huffman));
        if (self->extra != NULL) {
                huffman *encoder = (huffman *) self->extra;
                coding_huffman_create(encoder);
                return true;
        } else {
                return false;
        }
}

bool pack_coding_huffman_cpy(const packer *self, packer *dst)
{
        *dst = *self;
        dst->extra = MALLOC(sizeof(huffman));
        if (dst->extra != NULL) {
                huffman *self_encoder = (huffman *) self->extra;
                huffman *dst_encoder = (huffman *) dst->extra;
                return coding_huffman_cpy(dst_encoder, self_encoder);
        } else {
                return false;
        }
}

bool pack_coding_huffman_drop(packer *self)
{
        huffman *encoder = (huffman *) self->extra;
        coding_huffman_drop(encoder);

        return true;
}

bool huffman_dump_dictionary(FILE *file, memfile *memfile)
{
        DECLARE_AND_INIT(pack_huffman_info, entry_info)
        DECLARE_AND_INIT(offset_t, offset);

        while ((*MEMFILE_PEEK_TYPE(memfile, char)) == MARKER_SYMBOL_HUFFMAN_DIC_ENTRY) {
                MEMFILE_GET_OFFSET(&offset, memfile);
                coding_huffman_read_entry(&entry_info, memfile, MARKER_SYMBOL_HUFFMAN_DIC_ENTRY);

                fprintf(file, "0x%04x ", (unsigned) offset);
                fprintf(file,
                        "[marker: %c] [letter: '%c'] [nbytes_prefix: %d] [code: ",
                        MARKER_SYMBOL_HUFFMAN_DIC_ENTRY,
                        entry_info.letter,
                        entry_info.nbytes_prefix);

                if (entry_info.nbytes_prefix > 0) {
                        for (u16 i = 0; i < entry_info.nbytes_prefix; i++) {
                                bitmap_print_bits_in_char(file, entry_info.prefix_code[i]);
                                fprintf(file, "%s", i + 1 < entry_info.nbytes_prefix ? ", " : "");
                        }
                } else {
                        fprintf(file, "0b00000000");
                }

                fprintf(file, "]\n");
        }
        return true;
}

bool huffman_dump_string_table_entry(FILE *file, memfile *memfile)
{
        UNUSED(file);
        UNUSED(memfile);

        pack_huffman_str_info info;

        coding_huffman_read_string(&info, memfile);

        fprintf(file, "[[nbytes_encoded: %d] [bytes: ", info.nbytes_encoded);
        for (size_t i = 0; i < info.nbytes_encoded; i++) {
                char byte = info.encoded_bytes[i];
                bitmap_print_bits_in_char(file, byte);
                fprintf(file, "%s", i + 1 < info.nbytes_encoded ? "," : "");
        }
        fprintf(file, "]\n");

        return true;
}

bool pack_huffman_write_extra(packer *self, memfile *dst,
                              const vec ofType (const char *) *strings)
{
        huffman *encoder = (huffman *) self->extra;

        coding_huffman_build(encoder, strings);
        coding_huffman_serialize(dst, encoder, MARKER_SYMBOL_HUFFMAN_DIC_ENTRY);

        return true;
}

bool pack_huffman_read_extra(packer *self, FILE *src, size_t nbytes)
{
        UNUSED(self);
        UNUSED(src);
        UNUSED(nbytes);

        abort(); /** not implemented */
        return false;
}

bool pack_huffman_print_extra(packer *self, FILE *file, memfile *src)
{
        UNUSED(self);

        huffman_dump_dictionary(file, src);

        return true;
}

bool pack_huffman_print_encoded(packer *self, FILE *file, memfile *src,
                                u32 decompressed_strlen)
{
        UNUSED(self);
        UNUSED(file);
        UNUSED(src);
        UNUSED(decompressed_strlen);

        huffman_dump_string_table_entry(file, src);

        return true;
}

bool
pack_huffman_encode_string(packer *self, memfile *dst, const char *string)
{
        huffman *encoder = (huffman *) self->extra;
        bool status = coding_huffman_encode(dst, encoder, string);
        return status;
}

bool pack_huffman_decode_string(packer *self, char *dst, size_t strlen, FILE *src)
{
        UNUSED(self);
        UNUSED(dst);
        UNUSED(strlen);
        UNUSED(src);
        abort(); /** not implemented */
        return false;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/archive/internal.h>

void int_read_prop_offsets(archive_prop_offs *prop_offsets, memfile *memfile,
                               const object_flags_u *flags)
{
        ZERO_MEMORY(prop_offsets, sizeof(archive_prop_offs));
        if (flags->bits.has_null_props) {
                prop_offsets->nulls = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_bool_props) {
                prop_offsets->bools = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int8_props) {
                prop_offsets->int8s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int16_props) {
                prop_offsets->int16s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int32_props) {
                prop_offsets->int32s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int64_props) {
                prop_offsets->int64s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint8_props) {
                prop_offsets->uint8s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint16_props) {
                prop_offsets->uint16s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint32_props) {
                prop_offsets->uint32s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint64_props) {
                prop_offsets->uint64s = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_float_props) {
                prop_offsets->floats = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_string_props) {
                prop_offsets->strings = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_object_props) {
                prop_offsets->objects = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_null_array_props) {
                prop_offsets->null_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_bool_array_props) {
                prop_offsets->bool_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int8_array_props) {
                prop_offsets->int8_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int16_array_props) {
                prop_offsets->int16_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int32_array_props) {
                prop_offsets->int32_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_int64_array_props) {
                prop_offsets->int64_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint8_array_props) {
                prop_offsets->uint8_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint16_array_props) {
                prop_offsets->uint16_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint32_array_props) {
                prop_offsets->uint32_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_uint64_array_props) {
                prop_offsets->uint64_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_float_array_props) {
                prop_offsets->float_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_string_array_props) {
                prop_offsets->string_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
        if (flags->bits.has_object_array_props) {
                prop_offsets->object_arrays = *MEMFILE_READ_TYPE(memfile, offset_t);
        }
}

void int_embedded_fixed_props_read(fixed_prop *prop, memfile *memfile)
{
        prop->header = MEMFILE_READ_TYPE(memfile, prop_header);
        prop->keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(archive_field_sid_t));
        prop->values = MEMFILE_PEEK(memfile, 1);
}

void int_embedded_var_props_read(var_prop *prop, memfile *memfile)
{
        prop->header = MEMFILE_READ_TYPE(memfile, prop_header);
        prop->keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(archive_field_sid_t));
        prop->offsets = (offset_t *) MEMFILE_READ(memfile, prop->header->num_entries * sizeof(offset_t));
        prop->values = MEMFILE_PEEK(memfile, 1);
}

void int_embedded_null_props_read(null_prop *prop, memfile *memfile)
{
        prop->header = MEMFILE_READ_TYPE(memfile, prop_header);
        prop->keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(archive_field_sid_t));
}

void int_embedded_array_props_read(array_prop *prop, memfile *memfile)
{
        prop->header = MEMFILE_READ_TYPE(memfile, prop_header);
        prop->keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(archive_field_sid_t));
        prop->lengths = (u32 *) MEMFILE_READ(memfile, prop->header->num_entries * sizeof(u32));
        prop->values_begin = MEMFILE_TELL(memfile);
}

void int_embedded_table_props_read(table_prop *prop, memfile *memfile)
{
        prop->header->marker = *MEMFILE_READ_TYPE(memfile, char);
        prop->header->num_entries = *MEMFILE_READ_TYPE(memfile, u8);
        prop->keys = (archive_field_sid_t *) MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(archive_field_sid_t));
        prop->group_offs = (offset_t *) MEMFILE_READ(memfile, prop->header->num_entries * sizeof(offset_t));
}

archive_field_e int_get_value_type_of_char(char c)
{
        size_t len = sizeof(global_value_array_marker_mapping) / sizeof(global_value_array_marker_mapping[0]);
        for (size_t i = 0; i < len; i++) {
                if (global_marker_symbols[global_value_array_marker_mapping[i].marker].symbol == c) {
                        return global_value_array_marker_mapping[i].value_type;
                }
        }
        return ARCHIVE_FIELD_NULL;
}

archive_field_e // TODO: check whether 'archive_field_e' can be replaced by 'enum archive_field_type'
int_marker_to_field_type(char symbol)
{
        switch (symbol) {
                case MARKER_SYMBOL_PROP_NULL:
                case MARKER_SYMBOL_PROP_NULL_ARRAY:
                        return ARCHIVE_FIELD_NULL;
                case MARKER_SYMBOL_PROP_BOOLEAN:
                case MARKER_SYMBOL_PROP_BOOLEAN_ARRAY:
                        return ARCHIVE_FIELD_BOOLEAN;
                case MARKER_SYMBOL_PROP_INT8:
                case MARKER_SYMBOL_PROP_INT8_ARRAY:
                        return ARCHIVE_FIELD_INT8;
                case MARKER_SYMBOL_PROP_INT16:
                case MARKER_SYMBOL_PROP_INT16_ARRAY:
                        return ARCHIVE_FIELD_INT16;
                case MARKER_SYMBOL_PROP_INT32:
                case MARKER_SYMBOL_PROP_INT32_ARRAY:
                        return ARCHIVE_FIELD_INT32;
                case MARKER_SYMBOL_PROP_INT64:
                case MARKER_SYMBOL_PROP_INT64_ARRAY:
                        return ARCHIVE_FIELD_INT64;
                case MARKER_SYMBOL_PROP_UINT8:
                case MARKER_SYMBOL_PROP_UINT8_ARRAY:
                        return ARCHIVE_FIELD_UINT8;
                case MARKER_SYMBOL_PROP_UINT16:
                case MARKER_SYMBOL_PROP_UINT16_ARRAY:
                        return ARCHIVE_FIELD_UINT16;
                case MARKER_SYMBOL_PROP_UINT32:
                case MARKER_SYMBOL_PROP_UINT32_ARRAY:
                        return ARCHIVE_FIELD_UINT32;
                case MARKER_SYMBOL_PROP_UINT64:
                case MARKER_SYMBOL_PROP_UINT64_ARRAY:
                        return ARCHIVE_FIELD_UINT64;
                case MARKER_SYMBOL_PROP_REAL:
                case MARKER_SYMBOL_PROP_REAL_ARRAY:
                        return ARCHIVE_FIELD_FLOAT;
                case MARKER_SYMBOL_PROP_TEXT:
                case MARKER_SYMBOL_PROP_TEXT_ARRAY:
                        return ARCHIVE_FIELD_STRING;
                case MARKER_SYMBOL_PROP_OBJECT:
                case MARKER_SYMBOL_PROP_OBJECT_ARRAY:
                        return ARCHIVE_FIELD_OBJECT;
                default: {
                        ERROR(ERR_MARKERMAPPING, NULL);
                        return ARCHIVE_FIELD_NULL;
                }
        }
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/archive.h>
#include <karbonit/std/spinlock.h>
#include <karbonit/archive/io.h>

typedef struct archive_io_context {
        FILE *file;
        spinlock lock;
        offset_t last_pos;
} archive_io_context;

bool io_context_create(archive_io_context **context, const char *file_path)
{
        archive_io_context *result = MALLOC(sizeof(archive_io_context));

        if (!result) {
                ERROR(ERR_MALLOCERR, NULL);
                return false;
        }

        spinlock_init(&result->lock);

        result->file = fopen(file_path, "r");

        if (!result->file) {
                ERROR(ERR_FOPEN_FAILED, NULL);
                result->file = NULL;
                return false;
        } else {
                *context = result;
                return true;
        }
}

FILE *io_context_lock_and_access(archive_io_context *context)
{
        if (context) {
                spinlock_acquire(&context->lock);
                context->last_pos = ftell(context->file);
                return context->file;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool io_context_unlock(archive_io_context *context)
{
        if (context) {
                fseek(context->file, context->last_pos, SEEK_SET);
                spinlock_release(&context->lock);
                return true;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return false;
        }
}

bool io_context_drop(archive_io_context *context)
{
        OPTIONAL(context->file != NULL, fclose(context->file);
                context->file = NULL)
        free(context);
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/archive/it.h>
#include <karbonit/archive/internal.h>

static bool init_object_from_memfile(archive_object *obj, memfile *memfile)
{
        assert(obj);
        offset_t object_off;
        object_header *header;
        object_flags_u flags;

        object_off = MEMFILE_TELL(memfile);
        header = MEMFILE_READ_TYPE(memfile, object_header);
        if (UNLIKELY(header->marker != MARKER_SYMBOL_OBJECT_BEGIN)) {
                return false;
        }

        flags.value = header->flags;
        int_read_prop_offsets(&obj->prop_offsets, memfile, &flags);

        obj->object_id = header->oid;
        obj->offset = object_off;
        obj->next_obj_off = *MEMFILE_READ_TYPE(memfile, offset_t);
        MEMFILE_OPEN(&obj->memfile, memfile->memblock, READ_ONLY);

        return true;
}

#define STATE_AND_PROPERTY_EXISTS(state, property) \
    (iter->prop_cursor != state || iter->object.property != 0)

inline static offset_t offset_by_state(prop_iter *iter)
{
        switch (iter->prop_cursor) {
                case PROP_ITER_NULLS:
                        return iter->object.prop_offsets.nulls;
                case PROP_ITER_BOOLS:
                        return iter->object.prop_offsets.bools;
                case PROP_ITER_INT8S:
                        return iter->object.prop_offsets.int8s;
                case PROP_ITER_INT16S:
                        return iter->object.prop_offsets.int16s;
                case PROP_ITER_INT32S:
                        return iter->object.prop_offsets.int32s;
                case PROP_ITER_INT64S:
                        return iter->object.prop_offsets.int64s;
                case PROP_ITER_UINT8S:
                        return iter->object.prop_offsets.uint8s;
                case PROP_ITER_UINT16S:
                        return iter->object.prop_offsets.uint16s;
                case PROP_ITER_UINT32S:
                        return iter->object.prop_offsets.uint32s;
                case PROP_ITER_UINT64S:
                        return iter->object.prop_offsets.uint64s;
                case PROP_ITER_FLOATS:
                        return iter->object.prop_offsets.floats;
                case PROP_ITER_STRINGS:
                        return iter->object.prop_offsets.strings;
                case PROP_ITER_OBJECTS:
                        return iter->object.prop_offsets.objects;
                case PROP_ITER_NULL_ARRAYS:
                        return iter->object.prop_offsets.null_arrays;
                case PROP_ITER_BOOL_ARRAYS:
                        return iter->object.prop_offsets.bool_arrays;
                case PROP_ITER_INT8_ARRAYS:
                        return iter->object.prop_offsets.int8_arrays;
                case PROP_ITER_INT16_ARRAYS:
                        return iter->object.prop_offsets.int16_arrays;
                case PROP_ITER_INT32_ARRAYS:
                        return iter->object.prop_offsets.int32_arrays;
                case PROP_ITER_INT64_ARRAYS:
                        return iter->object.prop_offsets.int64_arrays;
                case PROP_ITER_UINT8_ARRAYS:
                        return iter->object.prop_offsets.uint8_arrays;
                case PROP_ITER_UINT16_ARRAYS:
                        return iter->object.prop_offsets.uint16_arrays;
                case PROP_ITER_UINT32_ARRAYS:
                        return iter->object.prop_offsets.uint32_arrays;
                case PROP_ITER_UINT64_ARRAYS:
                        return iter->object.prop_offsets.uint64_arrays;
                case PROP_ITER_FLOAT_ARRAYS:
                        return iter->object.prop_offsets.float_arrays;
                case PROP_ITER_STRING_ARRAYS:
                        return iter->object.prop_offsets.string_arrays;
                case PROP_ITER_OBJECT_ARRAYS:
                        return iter->object.prop_offsets.object_arrays;
                default: {
                        ERROR(ERR_INTERNALERR, NULL);
                        return 0;
                }
        }
}

static bool prop_iter_read_colum_entry(collection_iter_state *state, memfile *memfile)
{
        assert(state->current_column_group.current_column.current_entry.idx
                   < state->current_column_group.current_column.num_elem);

        u32 current_idx = state->current_column_group.current_column.current_entry.idx;
        offset_t entry_off = state->current_column_group.current_column.elem_offsets[current_idx];
        MEMFILE_SEEK(memfile, entry_off);

        state->current_column_group.current_column.current_entry.array_length = *MEMFILE_READ_TYPE(memfile,
                                                                                                       u32);
        state->current_column_group.current_column.current_entry.array_base = MEMFILE_PEEK_TYPE(memfile, void);

        return (++state->current_column_group.current_column.current_entry.idx)
               < state->current_column_group.current_column.num_elem;
}

static bool prop_iter_read_column(collection_iter_state *state, memfile *memfile)
{
        assert(state->current_column_group.current_column.idx < state->current_column_group.num_columns);

        u32 current_idx = state->current_column_group.current_column.idx;
        offset_t column_off = state->current_column_group.column_offs[current_idx];
        MEMFILE_SEEK(memfile, column_off);
        const column_header *header = MEMFILE_READ_TYPE(memfile, column_header);

        assert(header->marker == MARKER_SYMBOL_COLUMN);
        state->current_column_group.current_column.name = header->column_name;
        state->current_column_group.current_column.type = int_marker_to_field_type(header->value_type);

        state->current_column_group.current_column.num_elem = header->num_entries;
        state->current_column_group.current_column.elem_offsets =
                MEMFILE_READ_TYPE_LIST(memfile, offset_t, header->num_entries);
        state->current_column_group.current_column.elem_positions =
                MEMFILE_READ_TYPE_LIST(memfile, u32, header->num_entries);
        state->current_column_group.current_column.current_entry.idx = 0;

        return (++state->current_column_group.current_column.idx) < state->current_column_group.num_columns;
}

static bool collection_iter_read_next_column_group(collection_iter_state *state, memfile *memfile)
{
        assert(state->current_column_group_idx < state->num_column_groups);
        MEMFILE_SEEK(memfile, state->column_group_offsets[state->current_column_group_idx]);
        const column_group_header *header = MEMFILE_READ_TYPE(memfile, column_group_header);
        assert(header->marker == MARKER_SYMBOL_COLUMN_GROUP);
        state->current_column_group.num_columns = header->num_columns;
        state->current_column_group.num_objects = header->num_objects;
        state->current_column_group.object_ids = MEMFILE_READ_TYPE_LIST(memfile, unique_id_t,
                                                                            header->num_objects);
        state->current_column_group.column_offs = MEMFILE_READ_TYPE_LIST(memfile, offset_t,
                                                                             header->num_columns);
        state->current_column_group.current_column.idx = 0;

        return (++state->current_column_group_idx) < state->num_column_groups;
}

static void prop_iter_cursor_init(prop_iter *iter)
{
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_NULLS, prop_offsets.nulls));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_BOOLS, prop_offsets.bools));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT8S, prop_offsets.int8s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT16S, prop_offsets.int16s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT32S, prop_offsets.int32s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT64S, prop_offsets.int64s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT8S, prop_offsets.uint8s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT16S, prop_offsets.uint16s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT32S, prop_offsets.uint32s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT64S, prop_offsets.uint64s));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_FLOATS, prop_offsets.floats));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_STRINGS, prop_offsets.strings));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_OBJECTS, prop_offsets.objects));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_NULL_ARRAYS, prop_offsets.null_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_BOOL_ARRAYS, prop_offsets.bool_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT8_ARRAYS, prop_offsets.int8_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT16_ARRAYS, prop_offsets.int16_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT32_ARRAYS, prop_offsets.int32_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_INT64_ARRAYS, prop_offsets.int64_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT8_ARRAYS, prop_offsets.uint8_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT16_ARRAYS, prop_offsets.uint16_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT32_ARRAYS, prop_offsets.uint32_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_UINT64_ARRAYS, prop_offsets.uint64_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_FLOAT_ARRAYS, prop_offsets.float_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_STRING_ARRAYS, prop_offsets.string_arrays));
        assert(STATE_AND_PROPERTY_EXISTS(PROP_ITER_OBJECT_ARRAYS, prop_offsets.object_arrays));

        if (iter->mode == PROP_ITER_MODE_COLLECTION) {
                iter->mode_collection.collection_start_off = offset_by_state(iter);
                MEMFILE_SEEK(&iter->record_table_memfile, iter->mode_collection.collection_start_off);
                const object_array_header
                        *header = MEMFILE_READ_TYPE(&iter->record_table_memfile, object_array_header);
                iter->mode_collection.num_column_groups = header->num_entries;
                iter->mode_collection.current_column_group_idx = 0;
                iter->mode_collection.column_group_keys = MEMFILE_READ_TYPE_LIST(&iter->record_table_memfile,
                                                                                     archive_field_sid_t,
                                                                                     iter->mode_collection.num_column_groups);
                iter->mode_collection.column_group_offsets = MEMFILE_READ_TYPE_LIST(&iter->record_table_memfile,
                                                                                        offset_t,
                                                                                        iter->mode_collection.num_column_groups);

        } else {
                iter->mode_object.current_prop_group_off = offset_by_state(iter);
                MEMFILE_SEEK(&iter->record_table_memfile, iter->mode_object.current_prop_group_off);
                int_embedded_fixed_props_read(&iter->mode_object.prop_group_header, &iter->record_table_memfile);
                iter->mode_object.prop_data_off = MEMFILE_TELL(&iter->record_table_memfile);
        }

}

#define SET_STATE_FOR_FALL_THROUGH(iter, prop_offset_type, mask_group, mask_type, next_state)                          \
{                                                                                                                      \
    if ((iter->object.prop_offsets.prop_offset_type != 0) &&                                                           \
        (ARE_BITS_SET(iter->mask, mask_group | mask_type)))                                                  \
    {                                                                                                                  \
        iter->prop_cursor = next_state;                                                                                \
        break;                                                                                                         \
    }                                                                                                                  \
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"

static prop_iter_state_e prop_iter_state_next(prop_iter *iter)
{
        switch (iter->prop_cursor) {
                case PROP_ITER_INIT: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                    nulls,
                                                                    ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                    ARCHIVE_ITER_MASK_NULL,
                                                                    PROP_ITER_NULLS)
                case PROP_ITER_NULLS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                     bools,
                                                                     ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                     ARCHIVE_ITER_MASK_BOOLEAN,
                                                                     PROP_ITER_BOOLS)
                case PROP_ITER_BOOLS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                     int8s,
                                                                     ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                     ARCHIVE_ITER_MASK_INT8,
                                                                     PROP_ITER_INT8S)
                case PROP_ITER_INT8S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                     int16s,
                                                                     ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                     ARCHIVE_ITER_MASK_INT16,
                                                                     PROP_ITER_INT16S)
                case PROP_ITER_INT16S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      int32s,
                                                                      ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      ARCHIVE_ITER_MASK_INT32,
                                                                      PROP_ITER_INT32S)
                case PROP_ITER_INT32S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      int64s,
                                                                      ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      ARCHIVE_ITER_MASK_INT64,
                                                                      PROP_ITER_INT64S)
                case PROP_ITER_INT64S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      uint8s,
                                                                      ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      ARCHIVE_ITER_MASK_UINT8,
                                                                      PROP_ITER_UINT8S)
                case PROP_ITER_UINT8S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      uint16s,
                                                                      ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      ARCHIVE_ITER_MASK_UINT16,
                                                                      PROP_ITER_UINT16S)
                case PROP_ITER_UINT16S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       uint32s,
                                                                       ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       ARCHIVE_ITER_MASK_UINT32,
                                                                       PROP_ITER_UINT32S)
                case PROP_ITER_UINT32S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       uint64s,
                                                                       ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       ARCHIVE_ITER_MASK_UINT64,
                                                                       PROP_ITER_UINT64S)
                case PROP_ITER_UINT64S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       floats,
                                                                       ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       ARCHIVE_ITER_MASK_NUMBER,
                                                                       PROP_ITER_FLOATS)
                case PROP_ITER_FLOATS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      strings,
                                                                      ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      ARCHIVE_ITER_MASK_STRING,
                                                                      PROP_ITER_STRINGS)
                case PROP_ITER_STRINGS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       objects,
                                                                       ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       ARCHIVE_ITER_MASK_OBJECT,
                                                                       PROP_ITER_OBJECTS)
                case PROP_ITER_OBJECTS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       null_arrays,
                                                                       ARCHIVE_ITER_MASK_ARRAYS,
                                                                       ARCHIVE_ITER_MASK_NULL,
                                                                       PROP_ITER_NULL_ARRAYS)
                case PROP_ITER_NULL_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                           bool_arrays,
                                                                           ARCHIVE_ITER_MASK_ARRAYS,
                                                                           ARCHIVE_ITER_MASK_BOOLEAN,
                                                                           PROP_ITER_BOOL_ARRAYS)
                case PROP_ITER_BOOL_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                           int8_arrays,
                                                                           ARCHIVE_ITER_MASK_ARRAYS,
                                                                           ARCHIVE_ITER_MASK_INT8,
                                                                           PROP_ITER_INT8_ARRAYS)
                case PROP_ITER_INT8_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                           int16_arrays,
                                                                           ARCHIVE_ITER_MASK_ARRAYS,
                                                                           ARCHIVE_ITER_MASK_INT16,
                                                                           PROP_ITER_INT16_ARRAYS)
                case PROP_ITER_INT16_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            int32_arrays,
                                                                            ARCHIVE_ITER_MASK_ARRAYS,
                                                                            ARCHIVE_ITER_MASK_INT32,
                                                                            PROP_ITER_INT32_ARRAYS)
                case PROP_ITER_INT32_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            int64_arrays,
                                                                            ARCHIVE_ITER_MASK_ARRAYS,
                                                                            ARCHIVE_ITER_MASK_INT64,
                                                                            PROP_ITER_INT64_ARRAYS)
                case PROP_ITER_INT64_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            uint8_arrays,
                                                                            ARCHIVE_ITER_MASK_ARRAYS,
                                                                            ARCHIVE_ITER_MASK_UINT8,
                                                                            PROP_ITER_UINT8_ARRAYS)
                case PROP_ITER_UINT8_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            uint16_arrays,
                                                                            ARCHIVE_ITER_MASK_ARRAYS,
                                                                            ARCHIVE_ITER_MASK_UINT16,
                                                                            PROP_ITER_UINT16_ARRAYS)
                case PROP_ITER_UINT16_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             uint32_arrays,
                                                                             ARCHIVE_ITER_MASK_ARRAYS,
                                                                             ARCHIVE_ITER_MASK_UINT32,
                                                                             PROP_ITER_UINT32_ARRAYS)
                case PROP_ITER_UINT32_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             uint64_arrays,
                                                                             ARCHIVE_ITER_MASK_ARRAYS,
                                                                             ARCHIVE_ITER_MASK_UINT64,
                                                                             PROP_ITER_UINT64_ARRAYS)
                case PROP_ITER_UINT64_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             float_arrays,
                                                                             ARCHIVE_ITER_MASK_ARRAYS,
                                                                             ARCHIVE_ITER_MASK_NUMBER,
                                                                             PROP_ITER_FLOAT_ARRAYS)
                case PROP_ITER_FLOAT_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            string_arrays,
                                                                            ARCHIVE_ITER_MASK_ARRAYS,
                                                                            ARCHIVE_ITER_MASK_STRING,
                                                                            PROP_ITER_STRING_ARRAYS)
                case PROP_ITER_STRING_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             object_arrays,
                                                                             ARCHIVE_ITER_MASK_ARRAYS,
                                                                             ARCHIVE_ITER_MASK_OBJECT,
                                                                             PROP_ITER_OBJECT_ARRAYS)
                case PROP_ITER_OBJECT_ARRAYS:
                        iter->prop_cursor = PROP_ITER_DONE;
                        break;

                case PROP_ITER_DONE:
                        break;
                default: {
                        ERROR(ERR_INTERNALERR, NULL);
                        return PROP_ITER_ERR;
                }
        }

        iter->mode = iter->prop_cursor == PROP_ITER_OBJECT_ARRAYS ? PROP_ITER_MODE_COLLECTION
                                                                      : PROP_ITER_MODE_OBJECT;

        if (iter->prop_cursor != PROP_ITER_DONE) {
                prop_iter_cursor_init(iter);
        }
        return iter->prop_cursor;
}

#pragma GCC diagnostic pop

static void prop_iter_state_init(prop_iter *iter)
{
        iter->prop_cursor = PROP_ITER_INIT;
        iter->mode = PROP_ITER_MODE_OBJECT;
}

static bool archive_prop_iter_from_memblock(prop_iter *iter, u16 mask,
                                            memblock *memblock, offset_t object_offset)
{
        iter->mask = mask;
        MEMFILE_OPEN(&iter->record_table_memfile, memblock, READ_ONLY);
        if (!MEMFILE_SEEK(&iter->record_table_memfile, object_offset)) {
                return ERROR(ERR_MEMFILESEEK_FAILED, NULL);
        }
        if (!init_object_from_memfile(&iter->object, &iter->record_table_memfile)) {
                return ERROR(ERR_INTERNALERR, NULL);
        }

        prop_iter_state_init(iter);
        prop_iter_state_next(iter);

        return true;
}

bool archive_prop_iter_from_archive(prop_iter *iter, u16 mask,
                                        archive *archive)
{
        return archive_prop_iter_from_memblock(iter, mask, archive->record_table.record_db, 0);
}

bool archive_prop_iter_from_object(prop_iter *iter, u16 mask, const archive_object *obj)
{
        return archive_prop_iter_from_memblock(iter, mask, obj->memfile.memblock, obj->offset);
}

static enum archive_field_type get_basic_type(prop_iter_state_e state)
{
        switch (state) {
                case PROP_ITER_NULLS:
                case PROP_ITER_NULL_ARRAYS:
                        return ARCHIVE_FIELD_NULL;
                case PROP_ITER_BOOLS:
                case PROP_ITER_BOOL_ARRAYS:
                        return ARCHIVE_FIELD_BOOLEAN;
                case PROP_ITER_INT8S:
                case PROP_ITER_INT8_ARRAYS:
                        return ARCHIVE_FIELD_INT8;
                case PROP_ITER_INT16S:
                case PROP_ITER_INT16_ARRAYS:
                        return ARCHIVE_FIELD_INT16;
                case PROP_ITER_INT32S:
                case PROP_ITER_INT32_ARRAYS:
                        return ARCHIVE_FIELD_INT32;
                case PROP_ITER_INT64S:
                case PROP_ITER_INT64_ARRAYS:
                        return ARCHIVE_FIELD_INT64;
                case PROP_ITER_UINT8S:
                case PROP_ITER_UINT8_ARRAYS:
                        return ARCHIVE_FIELD_UINT8;
                case PROP_ITER_UINT16S:
                case PROP_ITER_UINT16_ARRAYS:
                        return ARCHIVE_FIELD_UINT16;
                case PROP_ITER_UINT32S:
                case PROP_ITER_UINT32_ARRAYS:
                        return ARCHIVE_FIELD_UINT32;
                case PROP_ITER_UINT64S:
                case PROP_ITER_UINT64_ARRAYS:
                        return ARCHIVE_FIELD_UINT64;
                case PROP_ITER_FLOATS:
                case PROP_ITER_FLOAT_ARRAYS:
                        return ARCHIVE_FIELD_FLOAT;
                case PROP_ITER_STRINGS:
                case PROP_ITER_STRING_ARRAYS:
                        return ARCHIVE_FIELD_STRING;
                case PROP_ITER_OBJECTS:
                case PROP_ITER_OBJECT_ARRAYS:
                        return ARCHIVE_FIELD_OBJECT;
                default: {
                        ERROR(ERR_INTERNALERR, NULL);
                        return ARCHIVE_FIELD_ERR;
                }
        }
}

static bool is_array_type(prop_iter_state_e state)
{
        switch (state) {
                case PROP_ITER_NULLS:
                case PROP_ITER_BOOLS:
                case PROP_ITER_INT8S:
                case PROP_ITER_INT16S:
                case PROP_ITER_INT32S:
                case PROP_ITER_INT64S:
                case PROP_ITER_UINT8S:
                case PROP_ITER_UINT16S:
                case PROP_ITER_UINT32S:
                case PROP_ITER_UINT64S:
                case PROP_ITER_FLOATS:
                case PROP_ITER_STRINGS:
                case PROP_ITER_OBJECTS:
                        return false;
                case PROP_ITER_NULL_ARRAYS:
                case PROP_ITER_BOOL_ARRAYS:
                case PROP_ITER_INT8_ARRAYS:
                case PROP_ITER_INT16_ARRAYS:
                case PROP_ITER_INT32_ARRAYS:
                case PROP_ITER_INT64_ARRAYS:
                case PROP_ITER_UINT8_ARRAYS:
                case PROP_ITER_UINT16_ARRAYS:
                case PROP_ITER_UINT32_ARRAYS:
                case PROP_ITER_UINT64_ARRAYS:
                case PROP_ITER_FLOAT_ARRAYS:
                case PROP_ITER_STRING_ARRAYS:
                case PROP_ITER_OBJECT_ARRAYS:
                        return true;
                default:
                        return ERROR(ERR_INTERNALERR, NULL);
        }
}

bool archive_prop_iter_next(prop_iter_mode_e *type, archive_value_vector *value_vector,
                                independent_iter_state *collection_iter, prop_iter *prop_iter)
{
        if (prop_iter->prop_cursor != PROP_ITER_DONE) {
                switch (prop_iter->mode) {
                        case PROP_ITER_MODE_OBJECT: {
                                value_vector->keys = prop_iter->mode_object.prop_group_header.keys;

                                prop_iter->mode_object.type = get_basic_type(prop_iter->prop_cursor);
                                prop_iter->mode_object.is_array = is_array_type(prop_iter->prop_cursor);

                                value_vector->value_max_idx = prop_iter->mode_object.prop_group_header.header->num_entries;
                                value_vector->prop_type = prop_iter->mode_object.type;
                                value_vector->is_array = prop_iter->mode_object.is_array;

                                if (value_vector
                                    && !archive_value_vec_from_prop_iter(value_vector, prop_iter)) {
                                        ERROR(ERR_VITEROPEN_FAILED, NULL);
                                        return false;
                                }
                        }
                                break;
                        case PROP_ITER_MODE_COLLECTION: {
                                collection_iter->state = prop_iter->mode_collection;
                                MEMFILE_OPEN(&collection_iter->record_table_memfile,
                                             prop_iter->record_table_memfile.memblock,
                                             READ_ONLY);
                        } break;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                return false;
                }
                *type = prop_iter->mode;
                prop_iter_state_next(prop_iter);
                return true;
        } else {
                return false;
        }
}

const archive_field_sid_t *
archive_collection_iter_get_keys(u32 *num_keys, independent_iter_state *iter)
{
        if (num_keys && iter) {
                *num_keys = iter->state.num_column_groups;
                return iter->state.column_group_keys;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool archive_collection_next_column_group(independent_iter_state *group_iter,
                                              independent_iter_state *iter)
{
        if (iter->state.current_column_group_idx < iter->state.num_column_groups) {
                collection_iter_read_next_column_group(&iter->state, &iter->record_table_memfile);
                MEMFILE_OPEN(&group_iter->record_table_memfile, iter->record_table_memfile.memblock, READ_ONLY);
                group_iter->state = iter->state;
                return true;
        } else {
                return false;
        }
}

const unique_id_t *
archive_column_group_get_object_ids(u32 *num_objects, independent_iter_state *iter)
{
        if (num_objects && iter) {
                *num_objects = iter->state.current_column_group.num_objects;
                return iter->state.current_column_group.object_ids;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool archive_column_group_next_column(independent_iter_state *column_iter,
                                          independent_iter_state *iter)
{
        if (iter->state.current_column_group.current_column.idx < iter->state.current_column_group.num_columns) {
                prop_iter_read_column(&iter->state, &iter->record_table_memfile);
                MEMFILE_OPEN(&column_iter->record_table_memfile, iter->record_table_memfile.memblock, READ_ONLY);
                column_iter->state = iter->state;
                return true;
        } else {
                return false;
        }
}

bool archive_column_get_name(archive_field_sid_t *name, enum archive_field_type *type,
                                 independent_iter_state *column_iter)
{
        OPTIONAL_SET(name, column_iter->state.current_column_group.current_column.name)
        OPTIONAL_SET(type, column_iter->state.current_column_group.current_column.type)
        return true;
}

const u32 *
archive_column_get_entry_positions(u32 *num_entry, independent_iter_state *column_iter)
{
        if (num_entry && column_iter) {
                *num_entry = column_iter->state.current_column_group.current_column.num_elem;
                return column_iter->state.current_column_group.current_column.elem_positions;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool
archive_column_next_entry(independent_iter_state *entry_iter, independent_iter_state *iter)
{
        if (iter->state.current_column_group.current_column.current_entry.idx
            < iter->state.current_column_group.current_column.num_elem) {
                prop_iter_read_colum_entry(&iter->state, &iter->record_table_memfile);
                MEMFILE_OPEN(&entry_iter->record_table_memfile, iter->record_table_memfile.memblock, READ_ONLY);
                entry_iter->state = iter->state;
                return true;
        } else {
                return false;
        }
}

bool archive_column_entry_get_type(enum archive_field_type *type, independent_iter_state *entry)
{
        *type = entry->state.current_column_group.current_column.type;
        return true;
}

#define DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(built_in_type, name, basic_type)                            \
const built_in_type *                                                                                   \
archive_column_entry_get_##name(u32 *array_length, independent_iter_state *entry)              \
{                                                                                                                      \
    if (array_length && entry) {                                                                                       \
        if (entry->state.current_column_group.current_column.type == basic_type)                                       \
        {                                                                                                              \
            *array_length =  entry->state.current_column_group.current_column.current_entry.array_length;              \
            return (const built_in_type *) entry->state.current_column_group.current_column.current_entry.array_base;  \
        } else {                                                                                                       \
            ERROR(ERR_TYPEMISMATCH, NULL);                                                        \
            return NULL;                                                                                               \
        }                                                                                                              \
    } else {                                                                                                           \
        ERROR(ERR_NULLPTR, NULL);                                                                 \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i8_t, int8s, ARCHIVE_FIELD_INT8);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i16_t, int16s, ARCHIVE_FIELD_INT16);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i32_t, int32s, ARCHIVE_FIELD_INT32);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i64_t, int64s, ARCHIVE_FIELD_INT64);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u8_t, uint8s, ARCHIVE_FIELD_UINT8);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u16_t, uint16s, ARCHIVE_FIELD_UINT16);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u32_t, uint32s, ARCHIVE_FIELD_UINT32);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u64_t, uint64s, ARCHIVE_FIELD_UINT64);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_sid_t, strings, ARCHIVE_FIELD_STRING);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_number_t, numbers, ARCHIVE_FIELD_FLOAT);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_boolean_t, booleans, ARCHIVE_FIELD_BOOLEAN);

DECLARE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u32_t, nulls, ARCHIVE_FIELD_NULL);

bool archive_column_entry_get_objects(column_object_iter *iter, independent_iter_state *entry)
{
        iter->entry_state = entry->state;
        MEMFILE_OPEN(&iter->memfile, entry->record_table_memfile.memblock, READ_ONLY);
        MEMFILE_SEEK(&iter->memfile,
                     entry->state.current_column_group.current_column.elem_offsets[
                             entry->state.current_column_group.current_column.current_entry.idx - 1] + sizeof(u32));
        iter->next_obj_off = MEMFILE_TELL(&iter->memfile);
        return true;
}

const archive_object *archive_column_entry_object_iter_next_object(column_object_iter *iter)
{
        if (iter) {
                if (iter->next_obj_off != 0) {
                        MEMFILE_SEEK(&iter->memfile, iter->next_obj_off);
                        if (init_object_from_memfile(&iter->obj, &iter->memfile)) {
                                iter->next_obj_off = iter->obj.next_obj_off;
                                return &iter->obj;
                        } else {
                                ERROR(ERR_INTERNALERR, NULL);
                                return NULL;
                        }
                } else {
                        return NULL;
                }
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool archive_object_get_object_id(unique_id_t *id, const archive_object *object)
{
        *id = object->object_id;
        return true;
}

bool archive_object_get_prop_iter(prop_iter *iter, const archive_object *object)
{
        UNUSED(iter);
        UNUSED(object);
        return false;
}

bool archive_value_vec_get_object_id(unique_id_t *id, const archive_value_vector *iter)
{
        *id = iter->object_id;
        return true;
}

const archive_field_sid_t *
archive_value_vec_get_keys(u32 *num_keys, archive_value_vector *iter)
{
        if (num_keys && iter) {
                *num_keys = iter->value_max_idx;
                return iter->keys;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

static void value_vec_init_object_basic(archive_value_vector *value)
{
        value->data.object.offsets =
                MEMFILE_READ_TYPE_LIST(&value->record_table_memfile, offset_t, value->value_max_idx);
}

static bool value_vec_init_fixed_length_types_basic(archive_value_vector *value)
{
        assert(!value->is_array);

        switch (value->prop_type) {
                case ARCHIVE_FIELD_INT8:
                        value->data.basic.values.int8s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                          archive_field_i8_t);
                        break;
                case ARCHIVE_FIELD_INT16:
                        value->data.basic.values.int16s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                           archive_field_i16_t);
                        break;
                case ARCHIVE_FIELD_INT32:
                        value->data.basic.values.int32s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                           archive_field_i32_t);
                        break;
                case ARCHIVE_FIELD_INT64:
                        value->data.basic.values.int64s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                           archive_field_i64_t);
                        break;
                case ARCHIVE_FIELD_UINT8:
                        value->data.basic.values.uint8s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                           archive_field_u8_t);
                        break;
                case ARCHIVE_FIELD_UINT16:
                        value->data.basic.values.uint16s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                            archive_field_u16_t);
                        break;
                case ARCHIVE_FIELD_UINT32:
                        value->data.basic.values.uint32s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                            archive_field_u32_t);
                        break;
                case ARCHIVE_FIELD_UINT64:
                        value->data.basic.values.uint64s = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                            archive_field_u64_t);
                        break;
                case ARCHIVE_FIELD_FLOAT:
                        value->data.basic.values.numbers = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                            archive_field_number_t);
                        break;
                case ARCHIVE_FIELD_STRING:
                        value->data.basic.values.strings = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                            archive_field_sid_t);
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                        value->data.basic.values.booleans = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                             archive_field_boolean_t);
                        break;
                default: {
                        ERROR(ERR_INTERNALERR, NULL);
                        return false;
                }
        }
        return true;
}

static void value_vec_init_fixed_length_types_null_arrays(archive_value_vector *value)
{
        assert(value->is_array);
        assert(value->prop_type == ARCHIVE_FIELD_NULL);
        value->data.arrays.meta.num_nulls_contained =
                MEMFILE_READ_TYPE_LIST(&value->record_table_memfile, u32, value->value_max_idx);
}

static bool value_vec_init_fixed_length_types_non_null_arrays(archive_value_vector *value)
{
        assert (value->is_array);

        value->data.arrays.meta.array_lengths =
                MEMFILE_READ_TYPE_LIST(&value->record_table_memfile, u32, value->value_max_idx);

        switch (value->prop_type) {
                case ARCHIVE_FIELD_INT8:
                        value->data.arrays.values.int8s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                archive_field_i8_t);
                        break;
                case ARCHIVE_FIELD_INT16:
                        value->data.arrays.values.int16s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                 archive_field_i16_t);
                        break;
                case ARCHIVE_FIELD_INT32:
                        value->data.arrays.values.int32s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                 archive_field_i32_t);
                        break;
                case ARCHIVE_FIELD_INT64:
                        value->data.arrays.values.int64s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                 archive_field_i64_t);
                        break;
                case ARCHIVE_FIELD_UINT8:
                        value->data.arrays.values.uint8s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                 archive_field_u8_t);
                        break;
                case ARCHIVE_FIELD_UINT16:
                        value->data.arrays.values.uint16s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                  archive_field_u16_t);
                        break;
                case ARCHIVE_FIELD_UINT32:
                        value->data.arrays.values.uint32s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                  archive_field_u32_t);
                        break;
                case ARCHIVE_FIELD_UINT64:
                        value->data.arrays.values.uint64s_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                  archive_field_u64_t);
                        break;
                case ARCHIVE_FIELD_FLOAT:
                        value->data.arrays.values.numbers_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                  archive_field_number_t);
                        break;
                case ARCHIVE_FIELD_STRING:
                        value->data.arrays.values.strings_base = MEMFILE_PEEK_TYPE(&value->record_table_memfile,
                                                                                  archive_field_sid_t);
                        break;
                case ARCHIVE_FIELD_BOOLEAN:
                        value->data.arrays.values.booleans_base =
                                MEMFILE_PEEK_TYPE(&value->record_table_memfile, archive_field_boolean_t);
                        break;
                default: {
                        ERROR(ERR_INTERNALERR, NULL);
                        return false;
                }
        }
        return true;
}

static void value_vec_init_fixed_length_types(archive_value_vector *value)
{
        if (value->is_array) {
                value_vec_init_fixed_length_types_non_null_arrays(value);
        } else {
                value_vec_init_fixed_length_types_basic(value);
        }
}

static void value_vec_init_object(archive_value_vector *value)
{
        if (value->is_array) {
                //value_vec_init_object_array(value);
        } else {
                value_vec_init_object_basic(value);
        }
}

bool archive_value_vec_from_prop_iter(archive_value_vector *value, prop_iter *prop_iter)
{
        if (prop_iter->mode != PROP_ITER_MODE_OBJECT) {
                return ERROR(ERR_ITER_OBJECT_NEEDED, NULL);
        }
        value->prop_iter = prop_iter;
        value->data_off = prop_iter->mode_object.prop_data_off;
        value->object_id = prop_iter->object.object_id;

        MEMFILE_OPEN(&value->record_table_memfile, prop_iter->record_table_memfile.memblock, READ_ONLY);
        if (!MEMFILE_SKIP(&value->record_table_memfile, value->data_off)) {
                return ERROR(ERR_MEMFILESKIP_FAILED, NULL);
        }

        value->prop_type = prop_iter->mode_object.type;
        value->is_array = prop_iter->mode_object.is_array;
        value->value_max_idx = prop_iter->mode_object.prop_group_header.header->num_entries;

        switch (value->prop_type) {
                case ARCHIVE_FIELD_OBJECT:
                        value_vec_init_object(value);
                        break;
                case ARCHIVE_FIELD_NULL:
                        if (value->is_array) {
                                value_vec_init_fixed_length_types_null_arrays(value);
                        }
                        break;
                case ARCHIVE_FIELD_INT8:
                case ARCHIVE_FIELD_INT16:
                case ARCHIVE_FIELD_INT32:
                case ARCHIVE_FIELD_INT64:
                case ARCHIVE_FIELD_UINT8:
                case ARCHIVE_FIELD_UINT16:
                case ARCHIVE_FIELD_UINT32:
                case ARCHIVE_FIELD_UINT64:
                case ARCHIVE_FIELD_FLOAT:
                case ARCHIVE_FIELD_STRING:
                case ARCHIVE_FIELD_BOOLEAN:
                        value_vec_init_fixed_length_types(value);
                        break;
                default: {
                        ERROR(ERR_INTERNALERR, NULL);
                        return false;
                }
        }

        return true;
}

bool archive_value_vec_get_basic_type(enum archive_field_type *type,
                                                 const archive_value_vector *value)
{
        *type = value->prop_type;
        return true;
}

bool archive_value_vec_is_array_type(bool *is_array, const archive_value_vector *value)
{
        *is_array = value->is_array;
        return true;
}

bool archive_value_vec_get_length(u32 *length, const archive_value_vector *value)
{
        *length = value->value_max_idx;
        return true;
}

bool archive_value_vec_is_of_objects(bool *is_object, archive_value_vector *value)
{
        *is_object = value->prop_type == ARCHIVE_FIELD_OBJECT && !value->is_array;
        return true;
}

bool archive_value_vec_get_object_at(archive_object *object, u32 idx,
                                                archive_value_vector *value)
{
        if (idx >= value->value_max_idx) {
                return ERROR(ERR_OUTOFBOUNDS, NULL);
        }

        bool is_object;

        archive_value_vec_is_of_objects(&is_object, value);

        if (is_object) {
                MEMFILE_SEEK(&value->record_table_memfile, value->data.object.offsets[idx]);
                init_object_from_memfile(&value->data.object.object, &value->record_table_memfile);
                *object = value->data.object.object;
                return true;
        } else {
                return ERROR(ERR_ITER_NOOBJ, NULL);
        }
}

#define DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(name, basic_type)                                            \
bool                                                                                                    \
archive_value_vec_is_##name(bool *type_match, archive_value_vector *value)                          \
{                                                                                                                      \
    *type_match = value->prop_type == basic_type;                                                                      \
    return true;                                                                                                       \
}

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(int8, ARCHIVE_FIELD_INT8)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(int16, ARCHIVE_FIELD_INT16)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(int32, ARCHIVE_FIELD_INT32)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(int64, ARCHIVE_FIELD_INT64)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(uint8, ARCHIVE_FIELD_UINT8)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(uint16, ARCHIVE_FIELD_UINT16)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(uint32, ARCHIVE_FIELD_UINT32)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(uint64, ARCHIVE_FIELD_UINT64)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(string, ARCHIVE_FIELD_STRING)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(number, ARCHIVE_FIELD_FLOAT)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(boolean, ARCHIVE_FIELD_BOOLEAN)

DECLARE_ARCHIVE_VALUE_VEC_IS_BASIC_TYPE(null, ARCHIVE_FIELD_NULL)

#define DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(names, name, built_in_type, err_code)                       \
const built_in_type *                                                                                   \
archive_value_vec_get_##names(u32 *num_values, archive_value_vector *value)                    \
{                                                                                                                      \
    bool is_array;                                                                                                     \
    bool type_match;                                                                                                   \
                                                                                                                       \
    if (archive_value_vec_is_array_type(&is_array, value) &&                                                 \
        archive_value_vec_is_##name(&type_match, value) && !is_array)                                        \
    {                                                                                                                  \
        OPTIONAL_SET(num_values, value->value_max_idx)                                                          \
        return value->data.basic.values.names;                                                                         \
    } else                                                                                                             \
    {                                                                                                                  \
        ERROR(err_code, NULL);                                                                           \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(int8s, int8, archive_field_i8_t, ERR_ITER_NOINT8)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(int16s, int16, archive_field_i16_t, ERR_ITER_NOINT16)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(int32s, int32, archive_field_i32_t, ERR_ITER_NOINT32)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(int64s, int64, archive_field_i64_t, ERR_ITER_NOINT64)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(uint8s, uint8, archive_field_u8_t, ERR_ITER_NOUINT8)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(uint16s, uint16, archive_field_u16_t, ERR_ITER_NOUINT16)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(uint32s, uint32, archive_field_u32_t, ERR_ITER_NOUINT32)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(uint64s, uint64, archive_field_u64_t, ERR_ITER_NOUINT64)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(strings, string, archive_field_sid_t, ERR_ITER_NOSTRING)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(numbers, number, archive_field_number_t, ERR_ITER_NONUMBER)

DECLARE_ARCHIVE_VALUE_VEC_GET_BASIC_TYPE(booleans, boolean, archive_field_boolean_t, ERR_ITER_NOBOOL)

const archive_field_u32_t *
archive_value_vec_get_null_arrays(u32 *num_values, archive_value_vector *value)
{
        bool is_array;
        bool type_match;

        if (archive_value_vec_is_array_type(&is_array, value) &&
            archive_value_vec_is_null(&type_match, value)
            && is_array) {
                OPTIONAL_SET(num_values, value->value_max_idx);
                return value->data.arrays.meta.num_nulls_contained;
        } else {
                return NULL;
        }
}

#define DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(name, built_in_type, base)                               \
const built_in_type *                                                                                   \
archive_value_vec_get_##name##_arrays_at(u32 *array_length, u32 idx,                               \
                                               archive_value_vector *value)                                   \
{                                                                                                                      \
    bool is_array;                                                                                                     \
    bool type_match;                                                                                                   \
                                                                                                                       \
    if (idx < value->value_max_idx && archive_value_vec_is_array_type(&is_array, value) &&                   \
        archive_value_vec_is_##name(&type_match, value) && is_array)                                         \
    {                                                                                                                  \
        u32 skip_length = 0;                                                                                      \
        for (u32 i = 0; i < idx; i++) {                                                                           \
            skip_length += value->data.arrays.meta.array_lengths[i];                                                   \
        }                                                                                                              \
        *array_length = value->data.arrays.meta.array_lengths[idx];                                                    \
        return value->data.arrays.values.base + skip_length;                                                           \
    } else                                                                                                             \
    {                                                                                                                  \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(int8, archive_field_i8_t, int8s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(int16, archive_field_i16_t, int16s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(int32, archive_field_i32_t, int32s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(int64, archive_field_i64_t, int64s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(uint8, archive_field_u8_t, uint8s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(uint16, archive_field_u16_t, uint16s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(uint32, archive_field_u32_t, uint32s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(uint64, archive_field_u64_t, uint64s_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(string, archive_field_sid_t, strings_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(number, archive_field_number_t, numbers_base)

DECLARE_ARCHIVE_VALUE_VEC_GET_ARRAY_TYPE_AT(boolean, archive_field_boolean_t, booleans_base)

void archive_int_reset_obj_it_mem_file(archive_object *object)
{
        UNUSED(object);
        //  MEMFILE_SEEK(&object->file, object->self);
        abort();
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/archive/pack.h>

static bool create_strategy(size_t i, packer *strategy)
{
        assert(strategy);
        global_pack_strategy_register[i].create(strategy);
        assert (strategy->create);
        assert (strategy->cpy);
        assert (strategy->drop);
        assert (strategy->write_extra);
        assert (strategy->encode_string);
        assert (strategy->decode_string);
        assert (strategy->print_extra);
        return strategy->create(strategy);
}

bool pack_by_type(packer *strategy, packer_e type)
{
        for (size_t i = 0; i < ARRAY_LENGTH(global_pack_strategy_register); i++) {
                if (global_pack_strategy_register[i].type == type) {
                        return create_strategy(i, strategy);
                }
        }
        return ERROR(ERR_NOCOMPRESSOR, NULL);
}

u8 pack_flagbit_by_type(packer_e type)
{
        for (size_t i = 0; i < ARRAY_LENGTH(global_pack_strategy_register); i++) {
                if (global_pack_strategy_register[i].type == type) {
                        return global_pack_strategy_register[i].flag_bit;
                }
        }
        return 0;
}

bool pack_by_flags(packer *strategy, u8 flags)
{
        for (size_t i = 0; i < ARRAY_LENGTH(global_pack_strategy_register); i++) {
                if (global_pack_strategy_register[i].flag_bit & flags) {
                        return create_strategy(i, strategy);
                }
        }
        return false;
}

bool pack_by_name(packer_e *type, const char *name)
{
        for (size_t i = 0; i < ARRAY_LENGTH(global_pack_strategy_register); i++) {
                if (strcmp(global_pack_strategy_register[i].name, name) == 0) {
                        *type = global_pack_strategy_register[i].type;
                        return true;
                }
        }
        return false;
}

bool pack_cpy(packer *dst, const packer *src)
{
        ERROR_IF_NOT_IMPLEMENTED(err, src, cpy)
        return src->cpy(src, dst);
}

bool pack_drop(packer *self)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, drop)
        return self->drop(self);
}

bool pack_write_extra(packer *self, memfile *dst,
                      const vec ofType (const char *) *strings)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, write_extra)
        return self->write_extra(self, dst, strings);
}

bool pack_read_extra(packer *self, FILE *src, size_t nbytes)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, read_extra)
        return self->read_extra(self, src, nbytes);
}

bool pack_encode(packer *self, memfile *dst, const char *string)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, encode_string)
        return self->encode_string(self, dst, string);
}

bool pack_decode(packer *self, char *dst, size_t strlen, FILE *src)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, decode_string)
        return self->decode_string(self, dst, strlen, src);
}

bool pack_print_extra(packer *self, FILE *file, memfile *src)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, print_extra)
        return self->print_extra(self, file, src);
}

bool pack_print_encoded(packer *self, FILE *file, memfile *src,
                        u32 decompressed_strlen)
{
        ERROR_IF_NOT_IMPLEMENTED(err, self, print_encoded)
        return self->print_encoded(self, file, src, decompressed_strlen);
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <limits.h>
#include <inttypes.h>

#include <karbonit/archive/huffman.h>
#include <karbonit/std/bitmap.h>

struct huff_node {
        struct huff_node *prev, *next, *left, *right;
        u64 freq;
        unsigned char letter;
};

static void huff_tree_create(vec ofType(pack_huffman_entry) *table,
                             const vec ofType(u32) *frequencies);

bool coding_huffman_create(huffman *dic)
{
        vec_create(&dic->table, sizeof(pack_huffman_entry), UCHAR_MAX / 4);
        return true;
}

bool coding_huffman_cpy(huffman *dst, huffman *src)
{
        if (!vec_cpy(&dst->table, &src->table)) {
                ERROR(ERR_HARDCOPYFAILED, NULL);
                return false;
        } else {
                return true;
        }
}

bool coding_huffman_build(huffman *encoder, const string_vec_t *strings)
{
        vec ofType(u32) frequencies;
        vec_create(&frequencies, sizeof(u32), UCHAR_MAX);
        vec_enlarge_size_to_capacity(&frequencies);

        u32 *freq_data = VEC_ALL(&frequencies, u32);
        ZERO_MEMORY(freq_data, UCHAR_MAX * sizeof(u32));

        for (size_t i = 0; i < strings->num_elems; i++) {
                const char *string = *VEC_GET(strings, i, const char *);
                size_t string_length = strlen(string);
                for (size_t k = 0; k < string_length; k++) {
                        size_t c = (unsigned char) string[k];
                        freq_data[c]++;
                }
        }

        huff_tree_create(&encoder->table, &frequencies);
        vec_drop(&frequencies);

        return true;
}

bool coding_huffman_drop(huffman *dic)
{
        for (size_t i = 0; i < dic->table.num_elems; i++) {
                pack_huffman_entry *entry = VEC_GET(&dic->table, i, pack_huffman_entry);
                free(entry->blocks);
        }

        vec_drop(&dic->table);

        free(dic);

        return true;
}

bool coding_huffman_serialize(memfile *file, const huffman *dic, char marker_symbol)
{
        for (size_t i = 0; i < dic->table.num_elems; i++) {
                pack_huffman_entry *entry = VEC_GET(&dic->table, i, pack_huffman_entry);
                MEMFILE_WRITE(file, &marker_symbol, sizeof(char));
                MEMFILE_WRITE(file, &entry->letter, sizeof(unsigned char));

                /** block one is the block that holds the significant part of the prefix code */
                offset_t offset_meta, offset_continue;
                MEMFILE_GET_OFFSET(&offset_meta, file);
                /** this will be the number of bytes used to encode the significant part of the prefix code */
                MEMFILE_SKIP(file, sizeof(u8));

                MEMFILE_BEGIN_BIT_MODE(file);
                bool first_bit_found = false;
                for (int i = 31; entry->blocks && i >= 0; i--) {
                        u32 mask = 1 << i;
                        u32 k = entry->blocks[0] & mask;
                        bool bit_state = k != 0;
                        first_bit_found |= bit_state;

                        if (first_bit_found) {
                                memfile_write_bit(file, bit_state);
                        }
                }
                size_t num_bytes_written;
                MEMFILE_END_BIT_MODE(&num_bytes_written, file);
                MEMFILE_GET_OFFSET(&offset_continue, file);
                MEMFILE_SEEK(file, offset_meta);
                u8 num_bytes_written_uint8 = (u8) num_bytes_written;
                MEMFILE_WRITE(file, &num_bytes_written_uint8, sizeof(u8));

                MEMFILE_SEEK(file, offset_continue);
        }

        return true;
}

static pack_huffman_entry *find_dic_entry(huffman *dic, unsigned char c)
{
        for (size_t i = 0; i < dic->table.num_elems; i++) {
                pack_huffman_entry *entry = VEC_GET(&dic->table, i, pack_huffman_entry);
                if (entry->letter == c) {
                        return entry;
                }
        }
        ERROR(ERR_HUFFERR, NULL);
        return NULL;
}

static size_t encodeString(memfile *file, huffman *dic, const char *string)
{
        MEMFILE_BEGIN_BIT_MODE(file);

        for (const char *c = string; *c != '\0'; c++) {
                pack_huffman_entry *entry = find_dic_entry(dic, (unsigned char) *c);
                if (!entry) {
                        return 0;
                }

                if (!entry->blocks) {
                        memfile_write_bit(file, false);
                } else {
                        for (size_t j = 0; j < entry->nblocks; j++) {
                                u32 block = entry->blocks[j];

                                bool first_bit_found = false;
                                for (int i = 31; i >= 0; i--) {
                                        u32 mask = 1 << i;
                                        u32 k = block & mask;
                                        bool bit_state = k != 0;
                                        first_bit_found |= bit_state;

                                        if (first_bit_found) {
                                                memfile_write_bit(file, bit_state);
                                        }
                                }
                        }
                }
        }

        size_t num_written_bytes;
        MEMFILE_END_BIT_MODE(&num_written_bytes, file);
        return num_written_bytes;
}

bool coding_huffman_encode(memfile *file, huffman *dic, const char *string)
{
        u32 num_bytes_encoded = 0;

        offset_t num_bytes_encoded_off = MEMFILE_TELL(file);
        MEMFILE_SKIP(file, sizeof(u32));

        if ((num_bytes_encoded = (u32) encodeString(file, dic, string)) == 0) {
                return false;
        }

        offset_t continue_off = MEMFILE_TELL(file);
        MEMFILE_SEEK(file, num_bytes_encoded_off);
        MEMFILE_WRITE(file, &num_bytes_encoded, sizeof(u32));
        MEMFILE_SEEK(file, continue_off);

        return true;
}

bool coding_huffman_read_string(pack_huffman_str_info *info, memfile *src)
{
        info->nbytes_encoded = *MEMFILE_READ_TYPE(src, u32);
        info->encoded_bytes = MEMFILE_READ(src, info->nbytes_encoded);
        return true;
}

bool coding_huffman_read_entry(pack_huffman_info *info, memfile *file, char marker_symbol)
{
        char marker = *MEMFILE_PEEK_TYPE(file, char);
        if (marker == marker_symbol) {
                MEMFILE_SKIP(file, sizeof(char));
                info->letter = *MEMFILE_READ_TYPE(file, unsigned char);
                info->nbytes_prefix = *MEMFILE_READ_TYPE(file, u8);
                info->prefix_code = MEMFILE_PEEK_TYPE(file, char);

                MEMFILE_SKIP(file, info->nbytes_prefix);

                return true;
        } else {
                return false;
        }
}

static const u32 *get_num_used_blocks(u16 *numUsedBlocks, pack_huffman_entry *entry, u16 num_blocks,
                                          const u32 *blocks)
{
        for (entry->nblocks = 0; entry->nblocks < num_blocks; entry->nblocks++) {
                const u32 *block = blocks + entry->nblocks;
                if (*block != 0) {
                        *numUsedBlocks = (num_blocks - entry->nblocks);
                        return block;
                }
        }
        return NULL;
}

static void
import_into_entry(pack_huffman_entry *entry, const struct huff_node *node, const bitmap *map)
{
        entry->letter = node->letter;
        u32 *blocks, num_blocks;
        const u32 *used_blocks;
        bitmap_blocks(&blocks, &num_blocks, map);
        used_blocks = get_num_used_blocks(&entry->nblocks, entry, num_blocks, blocks);
        entry->blocks = MALLOC(entry->nblocks * sizeof(u32));
        if (num_blocks > 0) {
                memcpy(entry->blocks, used_blocks, entry->nblocks * sizeof(u32));
        } else {
                entry->blocks = NULL;
        }
        free(blocks);
}

static struct huff_node *seek_to_begin(struct huff_node *handle)
{
        for (; handle->prev != NULL; handle = handle->prev) {}
        return handle;
}

static struct huff_node *seek_to_end(struct huff_node *handle)
{
        for (; handle->next != NULL; handle = handle->next) {}
        return handle;
}

MAYBE_UNUSED
static void __diag_print_insight(struct huff_node *n)
{
        printf("(");
        if (!n->left && !n->right) {
                printf("%c", n->letter);
        } else {
                if (n->left) {
                        __diag_print_insight(n->left);
                }
                printf(",");
                if (n->right) {
                        __diag_print_insight(n->right);
                }
        }
        printf(")");
        printf(": %"PRIu64"", n->freq);
}

MAYBE_UNUSED
static void __diag_dump_remaining_candidates(struct huff_node *n)
{
        struct huff_node *it = seek_to_begin(n);
        while (it->next != NULL) {
                __diag_print_insight(it);
                printf(" | ");
                it = it->next;
        }
}

static struct huff_node *find_smallest(struct huff_node *begin, u64 lowerBound, struct huff_node *skip)
{
        u64 smallest = UINT64_MAX;
        struct huff_node *result = NULL;
        for (struct huff_node *it = begin; it != NULL; it = it->next) {
                if (it != skip && it->freq >= lowerBound && it->freq <= smallest) {
                        smallest = it->freq;
                        result = it;
                }
        }
        return result;
}

static void assign_code(struct huff_node *node, const bitmap *path,
                        vec ofType(pack_huffman_entry) *table)
{
        if (!node->left && !node->right) {
                pack_huffman_entry *entry = VEC_NEW_AND_GET(table, pack_huffman_entry);
                import_into_entry(entry, node, path);
        } else {
                if (node->left) {
                        bitmap left;
                        bitmap_cpy(&left, path);
                        bitmap_lshift(&left);
                        bitmap_set(&left, 0, false);
                        assign_code(node->left, &left, table);
                        bitmap_drop(&left);
                }
                if (node->right) {
                        bitmap right;
                        bitmap_cpy(&right, path);
                        bitmap_lshift(&right);
                        bitmap_set(&right, 0, true);
                        assign_code(node->right, &right, table);
                        bitmap_drop(&right);
                }
        }
}

static struct huff_node *trim_and_begin(vec ofType(HuffNode) *candidates)
{
        struct huff_node *begin = NULL;
        for (struct huff_node *it = VEC_GET(candidates, 0, struct huff_node);; it++) {
                if (it->freq == 0) {
                        if (it->prev) {
                                it->prev->next = it->next;
                        }
                        if (it->next) {
                                it->next->prev = it->prev;
                        }
                } else {
                        if (!begin) {
                                begin = it;
                        }
                }
                if (!it->next) {
                        break;
                }
        }
        return begin;
}

static void huff_tree_create(vec ofType(pack_huffman_entry) *table,
                             const vec ofType(u32) *frequencies)
{
        assert(UCHAR_MAX == frequencies->num_elems);

        vec ofType(HuffNode) candidates;
        vec_create(&candidates, sizeof(struct huff_node), UCHAR_MAX * UCHAR_MAX);
        size_t appender_idx = UCHAR_MAX;

        for (unsigned char i = 0; i < UCHAR_MAX; i++) {
                struct huff_node *node = VEC_NEW_AND_GET(&candidates, struct huff_node);
                node->letter = i;
                node->freq = *VEC_GET(frequencies, i, u32);
        }

        for (unsigned char i = 0; i < UCHAR_MAX; i++) {
                struct huff_node *node = VEC_GET(&candidates, i, struct huff_node);
                struct huff_node *prev = i > 0 ? VEC_GET(&candidates, i - 1, struct huff_node) : NULL;
                struct huff_node *next = i + 1 < UCHAR_MAX ? VEC_GET(&candidates, i + 1, struct huff_node) : NULL;
                node->next = next;
                node->prev = prev;
                node->left = node->right = NULL;
        }

        struct huff_node *smallest, *small;
        struct huff_node *handle = trim_and_begin(&candidates);
        struct huff_node *new_node = NULL;

        while (handle->next != NULL) {
                smallest = find_smallest(handle, 0, NULL);
                small = find_smallest(handle, smallest->freq, smallest);

                appender_idx++;
                new_node = VEC_NEW_AND_GET(&candidates, struct huff_node);
                new_node->freq = small->freq + smallest->freq;
                new_node->letter = '\0';
                new_node->left = small;
                new_node->right = smallest;

                if ((small->prev == NULL && smallest->next == NULL) && small->next == smallest) {
                        break;
                }

                if ((smallest->prev == NULL && small->next == NULL) && smallest->next == small) {
                        break;
                }
                if (smallest->prev) {
                        smallest->prev->next = smallest->next;
                }
                if (smallest->next) {
                        smallest->next->prev = smallest->prev;
                }
                if (small->prev) {
                        small->prev->next = small->next;
                }
                if (small->next) {
                        small->next->prev = small->prev;
                }

                if (small->prev) {
                        handle = seek_to_begin(small->prev);
                } else if (smallest->prev) {
                        handle = seek_to_begin(smallest->prev);
                } else if (small->next) {
                        handle = seek_to_begin(small->next);
                } else if (smallest->next) {
                        handle = seek_to_begin(smallest->next);
                } else {
                        PANIC(ERR_INTERNALERR);
                }

                assert (!handle->prev);
                struct huff_node *end = seek_to_end(handle);
                assert(!end->next);
                end->next = new_node;
                new_node->prev = end;
                new_node->next = NULL;

#ifdef DIAG_HUFFMAN_ENABLE_DEBUG
                printf("in-memory huff-tree: ");
                __diag_print_insight(new_node);
                printf("\n");
                printf("remaining candidates: ");
                __diag_dump_remaining_candidates(handle);
                printf("\n");
#endif
        }

        seek_to_begin(handle);
        if (handle->next) {
                struct huff_node *finalNode = VEC_NEW_AND_GET(&candidates, struct huff_node);
                finalNode->freq = small->freq + smallest->freq;
                finalNode->letter = '\0';
                if (handle->freq > handle->next->freq) {
                        finalNode->left = handle;
                        finalNode->right = handle->next;
                } else {
                        finalNode->left = handle->next;
                        finalNode->right = handle;
                }
                new_node = finalNode;
        }

#ifdef DIAG_HUFFMAN_ENABLE_DEBUG
        printf("final in-memory huff-tree: ");
        __diag_print_insight(new_node);
        printf("\n");
#endif

        bitmap root_path;
        bitmap_create(&root_path, UCHAR_MAX);
        bitmap_set(&root_path, 0, true);
        assign_code(new_node, &root_path, table);
        bitmap_drop(&root_path);

        vec_drop(&candidates);
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <karbonit/archive/pack.h>
#include <karbonit/archive/pack/none.h>

bool pack_none_init(packer *self)
{
        UNUSED(self);
        /** nothing to do for uncompressed dictionaries */
        return true;
}

bool pack_none_cpy(const packer *self, packer *dst)
{
        /** nothing to hard copy but the function pointers */
        *dst = *self;
        return true;
}

bool pack_none_drop(packer *self)
{
        UNUSED(self);
        /** nothing to do for uncompressed dictionaries */
        return true;
}

bool pack_none_write_extra(packer *self, memfile *dst,
                           const vec ofType (const char *) *strings)
{
        UNUSED(self);
        UNUSED(dst);
        UNUSED(strings);
        /** nothing to do for uncompressed dictionaries */
        return true;
}

bool pack_none_read_extra(packer *self, FILE *src, size_t nbytes)
{
        UNUSED(self);
        UNUSED(src);
        UNUSED(nbytes);
        /** nothing to do for uncompressed dictionaries */
        return true;
}

bool pack_none_print_extra(packer *self, FILE *file, memfile *src)
{
        UNUSED(self);
        UNUSED(file);
        UNUSED(src);
        /** nothing to do for uncompressed dictionaries */
        return true;
}

bool pack_none_print_encoded_string(packer *self, FILE *file, memfile *src,
                                    u32 decompressed_strlen)
{
        UNUSED(self);

        const char *string = MEMFILE_READ(src, decompressed_strlen);

        char *printableString = MALLOC(decompressed_strlen + 1);
        memcpy(printableString, string, decompressed_strlen);
        printableString[decompressed_strlen] = '\0';

        fprintf(file, "[str_buf: %s]", printableString);

        free(printableString);

        return true;
}

bool pack_none_encode_string(packer *self, memfile *dst, const char *string)
{
        UNUSED(self);

        u32 string_length = strlen(string);

        MEMFILE_WRITE(dst, string, string_length);

        return true;
}

bool pack_none_decode_string(packer *self, char *dst, size_t strlen, FILE *src)
{
        UNUSED(self);

        size_t num_read = fread(dst, sizeof(char), strlen, src);
        return (num_read == strlen);
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/archive/internal.h>
#include <karbonit/archive/pred.h>
#include <karbonit/archive/cache.h>
#include <karbonit/archive/query.h>

struct sid_to_offset_arg {
        offset_t offset;
        u32 strlen;
};

struct sid_to_offset {
        hashtable ofMapping(archive_field_sid_t, struct sid_to_offset_arg) mapping;
        FILE *disk_file;
        size_t disk_file_size;

};

#define OBJECT_GET_KEYS_TO_FIX_TYPE_GENERIC(num_pairs, obj, bit_flag_name, offset_name)                                \
{                                                                                                                      \
    if (!obj) {                                                                                                        \
        PANIC(ERR_NULLPTR)                                                                 \
    }                                                                                                                  \
                                                                                                                       \
    if (obj->flags.bits.bit_flag_name) {                                                                               \
        assert(obj->props.offset_name != 0);                                                                           \
        MEMFILE_SEEK(&obj->file, obj->props.offset_name);                                                       \
        fixed_prop prop;                                                                                      \
        int_embedded_fixed_props_read(&prop, &obj->file);                                                       \
        archive_int_reset_obj_it_mem_file(obj);                                                                   \
        OPTIONAL_SET(num_pairs, prop.header->num_entries);                                                      \
        return prop.keys;                                                                                              \
    } else {                                                                                                           \
        OPTIONAL_SET(num_pairs, 0);                                                                             \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

bool query_create(query *query, archive *archive)
{
        query->archive = archive;
        query->context = archive_io_context_create(archive);
        return query->context != NULL;
}

bool query_drop(query *query)
{
        return io_context_drop(query->context);
}

bool query_scan_strids(strid_iter *it, query *query)
{
        return strid_iter_open(it, query->archive);
}

static bool
index_string_id_to_offset_open_file(struct sid_to_offset *index, const char *file)
{
        index->disk_file = fopen(file, "r");
        if (!index->disk_file) {
                return ERROR(ERR_FOPEN_FAILED, NULL);
        } else {
                fseek(index->disk_file, 0, SEEK_END);
                index->disk_file_size = ftell(index->disk_file);
                fseek(index->disk_file, 0, SEEK_SET);
                return true;
        }
}

bool query_create_index_string_id_to_offset(struct sid_to_offset **index, query *query)
{
        strid_iter strid_iter;
        strid_info *info;
        size_t vec_len;
        bool status;
        bool success;
        u32 capacity;
        archive_info archive_info;
        archive_get_info(&archive_info, query->archive);
        capacity = archive_info.num_embeddded_strings;

        struct sid_to_offset *result = MALLOC(sizeof(struct sid_to_offset));
        hashtable_create(&result->mapping,
                         sizeof(archive_field_sid_t),
                         sizeof(struct sid_to_offset_arg),
                         capacity);

        if (!index_string_id_to_offset_open_file(result, query->archive->disk_file_path)) {
                return false;
        }

        status = query_scan_strids(&strid_iter, query);

        if (status) {
                while (strid_iter_next(&success, &info, &vec_len, &strid_iter)) {
                        for (size_t i = 0; i < vec_len; i++) {
                                struct sid_to_offset_arg arg = {.offset = info[i].offset, .strlen = info[i].strlen};
                                hashtable_insert_or_update(&result->mapping, &info[i].id, &arg, 1);
                        }
                }
                *index = result;
                strid_iter_close(&strid_iter);
                return true;
        } else {
                ERROR(ERR_SCAN_FAILED, NULL);
                return false;
        }

}

void query_drop_index_string_id_to_offset(struct sid_to_offset *index)
{
        if (index) {
                hashtable_drop(&index->mapping);
                fclose(index->disk_file);
                free(index);
        }
}

bool query_index_id_to_offset_serialize(FILE *file, struct sid_to_offset *index)
{
        UNUSED(file);
        UNUSED(index);
        return hashtable_serialize(file, &index->mapping);
}

bool query_index_id_to_offset_deserialize(struct sid_to_offset **index, const char *file_path, offset_t offset)
{
        struct sid_to_offset *result = MALLOC(sizeof(struct sid_to_offset));
        if (!result) {
                ERROR(ERR_MALLOCERR, NULL);
                return false;
        }

        if (!index_string_id_to_offset_open_file(result, file_path)) {
                return false;
        }

        FILE *index_reader_file = fopen(file_path, "r");
        if (!index_reader_file) {
                return ERROR(ERR_FOPEN_FAILED, NULL);
        } else {
                fseek(index_reader_file, 0, SEEK_END);
                offset_t file_size = ftell(index_reader_file);

                if (offset >= file_size) {
                        return ERROR(ERR_INTERNALERR, NULL);
                }

                fseek(index_reader_file, offset, SEEK_SET);

                if (!hashtable_deserialize(&result->mapping, index_reader_file)) {
                        ERROR(ERR_HASTABLE_DESERIALERR, NULL);
                        fclose(index_reader_file);
                        *index = NULL;
                        return false;
                }

                fclose(index_reader_file);
                *index = result;
                return true;
        }
}

static char *fetch_string_from_file(bool *decode_success, FILE *disk_file, size_t offset, size_t string_len,
                                    archive *archive)
{
        char *result = MALLOC(string_len + 1);
        memset(result, 0, string_len + 1);

        fseek(disk_file, offset, SEEK_SET);

        bool decode_result = pack_decode(&archive->string_table.compressor, result, string_len, disk_file);

        *decode_success = decode_result;
        return result;
}

static char *fetch_string_by_id_via_scan(query *query, archive_field_sid_t id)
{
        assert(query);

        strid_iter strid_iter;
        strid_info *info;
        size_t vec_len;
        bool status;
        bool success;

        status = query_scan_strids(&strid_iter, query);

        if (status) {
                while (strid_iter_next(&success, &info, &vec_len, &strid_iter)) {
                        for (size_t i = 0; i < vec_len; i++) {
                                if (info[i].id == id) {
                                        bool decode_result;
                                        char *result = fetch_string_from_file(&decode_result,
                                                                              strid_iter.disk_file,
                                                                              info[i].offset,
                                                                              info[i].strlen,
                                                                              query->archive);

                                        bool close_iter_result = strid_iter_close(&strid_iter);

                                        if (!success || !close_iter_result) {
                                                if (result) {
                                                        free(result);
                                                }
                                                ERROR(!decode_result ? ERR_DECOMPRESSFAILED
                                                                     : ERR_ITERATORNOTCLOSED, NULL);
                                                return NULL;
                                        } else {
                                                return result;
                                        }
                                }
                        }
                }
                strid_iter_close(&strid_iter);
                ERROR(ERR_NOTFOUND, NULL);
                return NULL;
        } else {
                ERROR(ERR_SCAN_FAILED, NULL);
                return NULL;
        }
}

static char *fetch_string_by_id_via_index(query *query, struct sid_to_offset *index,
                                          archive_field_sid_t id)
{
        const struct sid_to_offset_arg *args = hashtable_get_value(&index->mapping, &id);
        if (args) {
                if (args->offset < index->disk_file_size) {
                        bool decode_result;
                        char *result = fetch_string_from_file(&decode_result,
                                                              index->disk_file,
                                                              args->offset,
                                                              args->strlen,
                                                              query->archive);
                        if (decode_result) {
                                return result;
                        } else {
                                ERROR(ERR_DECOMPRESSFAILED, NULL);
                                return NULL;
                        }

                } else {
                        ERROR(ERR_INDEXCORRUPTED_OFFSET, NULL);
                        return NULL;
                }
        } else {
                ERROR(ERR_NOTFOUND, NULL);
                return NULL;
        }
}

char *query_fetch_string_by_id(query *query, archive_field_sid_t id)
{
        assert(query);

        bool has_cache = false;
        archive_hash_query_string_id_cache(&has_cache, query->archive);
        if (has_cache) {
                return string_id_cache_get(query->archive->string_id_cache, id);
        } else {
                return query_fetch_string_by_id_nocache(query, id);
        }
}

char *query_fetch_string_by_id_nocache(query *query, archive_field_sid_t id)
{
        bool has_index = false;
        archive_has_query_index_string_id_to_offset(&has_index, query->archive);
        if (has_index) {
                return fetch_string_by_id_via_index(query, query->archive->query_index_string_id_to_offset, id);
        } else {
                return fetch_string_by_id_via_scan(query, id);
        }
}

char **query_fetch_strings_by_offset(query *query, offset_t *offs, u32 *strlens,
                                         size_t num_offs)
{
        assert(query);
        assert(offs);
        assert(strlens);

        FILE *file;

        if (num_offs == 0) {
                return NULL;
        }

        char **result = MALLOC(num_offs * sizeof(char *));
        if (!result) {
                ERROR(ERR_MALLOCERR, NULL);
                return NULL;
        }
        for (size_t i = 0; i < num_offs; i++) {
                if ((result[i] = MALLOC((strlens[i] + 1) * sizeof(char))) == NULL) {
                        for (size_t k = 0; k < i; k++) {
                                free(result[k]);
                        }
                        free(result);
                        return NULL;
                }
                memset(result[i], 0, (strlens[i] + 1) * sizeof(char));
        }

        if (!result) {
                ERROR(ERR_MALLOCERR, NULL);
                return NULL;
        } else {
                if (!(file = io_context_lock_and_access(query->context))) {
                        goto cleanup_and_error;
                }

                for (size_t i = 0; i < num_offs; i++) {
                        fseek(file, offs[i], SEEK_SET);
                        if (!pack_decode(&query->archive->string_table.compressor,
                                         result[i],
                                         strlens[i],
                                         file)) {
                                io_context_unlock(query->context);
                                goto cleanup_and_error;
                        }
                }
                io_context_unlock(query->context);
                return result;
        }

        cleanup_and_error:
        for (size_t i = 0; i < num_offs; i++) {
                free(result[i]);
        }
        free(result);
        return NULL;
}

archive_field_sid_t *query_find_ids(size_t *num_found, query *query,
                                            const string_pred *pred, void *capture, i64 limit)
{
        if (UNLIKELY(string_pred_validate(pred) == false)) {
                return NULL;
        }
        i64 pred_limit;
        string_pred_get_limit(&pred_limit, pred);
        pred_limit = pred_limit < 0 ? limit : JAK_MIN(pred_limit, limit);

        strid_iter it;
        strid_info *info = NULL;
        size_t info_len = 0;
        size_t step_len = 0;
        offset_t *str_offs = NULL;
        u32 *str_lens = NULL;
        size_t *idxs_matching = NULL;
        size_t num_matching = 0;
        void *tmp = NULL;
        size_t str_cap = 1024;
        archive_field_sid_t *step_ids = NULL;
        archive_field_sid_t *result_ids = NULL;
        size_t result_len = 0;
        size_t result_cap = pred_limit < 0 ? str_cap : (size_t) pred_limit;
        bool success = false;

        if (UNLIKELY(pred_limit == 0)) {
                *num_found = 0;
                return NULL;
        }

        if (UNLIKELY(!num_found || !query || !pred)) {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }

        if (UNLIKELY((step_ids = MALLOC(str_cap * sizeof(archive_field_sid_t))) == NULL)) {
                ERROR(ERR_MALLOCERR, NULL);
                return NULL;
        }

        if (UNLIKELY((str_offs = MALLOC(str_cap * sizeof(offset_t))) == NULL)) {
                ERROR(ERR_MALLOCERR, NULL);
                goto cleanup_result_and_error;
                return NULL;
        }

        if (UNLIKELY((str_lens = MALLOC(str_cap * sizeof(u32))) == NULL)) {
                ERROR(ERR_MALLOCERR, NULL);
                free(str_offs);
                goto cleanup_result_and_error;
                return NULL;
        }

        if (UNLIKELY((idxs_matching = MALLOC(str_cap * sizeof(size_t))) == NULL)) {
                ERROR(ERR_MALLOCERR, NULL);
                free(str_offs);
                free(str_lens);
                goto cleanup_result_and_error;
                return NULL;
        }

        if (UNLIKELY(query_scan_strids(&it, query) == false)) {
                free(str_offs);
                free(str_lens);
                free(idxs_matching);
                goto cleanup_result_and_error;
        }

        if (UNLIKELY((result_ids = MALLOC(result_cap * sizeof(archive_field_sid_t))) == NULL)) {
                ERROR(ERR_MALLOCERR, NULL);
                free(str_offs);
                free(str_lens);
                free(idxs_matching);
                strid_iter_close(&it);
                goto cleanup_result_and_error;
                return NULL;
        }

        while (strid_iter_next(&success, &info, &info_len, &it)) {
                if (UNLIKELY(info_len > str_cap)) {
                        str_cap = (info_len + 1) * 1.7f;
                        if (UNLIKELY((tmp = realloc(str_offs, str_cap * sizeof(offset_t))) == NULL)) {
                                goto realloc_error;
                        } else {
                                str_offs = tmp;
                        }
                        if (UNLIKELY((tmp = realloc(str_lens, str_cap * sizeof(u32))) == NULL)) {
                                goto realloc_error;
                        } else {
                                str_lens = tmp;
                        }
                        if (UNLIKELY((tmp = realloc(idxs_matching, str_cap * sizeof(size_t))) == NULL)) {
                                goto realloc_error;
                        } else {
                                idxs_matching = tmp;
                        }
                }
                assert(info_len <= str_cap);
                for (step_len = 0; step_len < info_len; step_len++) {
                        assert(step_len < str_cap);
                        str_offs[step_len] = info[step_len].offset;
                        str_lens[step_len] = info[step_len].strlen;
                }

                char **strings = query_fetch_strings_by_offset(query,
                                                                   str_offs,
                                                                   str_lens,
                                                                   step_len); // TODO: buffer + cleanup buffer

                if (UNLIKELY(
                        string_pred_eval(pred, idxs_matching, &num_matching, strings, step_len, capture) ==
                        false)) {
                        ERROR(ERR_PREDEVAL_FAILED, NULL);
                        strid_iter_close(&it);
                        goto cleanup_intermediate;
                }

                for (size_t i = 0; i < step_len; i++) {
                        free(strings[i]);
                }
                free(strings);

                for (size_t i = 0; i < num_matching; i++) {
                        assert (idxs_matching[i] < info_len);
                        result_ids[result_len++] = info[idxs_matching[i]].id;
                        if (pred_limit > 0 && result_len == (size_t) pred_limit) {
                                goto stop_search_and_return;
                        }
                        if (UNLIKELY(result_len > result_cap)) {
                                result_cap = (result_len + 1) * 1.7f;
                                if (UNLIKELY(
                                        (tmp = realloc(result_ids, result_cap * sizeof(archive_field_sid_t))) ==
                                        NULL)) {
                                        strid_iter_close(&it);
                                        goto cleanup_intermediate;
                                } else {
                                        result_ids = tmp;
                                }
                        }
                }
        }

        stop_search_and_return:
        if (UNLIKELY(success == false)) {
                strid_iter_close(&it);
                goto cleanup_intermediate;
        }

        *num_found = result_len;
        return result_ids;

        realloc_error:
        ERROR(ERR_REALLOCERR, NULL);

        cleanup_intermediate:
        free(str_offs);
        free(str_lens);
        free(idxs_matching);
        free(result_ids);

        cleanup_result_and_error:
        free(step_ids);
        return NULL;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/archive/strid_it.h>

bool strid_iter_open(strid_iter *it, archive *archive)
{
        memset(&it->vec, 0, sizeof(it->vec));
        it->disk_file = fopen(archive->disk_file_path, "r");
        if (!it->disk_file) {
                it->is_open = false;
                return false;
        }
        fseek(it->disk_file, archive->string_table.first_entry_off, SEEK_SET);
        it->is_open = true;
        it->disk_offset = archive->string_table.first_entry_off;
        return true;
}

bool strid_iter_next(bool *success, strid_info **info, size_t *info_length,
                         strid_iter *it)
{
        if (it->disk_offset != 0 && it->is_open) {
                string_entry_header header;
                size_t vec_pos = 0;
                do {
                        fseek(it->disk_file, it->disk_offset, SEEK_SET);
                        int num_read = fread(&header, sizeof(string_entry_header), 1, it->disk_file);
                        if (header.marker != '-') {
                                ERROR(ERR_INTERNALERR, NULL);
                                return false;
                        }
                        if (num_read != 1) {
                                *success = false;
                                return false;
                        } else {
                                it->vec[vec_pos].id = header.string_id;
                                it->vec[vec_pos].offset = ftell(it->disk_file);
                                it->vec[vec_pos].strlen = header.string_len;
                                it->disk_offset = header.next_entry_off;
                                vec_pos++;
                        }
                } while (header.next_entry_off != 0 && vec_pos < ARRAY_LENGTH(it->vec));

                *info_length = vec_pos;
                *success = true;
                *info = &it->vec[0];
                return true;
        } else {
                return false;
        }
}

bool strid_iter_close(strid_iter *it)
{
        if (it->is_open) {
                fclose(it->disk_file);
                it->is_open = false;
        }
        return true;
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/forwdecl.h>
#include <karbonit/archive/visitor.h>
#include <karbonit/std/hash/table.h>
#include <karbonit/std/hash/set.h>
#include <karbonit/archive/visitor.h>
#include <karbonit/archive/query.h>

static void iterate_props(archive *archive, prop_iter *prop_iter,
                          vec ofType(path_entry) *path_stack,
                          visitor *visitor,
                          int mask, void *capture,
                          bool is_root_object, archive_field_sid_t parent_key, u32 parent_key_array_idx);

static void iterate_objects(archive *archive, const archive_field_sid_t *keys, u32 num_pairs,
                            archive_value_vector *value_iter,
                            vec ofType(path_entry) *path_stack,
                            visitor *visitor, int mask, void *capture, bool is_root_object)
{
        UNUSED(num_pairs);

        DECLARE_AND_INIT(u32, VEC_LENGTH)
        DECLARE_AND_INIT(archive_object, object)
        DECLARE_AND_INIT(unique_id_t, parent_object_id)
        DECLARE_AND_INIT(unique_id_t, object_id)
        DECLARE_AND_INIT(prop_iter, prop_iter)

        archive_value_vec_get_object_id(&parent_object_id, value_iter);
        archive_value_vec_get_length(&VEC_LENGTH, value_iter);
        assert(num_pairs == VEC_LENGTH);

        for (u32 i = 0; i < VEC_LENGTH; i++) {
                archive_field_sid_t parent_key = keys[i];
                u32 parent_key_array_idx = i;

//        path_entry  e = { .key = parent_key, .idx = 0 };
//        vec_push(path_stack, &e, 1);

                //  fprintf(stderr, "XXXX object: ");
                //  archive_visitor_print_path(stderr, archive, path_stack);

                archive_value_vec_get_object_at(&object, i, value_iter);
                archive_object_get_object_id(&object_id, &object);

                archive_prop_iter_from_object(&prop_iter, mask, &object);

                if (!is_root_object) {
                        visit_policy_e visit = VISIT_INCLUDE;
                        if (visitor->before_object_visit) {
                                visit = visitor->before_object_visit(archive,
                                                                     path_stack,
                                                                     parent_object_id,
                                                                     object_id,
                                                                     i,
                                                                     VEC_LENGTH,
                                                                     keys[i],
                                                                     capture);
                        }
                        if (visit == VISIT_INCLUDE) {
                                iterate_props(archive,
                                              &prop_iter,
                                              path_stack,
                                              visitor,
                                              mask,
                                              capture,
                                              false,
                                              parent_key,
                                              parent_key_array_idx);
                                OPTIONAL_CALL(visitor,
                                                  after_object_visit,
                                                  archive,
                                                  path_stack,
                                                  object_id,
                                                  i,
                                                  VEC_LENGTH,
                                                  capture);
                        }
                } else {
                        OPTIONAL_CALL(visitor, visit_root_object, archive, object_id, capture);
                        iterate_props(archive,
                                      &prop_iter,
                                      path_stack,
                                      visitor,
                                      mask,
                                      capture,
                                      false,
                                      parent_key,
                                      parent_key_array_idx);
                }

                //  vec_pop(path_stack);
        }
}

#define SET_TYPE_SWITCH_CASE(name, built_in_type)                                                                      \
{                                                                                                                      \
    if (is_array) {                                                                                                    \
        visit_policy_e visit = VISIT_INCLUDE;                                                 \
        if (visitor->visit_enter_##name##_array_pairs) {                                                               \
            visit = visitor->visit_enter_##name##_array_pairs(archive, path_stack, this_object_oid, keys, num_pairs, capture);     \
        }                                                                                                              \
        if (visit == VISIT_INCLUDE) {                                                                  \
            for (u32 prop_idx = 0; prop_idx < num_pairs; prop_idx++)                                              \
            {                                                                                                          \
                u32 array_length;                                                                                 \
                const built_in_type *values = archive_value_vec_get_##name##_arrays_at(&array_length,        \
                                                                                             prop_idx,                 \
                                                                                             &value_iter);             \
                OPTIONAL_CALL(visitor, visit_enter_##name##_array_pair, archive, path_stack, this_object_oid, keys[prop_idx],      \
                              prop_idx, array_length, capture);                                                        \
                OPTIONAL_CALL(visitor, visit_##name##_array_pair, archive, path_stack, this_object_oid, keys[prop_idx],            \
                              prop_idx, num_pairs, values, array_length, capture)                                      \
                OPTIONAL_CALL(visitor, visit_leave_##name##_array_pair, archive, path_stack, this_object_oid, prop_idx, num_pairs, \
                                                                        capture);                                      \
            }                                                                                                          \
            OPTIONAL_CALL(visitor, visit_leave_##name##_array_pairs, archive, path_stack, this_object_oid, capture);               \
        }                                                                                                              \
    } else                                                                                                             \
    {                                                                                                                  \
        if (visitor->visit_##name##_pairs) {                                                                           \
            const built_in_type *values = archive_value_vec_get_##name##s(NULL, &value_iter);                \
            visitor->visit_##name##_pairs(archive, path_stack, this_object_oid, keys, values, num_pairs, capture);                 \
        }                                                                                                              \
    }                                                                                                                  \
}

#define SET_NESTED_ARRAY_SWITCH_CASE(name, built_in_type)                                                              \
{                                                                                                                      \
    const built_in_type *values = archive_column_entry_get_##name(&entry_length, &entry_iter);                  \
    OPTIONAL_CALL(visitor, visit_object_array_object_property_##name,                                                  \
                  archive, path_stack, this_object_oid, group_key, current_nested_object_id,                           \
                  current_column_name, values, entry_length, capture);                                                 \
}

static void iterate_props(archive *archive, prop_iter *prop_iter,
                          vec ofType(path_entry) *path_stack,
                          visitor *visitor,
                          int mask, void *capture,
                          bool is_root_object, archive_field_sid_t parent_key, u32 parent_key_array_idx)
{
        DECLARE_AND_INIT(unique_id_t, this_object_oid)
        DECLARE_AND_INIT(archive_value_vector, value_iter)
        DECLARE_AND_INIT(enum archive_field_type, type);
        DECLARE_AND_INIT(bool, is_array)
        DECLARE_AND_INIT(const archive_field_sid_t *, keys);
        DECLARE_AND_INIT(u32, num_pairs);
        DECLARE_AND_INIT(prop_iter_mode_e, iter_type)
        DECLARE_AND_INIT(independent_iter_state, collection_iter)
        bool first_type_group = true;

        UNUSED(parent_key);
        UNUSED(parent_key_array_idx);

        path_entry e = {.key = parent_key, .idx = parent_key_array_idx};
        vec_push(path_stack, &e, 1);

        archive_value_vec_get_object_id(&this_object_oid, &value_iter);

        while (archive_prop_iter_next(&iter_type, &value_iter, &collection_iter, prop_iter)) {

                if (iter_type == PROP_ITER_MODE_OBJECT) {

                        keys = archive_value_vec_get_keys(&num_pairs, &value_iter);
                        archive_value_vec_is_array_type(&is_array, &value_iter);
                        archive_value_vec_get_basic_type(&type, &value_iter);
                        archive_value_vec_get_object_id(&this_object_oid, &value_iter);

                        for (u32 i = 0; i < num_pairs; i++) {
                                OPTIONAL_CALL(visitor,
                                                  visit_object_property,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys[i],
                                                  type,
                                                  is_array,
                                                  capture);

                                path_entry e = {.key = keys[i], .idx = 666};
                                vec_push(path_stack, &e, 1);
                                //archive_visitor_print_path(stderr, archive, path_stack);
                                OPTIONAL_CALL(visitor,
                                                  visit_object_array_prop,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys[i],
                                                  type,
                                                  capture);
                                vec_pop(path_stack);
                        }

                        if (UNLIKELY(first_type_group)) {
                                OPTIONAL_CALL(visitor,
                                                  first_prop_type_group,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys,
                                                  type,
                                                  is_array,
                                                  num_pairs,
                                                  capture);
                        } else {
                                OPTIONAL_CALL(visitor,
                                                  next_prop_type_group,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys,
                                                  type,
                                                  is_array,
                                                  num_pairs,
                                                  capture);
                        }

                        switch (type) {
                                case ARCHIVE_FIELD_OBJECT:
                                        assert (!is_array);
                                        iterate_objects(archive,
                                                        keys,
                                                        num_pairs,
                                                        &value_iter,
                                                        path_stack,
                                                        visitor,
                                                        mask,
                                                        capture,
                                                        is_root_object);
                                        //for (size_t i = 0; i < num_pairs; i++) {
                                        //    iterate_objects(archive, &keys[i], 1, &value_iter, path_stack, visitor, mask, capture, is_root_object, keys[i], i);
                                        //}
                                        break;
                                case ARCHIVE_FIELD_NULL:
                                        if (is_array) {
                                                visit_policy_e visit = VISIT_INCLUDE;
                                                if (visitor->visit_enter_null_array_pairs) {
                                                        visit = visitor->visit_enter_null_array_pairs(archive,
                                                                                                      path_stack,
                                                                                                      this_object_oid,
                                                                                                      keys,
                                                                                                      num_pairs,
                                                                                                      capture);
                                                }
                                                if (visit == VISIT_INCLUDE) {
                                                        const archive_field_u32_t *num_values =
                                                                archive_value_vec_get_null_arrays(NULL,
                                                                                                         &value_iter);
                                                        for (u32 prop_idx = 0; prop_idx < num_pairs; prop_idx++) {
                                                                OPTIONAL_CALL(visitor,
                                                                                  visit_enter_null_array_pair,
                                                                                  archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  keys[prop_idx],
                                                                                  prop_idx,
                                                                                  num_values[prop_idx],
                                                                                  capture);
                                                                OPTIONAL_CALL(visitor,
                                                                                  visit_null_array_pair,
                                                                                  archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  keys[prop_idx],
                                                                                  prop_idx,
                                                                                  num_pairs,
                                                                                  num_values[prop_idx],
                                                                                  capture)
                                                                OPTIONAL_CALL(visitor,
                                                                                  visit_leave_null_array_pair,
                                                                                  archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  prop_idx,
                                                                                  num_pairs,
                                                                                  capture);
                                                        }
                                                        OPTIONAL_CALL(visitor,
                                                                          visit_leave_int8_array_pairs,
                                                                          archive,
                                                                          path_stack,
                                                                          this_object_oid,
                                                                          capture);
                                                }
                                        } else {
                                                if (visitor->visit_null_pairs) {
                                                        visitor->visit_null_pairs(archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  keys,
                                                                                  num_pairs,
                                                                                  capture);
                                                }
                                        }
                                        break;
                                case ARCHIVE_FIELD_INT8: SET_TYPE_SWITCH_CASE(int8, archive_field_i8_t)
                                        break;
                                case ARCHIVE_FIELD_INT16: SET_TYPE_SWITCH_CASE(int16, archive_field_i16_t)
                                        break;
                                case ARCHIVE_FIELD_INT32: SET_TYPE_SWITCH_CASE(int32, archive_field_i32_t)
                                        break;
                                case ARCHIVE_FIELD_INT64: SET_TYPE_SWITCH_CASE(int64, archive_field_i64_t)
                                        break;
                                case ARCHIVE_FIELD_UINT8: SET_TYPE_SWITCH_CASE(uint8, archive_field_u8_t)
                                        break;
                                case ARCHIVE_FIELD_UINT16: SET_TYPE_SWITCH_CASE(uint16, archive_field_u16_t)
                                        break;
                                case ARCHIVE_FIELD_UINT32: SET_TYPE_SWITCH_CASE(uint32, archive_field_u32_t)
                                        break;
                                case ARCHIVE_FIELD_UINT64: SET_TYPE_SWITCH_CASE(uint64, archive_field_u64_t)
                                        break;
                                case ARCHIVE_FIELD_FLOAT: SET_TYPE_SWITCH_CASE(number, archive_field_number_t)
                                        break;
                                case ARCHIVE_FIELD_STRING: SET_TYPE_SWITCH_CASE(string, archive_field_sid_t)
                                        break;
                                case ARCHIVE_FIELD_BOOLEAN: SET_TYPE_SWITCH_CASE(boolean, archive_field_boolean_t)
                                        break;
                                default:
                                        break;
                        }

                        first_type_group = false;
                } else {
                        independent_iter_state group_iter;
                        u32 num_column_groups;
                        keys = archive_collection_iter_get_keys(&num_column_groups, &collection_iter);

                        bool *skip_groups_by_key = MALLOC(num_column_groups * sizeof(bool));
                        ZERO_MEMORY(skip_groups_by_key, num_column_groups * sizeof(bool));

                        if (visitor->before_visit_object_array) {
                                for (u32 i = 0; i < num_column_groups; i++) {

                                        //     path_entry  e = { .key = parent_key, .idx = i };
                                        //vec_push(path_stack, &e, 1);


                                        visit_policy_e policy = visitor->before_visit_object_array(archive,
                                                                                                          path_stack,
                                                                                                          this_object_oid,
                                                                                                          keys[i],
                                                                                                          capture);

                                        //     vec_pop(path_stack);

                                        skip_groups_by_key[i] = policy == VISIT_EXCLUDE;
                                }
                        }

                        u32 current_group_idx = 0;

                        while (archive_collection_next_column_group(&group_iter, &collection_iter)) {
                                if (!skip_groups_by_key[current_group_idx]) {

                                        u32 num_column_group_objs;
                                        independent_iter_state column_iter;
                                        archive_field_sid_t group_key = keys[current_group_idx];
                                        const unique_id_t *column_group_object_ids =
                                                archive_column_group_get_object_ids(&num_column_group_objs,
                                                                                        &group_iter);
                                        bool *skip_objects = MALLOC(num_column_group_objs * sizeof(bool));
                                        ZERO_MEMORY(skip_objects, num_column_group_objs * sizeof(bool));

                                        if (visitor->before_visit_object_array_objects) {
                                                visitor->before_visit_object_array_objects(skip_objects,
                                                                                           archive,
                                                                                           path_stack,
                                                                                           this_object_oid,
                                                                                           group_key,
                                                                                           column_group_object_ids,
                                                                                           num_column_group_objs,
                                                                                           capture);
                                        }

                                        u32 current_column_group_obj_idx = 0;

                                        while (archive_column_group_next_column(&column_iter, &group_iter)) {

                                                if (!skip_objects[current_column_group_obj_idx]) {
                                                        archive_field_sid_t current_column_name;
                                                        enum archive_field_type current_column_entry_type;

                                                        archive_column_get_name(&current_column_name,
                                                                                    &current_column_entry_type,
                                                                                    &column_iter);

                                                        path_entry e = {.key = current_column_name, .idx = 0};
                                                        vec_push(path_stack, &e, 1);

                                                        /**
                                                            0/page_end/0/
                                                            /0/doi/0/
                                                            /0/page_start/0/
                                                            /0/venue/0/
                                                            /0/doc_type/0/
                                                            /0/n_citation/0/
                                                            /0/issue/0/
                                                            /0/volume/0/
                                                            /0/n_citation/0/
                                                         */

                                                        OPTIONAL_CALL(visitor,
                                                                          visit_object_array_prop,
                                                                          archive,
                                                                          path_stack,
                                                                          this_object_oid,
                                                                          current_column_name,
                                                                          current_column_entry_type,
                                                                          capture);

                                                        bool skip_column = false;
                                                        if (visitor->before_visit_object_array_object_property) {
                                                                visit_policy_e policy =
                                                                        visitor->before_visit_object_array_object_property(
                                                                                archive,
                                                                                path_stack,
                                                                                this_object_oid,
                                                                                group_key,
                                                                                current_column_name,
                                                                                current_column_entry_type,
                                                                                capture);
                                                                skip_column = policy == VISIT_EXCLUDE;
                                                        }

                                                        if (!skip_column) {
                                                                u32 num_positions;
                                                                const u32 *entry_positions =
                                                                        archive_column_get_entry_positions(
                                                                                &num_positions,
                                                                                &column_iter);
                                                                independent_iter_state entry_iter;

                                                                unique_id_t *entry_object_containments =
                                                                        MALLOC(num_positions *
                                                                                   sizeof(unique_id_t));
                                                                for (u32 m = 0; m < num_positions; m++) {
                                                                        entry_object_containments[m] =
                                                                                column_group_object_ids[entry_positions[m]];
                                                                }

                                                                if (visitor->get_column_entry_count) {
                                                                        bool shall_continue =
                                                                                visitor->get_column_entry_count(archive,
                                                                                                                path_stack,
                                                                                                                current_column_name,
                                                                                                                current_column_entry_type,
                                                                                                                num_positions,
                                                                                                                capture);
                                                                        if (!shall_continue) {
                                                                                break;
                                                                        }
                                                                }

                                                                u32 current_entry_idx = 0;
                                                                while (archive_column_next_entry(&entry_iter,
                                                                                                     &column_iter)) {

                                                                        unique_id_t current_nested_object_id =
                                                                                entry_object_containments[current_entry_idx];
                                                                        DECLARE_AND_INIT(u32, entry_length)

                                                                        switch (current_column_entry_type) {
                                                                                case ARCHIVE_FIELD_INT8: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int8s,
                                                                                                archive_field_i8_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_INT16: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int16s,
                                                                                                archive_field_i16_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_INT32: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int32s,
                                                                                                archive_field_i32_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_INT64: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int64s,
                                                                                                archive_field_i64_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_UINT8: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint8s,
                                                                                                archive_field_u8_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_UINT16: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint16s,
                                                                                                archive_field_u16_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_UINT32: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint32s,
                                                                                                archive_field_u32_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_UINT64: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint64s,
                                                                                                archive_field_u64_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_FLOAT: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                numbers,
                                                                                                archive_field_number_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_STRING: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                strings,
                                                                                                archive_field_sid_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_BOOLEAN: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                booleans,
                                                                                                archive_field_boolean_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_NULL: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                nulls,
                                                                                                archive_field_u32_t)
                                                                                }
                                                                                        break;
                                                                                case ARCHIVE_FIELD_OBJECT: {
                                                                                        column_object_iter iter;
                                                                                        const archive_object
                                                                                                *archive_object;
                                                                                        archive_column_entry_get_objects(
                                                                                                &iter,
                                                                                                &entry_iter);

                                                                                        while ((archive_object =
                                                                                                        archive_column_entry_object_iter_next_object(
                                                                                                                &iter))
                                                                                               != NULL) {
                                                                                                unique_id_t id;
                                                                                                archive_object_get_object_id(
                                                                                                        &id,
                                                                                                        archive_object);

                                                                                                bool skip_object = false;
                                                                                                if (visitor
                                                                                                        ->before_object_array_object_property_object) {
                                                                                                        visit_policy_e
                                                                                                                policy =
                                                                                                                visitor->before_object_array_object_property_object(
                                                                                                                        archive,
                                                                                                                        path_stack,
                                                                                                                        this_object_oid,
                                                                                                                        group_key,
                                                                                                                        current_nested_object_id,
                                                                                                                        current_column_name,
                                                                                                                        id,
                                                                                                                        capture);
                                                                                                        skip_object =
                                                                                                                policy
                                                                                                                ==
                                                                                                                VISIT_EXCLUDE;
                                                                                                }

                                                                                                if (!skip_object) {


                                                                                                        //keys[i]

                                                                                                        //path_entry  e = { .key = current_column_name, .idx = 0 };
                                                                                                        //vec_push(path_stack, &e, 1);

                                                                                                        vec_pop(path_stack);

                                                                                                        struct prop_iter
                                                                                                                nested_obj_prop_iter;
                                                                                                        archive_prop_iter_from_object(
                                                                                                                &nested_obj_prop_iter,
                                                                                                                mask,
                                                                                                                archive_object);
                                                                                                        iterate_props(
                                                                                                                archive,
                                                                                                                &nested_obj_prop_iter,
                                                                                                                path_stack,
                                                                                                                visitor,
                                                                                                                mask,
                                                                                                                capture,
                                                                                                                false,
                                                                                                                current_column_name,
                                                                                                                current_group_idx);

                                                                                                        path_entry e =
                                                                                                                {.key = current_column_name, .idx = 0};
                                                                                                        vec_push(
                                                                                                                path_stack,
                                                                                                                &e,
                                                                                                                1);

                                                                                                }

                                                                                        }
                                                                                }
                                                                                        break;
                                                                                default:
                                                                                        break;
                                                                        }

                                                                        current_entry_idx++;
                                                                }

                                                                free(entry_object_containments);
                                                        }
                                                        vec_pop(path_stack);
                                                }
                                                current_column_group_obj_idx++;

                                        }

                                        free(skip_objects);
                                }
                                current_group_idx++;
                        }
                        free(skip_groups_by_key);
                }
        }
        vec_pop(path_stack);
}

bool archive_visit_archive(archive *archive, const archive_visitor_desc *desc,
                               visitor *visitor, void *capture)
{
        prop_iter prop_iter;
        vec ofType(path_entry) path_stack;

        int mask = desc ? desc->visit_mask : ARCHIVE_ITER_MASK_ANY;

        if (archive_prop_iter_from_archive(&prop_iter, mask, archive)) {
                vec_create(&path_stack, sizeof(path_entry), 100);
                OPTIONAL_CALL(visitor, before_visit_starts, archive, capture);
                iterate_props(archive, &prop_iter, &path_stack, visitor, mask, capture, true, 0, 0);
                OPTIONAL_CALL(visitor, after_visit_ends, archive, capture);
                vec_drop(&path_stack);
                return true;
        } else {
                return false;
        }
}

#include <inttypes.h>

void archive_visitor_path_to_string(char path_buffer[2048], archive *archive,
                                        const vec ofType(path_entry) *path_stack)
{

        query *query = archive_query_default(archive);

        for (u32 i = 0; i < path_stack->num_elems; i++) {
                const path_entry *entry = VEC_GET(path_stack, i, path_entry);
                if (entry->key != 0) {
                        char *key = query_fetch_string_by_id(query, entry->key);
                        size_t len = strlen(path_buffer);
                        sprintf(path_buffer + len, "%s%s", key, i + 1 < path_stack->num_elems ? ", " : "");
                        free(key);
                } else {
                        sprintf(path_buffer, "/");
                }
        }
}

bool archive_visitor_print_path(FILE *file, archive *archive,
                                    const vec ofType(path_entry) *path_stack)
{
        query *query = archive_query_default(archive);

        for (u32 i = 0; i < path_stack->num_elems; i++) {
                const path_entry *entry = VEC_GET(path_stack, i, path_entry);
                if (entry->key != 0) {
                        char *key = query_fetch_string_by_id(query, entry->key);
                        fprintf(file, "%s/", key);
                        free(key);
                } else {
                        fprintf(file, "/");
                }
        }
        fprintf(file, "\n");

        char buffer[2048];
        memset(buffer, 0, sizeof(buffer));
        archive_visitor_path_to_string(buffer, archive, path_stack);
        fprintf(file, "%s\n", buffer);

        return true;
}

bool archive_visitor_path_compare(const vec ofType(path_entry) *path,
                                      archive_field_sid_t *group_name, const char *path_str,
                                      archive *archive)
{
        char path_buffer[2048];
        memset(path_buffer, 0, sizeof(path_buffer));
        sprintf(path_buffer, "/");

        query *query = archive_query_default(archive);

        for (u32 i = 1; i < path->num_elems; i++) {
                const path_entry *entry = VEC_GET(path, i, path_entry);
                if (entry->key != 0) {
                        char *key = query_fetch_string_by_id(query, entry->key);
                        size_t len = strlen(path_buffer);
                        sprintf(path_buffer + len, "%s/", key);
                        free(key);
                }
        }

        if (group_name) {
                char *key = query_fetch_string_by_id(query, *group_name);
                size_t len = strlen(path_buffer);
                sprintf(path_buffer + len, "%s/", key);
                free(key);
        }

        fprintf(stderr, "'%s' <-> needle '%s'\n", path_buffer, path_str);

        return strcmp(path_buffer, path_str) == 0;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements an (read-/write) iterator for (JSON) arrays in carbon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/forwdecl.h>
#include <karbonit/std/uintvar/stream.h>
#include <karbonit/rec.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/mime.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/item.h>

#define DEFINE_IN_PLACE_UPDATE_FUNCTION(type_name, field_type)                                                         \
bool internal_arr_it_update_##type_name(arr_it *it, type_name value)                \
{                                                                                                                      \
        offset_t datum = 0;                                                                                                \
        if (LIKELY(it->field.type == field_type)) {                                                    \
                MEMFILE_SAVE_POSITION(&it->file);                                                                   \
                internal_arr_it_offset(&datum, it);                                                                 \
                MEMFILE_SEEK(&it->file, datum + sizeof(u8));                                                        \
                MEMFILE_WRITE(&it->file, &value, sizeof(type_name));                                                \
                MEMFILE_RESTORE_POSITION(&it->file);                                                                \
                return true;                                                                                           \
        } else {                                                                                                       \
                ERROR(ERR_TYPEMISMATCH, NULL);                                                                 \
                return false;                                                                                          \
        }                                                                                                              \
}

DEFINE_IN_PLACE_UPDATE_FUNCTION(u8, FIELD_NUMBER_U8)

DEFINE_IN_PLACE_UPDATE_FUNCTION(u16, FIELD_NUMBER_U16)

DEFINE_IN_PLACE_UPDATE_FUNCTION(u32, FIELD_NUMBER_U32)

DEFINE_IN_PLACE_UPDATE_FUNCTION(u64, FIELD_NUMBER_U64)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i8, FIELD_NUMBER_I8)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i16, FIELD_NUMBER_I16)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i32, FIELD_NUMBER_I32)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i64, FIELD_NUMBER_I64)

DEFINE_IN_PLACE_UPDATE_FUNCTION(float, FIELD_NUMBER_FLOAT)

static inline bool update_in_place_constant(arr_it *it, constant_e constant)
{
        MEMFILE_SAVE_POSITION(&it->file);

        if (FIELD_IS_CONSTANT(it->field.type)) {
                u8 value;
                switch (constant) {
                        case CONST_TRUE:
                                value = FIELD_TRUE;
                                break;
                        case CONST_FALSE:
                                value = FIELD_FALSE;
                                break;
                        case CONST_NULL:
                                value = FIELD_NULL;
                                break;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                break;
                }
                offset_t datum = 0;
                internal_arr_it_offset(&datum, it);
                MEMFILE_SEEK(&it->file, datum);
                MEMFILE_WRITE(&it->file, &value, sizeof(u8));
        } else {
                insert ins;
                internal_arr_it_remove(it);
                arr_it_insert_begin(&ins, it);

                switch (constant) {
                        case CONST_TRUE:
                                insert_true(&ins);
                                break;
                        case CONST_FALSE:
                                insert_false(&ins);
                                break;
                        case CONST_NULL:
                                insert_null(&ins);
                                break;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                break;
                }

                arr_it_insert_end(&ins);
        }

        MEMFILE_RESTORE_POSITION(&it->file);
        return true;
}

inline bool internal_arr_it_update_true(arr_it *it)
{
        return update_in_place_constant(it, CONST_TRUE);
}

inline bool internal_arr_it_update_false(arr_it *it)
{
        return update_in_place_constant(it, CONST_FALSE);
}

inline bool internal_arr_it_update_null(arr_it *it)
{
        return update_in_place_constant(it, CONST_NULL);
}

inline bool internal_arr_it_update_string(arr_it *it, const char *str)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(str)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline bool internal_arr_it_update_binary(arr_it *it, const void *base, size_t nbytes, const char *file_ext, const char *type)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(base)
        UNUSED(nbytes)
        UNUSED(file_ext)
        UNUSED(type)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline insert *internal_arr_it_update_array_begin(arr_state *state, arr_it *it)
{
        // TODO: Implement P1
        UNUSED(state)
        UNUSED(it)
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

inline bool internal_arr_it_update_array_end(arr_state *state)
{
        // TODO: Implement P1
        UNUSED(state)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline insert *internal_arr_it_update_column_begin(col_state *state, arr_it *it)
{
        // TODO: Implement P1
        UNUSED(state)
        UNUSED(it)
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

inline bool internal_arr_it_update_column_end(col_state *state)
{
        // TODO: Implement P1
        UNUSED(state)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline insert *internal_arr_it_update_object_begin(obj_state *state, arr_it *it)
{
        // TODO: Implement P1
        UNUSED(state)
        UNUSED(it)
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

inline bool internal_arr_it_update_object_end(obj_state *state)
{
        // TODO: Implement P1
        UNUSED(state)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline bool internal_arr_it_update_from_carbon(arr_it *it, const rec *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline bool internal_arr_it_update_from_array(arr_it *it, const arr_it *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline bool internal_arr_it_update_from_object(arr_it *it, const obj_it *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline bool internal_arr_it_update_from_column(arr_it *it, const col_it *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

inline bool internal_arr_it_create(arr_it *it, memfile *memfile, offset_t payload_start)
{
        //ZERO_MEMORY(it, sizeof(arr_it));

        it->begin = payload_start;
        it->mod_size = 0;
        it->eof = false;
        it->field_offset = 0;
        it->pos = 0;
        it->last_off = 0;

        MEMFILE_OPEN(&it->file, memfile->memblock, memfile->mode);
        MEMFILE_SEEK__UNSAFE(&it->file, payload_start);

        u8 marker = *(u8*) MEMFILE_READ_UNSAEF(&it->file, 1);

//#ifndef NDEBUG
//        if (!abstract_is_instanceof_array(marker)) {
//            return ERROR(ERR_MARKERMAPPING, "expected array or sub type marker");
//        }
//#endif

        abstract_type_class_e type_class = abstract_get_class(marker);
        it->list_type = abstract_class_to_list_derivable(type_class);

        ARR_IT_REWIND(it);

        return true;
}

inline bool internal_arr_it_copy(arr_it *dst, arr_it *src)
{
        internal_arr_it_create(dst, &src->file, src->begin);
        return true;
}

inline bool internal_arr_it_clone(arr_it *dst, arr_it *src)
{
        MEMFILE_CLONE(&dst->file, &src->file);
        dst->begin = src->begin;
        dst->mod_size = src->mod_size;
        dst->eof = src->eof;
        dst->list_type = src->list_type;
        dst->last_off = src->last_off;
        internal_field_clone(&dst->field, &src->field);
        dst->field_offset = src->field_offset;
        dst->pos = src->pos;
        INTERNAL_ITEM_CREATE_FROM_ARRAY(&dst->item, dst, src->pos, &dst->field, dst->field.type);
        return true;
}

inline bool arr_it_length(u64 *len, arr_it *it)
{
        arr_it dup;
        internal_arr_it_clone(&dup, it);

        u64 num_elem = 0;
        while (arr_it_next(&dup)) {
                num_elem++;
        }
        *len = num_elem;

        return true;
}

inline bool arr_it_is_empty(arr_it *it)
{
        ARR_IT_REWIND(it);
        return arr_it_next(it);
}

inline bool arr_it_has_next(arr_it *it)
{
        arr_it cpy;
        internal_arr_it_clone(&cpy, it);
        bool has_next = arr_it_next(&cpy);
        return has_next;
}

inline bool arr_it_is_unit(arr_it *it)
{
        arr_it cpy;
        internal_arr_it_copy(&cpy, it);
        bool has_next = arr_it_next(&cpy);
        bool ret = false;

        if (has_next) {
                has_next = arr_it_next(&cpy);
                ret = !has_next;
        }

        return ret;
}

inline void internal_arr_it_adjust(arr_it *it)
{
        MEMFILE_SEEK_FROM_HERE(&it->file, it->mod_size);
        it->mod_size = 0;
}

inline item *arr_it_next(arr_it *it)
{
        offset_t begin_off = MEMFILE_TELL(&it->file);
        u8 *raw_begin = MEMFILE_RAW_DATA(&it->file);
        u8 *raw_it = raw_begin;

        uint_fast8_t c;

        /** skip remaining zeros until end of array is reached */
        while ((c = *raw_it) == 0) {
                raw_it++;
        }

        if (c != MARRAY_END) {
                // read array field read fast
                {
                        it->field_offset = begin_off + (raw_it - raw_begin);
                        it->field.type = *(raw_it++);
                }
                // access field data
                {
                        field *field = &it->field;

                        switch (field->type) {
                                case FIELD_NULL:
                                case FIELD_TRUE:
                                case FIELD_FALSE:
                                        /* nothing to do */
                                        break;
                                case FIELD_NUMBER_U8:
                                case FIELD_NUMBER_I8:
                                        field->data = raw_it;
                                        raw_it += sizeof(u8);
                                        break;
                                case FIELD_NUMBER_U16:
                                case FIELD_NUMBER_I16:
                                        field->data = raw_it;
                                        raw_it += sizeof(u16);
                                        break;
                                case FIELD_NUMBER_U32:
                                case FIELD_NUMBER_I32:
                                        field->data = raw_it;
                                        raw_it += sizeof(u32);
                                        break;
                                case FIELD_NUMBER_U64:
                                case FIELD_NUMBER_I64:
                                        field->data = raw_it;
                                        raw_it += sizeof(u64);
                                        break;
                                case FIELD_NUMBER_FLOAT:
                                        field->data = raw_it;
                                        raw_it += sizeof(float);
                                        break;
                                case FIELD_STRING: {
                                        u8 nbytes;
                                        uintvar_stream_t len = (uintvar_stream_t) raw_it;
                                        field->len = UINTVAR_STREAM_READ(&nbytes, len);
                                        raw_it += nbytes;
                                        field->data = raw_it;
                                        raw_it += field->len; /* skip string value */
                                }
                                        break;
                                case FIELD_BINARY: {
                                        u8 nbytes;
                                        /** read mime type with variable-length integer type */
                                        uintvar_stream_t id = (uintvar_stream_t) raw_it;
                                        u64 mime_id = UINTVAR_STREAM_READ(&nbytes, id);
                                        raw_it += nbytes;
                                        field->mime = mime_by_id(mime_id);
                                        field->mime_len = strlen(field->mime);

                                        /** read blob length */
                                        uintvar_stream_t len = (uintvar_stream_t) raw_it;
                                        field->len = UINTVAR_STREAM_READ(&nbytes, len);
                                        raw_it += nbytes;

                                        /** the mem points now to the actual blob data, which is used by the iterator to set the field */
                                        field->data = raw_it;
                                        raw_it += field->len;
                                }
                                        break;
                                case FIELD_BINARY_CUSTOM: {
                                        u8 nbytes;
                                        /** read mime type str_buf */
                                        uintvar_stream_t mlen = (uintvar_stream_t) raw_it;
                                        field->mime_len = UINTVAR_STREAM_READ(&nbytes, mlen);
                                        raw_it += nbytes;

                                        field->mime = (const char *) raw_it;
                                        raw_it += field->mime_len;

                                        /** read blob length */
                                        uintvar_stream_t len = (uintvar_stream_t) raw_it;
                                        field->len = UINTVAR_STREAM_READ(&nbytes, len);
                                        raw_it += nbytes;

                                        /** the mem points now to the actual blob data, which is used by the iterator to set the field */
                                        field->data = raw_it;
                                        raw_it += field->len;
                                }
                                        break;
                                case FIELD_ARRAY_UNSORTED_MULTISET:
                                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                                case FIELD_DERIVED_ARRAY_SORTED_SET: {
                                        arr_it forward_it;
                                        field->data = raw_begin;

                                        internal_arr_it_create(&forward_it, &it->file, begin_off);
                                        internal_arr_it_fast_forward(&forward_it);
                                        raw_it = internal_arr_it_memfile(&forward_it);
                                } break;
                                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                                        col_it forward_it;
                                        field->data = raw_begin;

                                        col_it_create(&forward_it, &it->file, begin_off);
                                        internal_col_it_skip__fast(&forward_it);
                                        raw_it = col_it_memfile_raw(&forward_it);
                                } break;
                                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                                case FIELD_DERIVED_OBJECT_SORTED_MAP: {
                                        obj_it forward_it;
                                        field->data = raw_it;

                                        internal_obj_it_create(&forward_it, &it->file, begin_off);
                                        internal_obj_it_fast_forward(&forward_it);
                                        raw_it = internal_obj_it_memfile(&forward_it);
                                } break;
                                default:
                                        ERROR(ERR_CORRUPTED, NULL);
                                        break;
                        }
                }

                INTERNAL_ITEM_CREATE_FROM_ARRAY(&(it->item), it, it->pos, &(it->field),it->field.type);
                it->pos++;

                it->last_off = begin_off;
                MEMFILE_SEEK__UNSAFE(&it->file, begin_off + (raw_it - raw_begin));

                return &(it->item);
        } else {
                MEMFILE_SEEK__UNSAFE(&it->file, begin_off + (raw_it - raw_begin));
                assert(*MEMFILE_PEEK(&it->file, sizeof(char)) == MARRAY_END);
                it->eof = true;
                return NULL;
        }
}

inline void *internal_arr_it_memfile(arr_it *it)
{
        return MEMFILE_RAW_DATA(&it->file);
}

inline offset_t internal_arr_it_memfilepos(arr_it *it)
{
        if (LIKELY(it != NULL)) {
                return MEMFILE_TELL(&it->file);
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return 0;
        }
}

inline offset_t internal_arr_it_tell(arr_it *it)
{
        return it ? it->field_offset : 0;
}

inline bool internal_arr_it_offset(offset_t *off, arr_it *it)
{
        if (it->last_off) {
                *off = it->last_off;
                return true;
        }
        return false;
}

inline bool internal_arr_it_fast_forward(arr_it *it)
{
        while (arr_it_next(it))
                { }

        assert(*MEMFILE_PEEK(&it->file, sizeof(char)) == MARRAY_END);
        MEMFILE_SKIP(&it->file, sizeof(char));
        return true;
}

inline void arr_it_insert_begin(insert *in, arr_it *it)
{
        internal_insert_create_for_array(in, it);
}

inline void arr_it_insert_end(insert *in)
{
        UNUSED(in)
        /* nothing to do */
}

inline bool internal_arr_it_remove(arr_it *it)
{
        field_e type;
        if (arr_it_field_type(&type, it)) {
                offset_t prev_off = it->last_off;
                MEMFILE_SEEK(&it->file, prev_off);
                if (internal_field_remove(&it->file, type)) {
                        internal_array_refresh(NULL, NULL, it);
                        return true;
                } else {
                        return false;
                }
        } else {
                ERROR(ERR_ILLEGALSTATE, NULL);
                return false;
        }
}

/** Checks if this array is annotated as a multi set abstract type. Returns true if it is is a multi set, and false if
 * it is a set. In case of any ERROR, a failure is returned. */
inline bool arr_it_is_multiset(arr_it *it)
{
        abstract_type_class_e type_class = abstract_list_derivable_to_class(it->list_type);
        return abstract_is_multiset(type_class);
}

/** Checks if this array is annotated as a sorted abstract type. Returns true if this is the case,
 * otherwise false. In case of any ERROR, a failure is returned. */
inline bool arr_it_is_sorted(arr_it *it)
{
        abstract_type_class_e type_class = abstract_list_derivable_to_class(it->list_type);
        return abstract_is_sorted(type_class);
}

inline void arr_it_update_type(arr_it *it, list_type_e derivation)
{
        MEMFILE_SAVE_POSITION(&it->file);
        MEMFILE_SEEK(&it->file, it->begin);

        derived_e derive_marker = abstract_derive_list_to(LIST_ARRAY, derivation);
        abstract_write_derived_type(&it->file, derive_marker);

        MEMFILE_RESTORE_POSITION(&it->file);
}

inline bool arr_it_field_type(field_e *type, arr_it *it)
{
        return internal_field_field_type(type, &it->field);
}/*
 * Copyright 2019 Marcus Pinnecke
 */

#include <karbonit/carbon/binary.h>
#include <libs/libb64/libb64.h>

#define code_of(x, data_len)      (x + data_len + 2)
#define data_of(x)      (x)

void binary_field_print(str_buf *dst, const binary_field *field)
{
        str_buf_add(dst, "{");
        str_buf_add(dst, "\"type\":\"");
        str_buf_add_nchar(dst, field->mime, field->mime_len);
        str_buf_add(dst, "\", \"encoding\":\"base64\", \"value\":\"");
        binary_field_value_print(dst, field);
        str_buf_add(dst, "\"}");
}

void binary_field_value_print(str_buf *dst, const binary_field *field)
{
        base64_encodestate state;
        base64_init_encodestate(&state);

        size_t required_buff_size = 3 * (field->blob_len + 1);
        char *buffer = malloc(required_buff_size);
        ZERO_MEMORY(buffer, required_buff_size);
        memcpy(buffer, field->blob, field->blob_len);

        u64 code_len = base64_encode_block(buffer, field->blob_len + 2,
                                           code_of(buffer, field->blob_len), &state);
        base64_encode_blockend(code_of(buffer, field->blob_len), &state);
        str_buf_add_nchar(dst, code_of(buffer, field->blob_len), code_len);
        free(buffer);
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements an (read-/write) iterator for (JSON) arrays in carbon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/mime.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/internal.h>

bool col_it_create(col_it *it, memfile *memfile, offset_t begin)
{
        it->begin = begin;
        it->mod_size = 0;

        MEMFILE_OPEN(&it->file, memfile->memblock, memfile->mode);
        MEMFILE_SEEK(&it->file, begin);

#ifndef NDEBUG
        ERROR_IF_AND_RETURN(MEMFILE_REMAIN_SIZE(&it->file) < sizeof(u8) + sizeof(media_type), ERR_CORRUPTED, NULL);
#endif

        u8 marker = *MEMFILE_READ(&it->file, sizeof(u8));

        if (!abstract_is_instanceof_column(marker)) {
            return ERROR(ERR_ILLEGALOP, "column begin marker or sub type expected");
        }

        abstract_type_class_e type_class = abstract_get_class(marker);
        it->list_type = abstract_class_to_list_derivable(type_class);


        field_e type = (field_e) marker;
        it->field_type = type;

        it->header_begin = MEMFILE_TELL(&it->file);
        it->num = (u32) MEMFILE_READ_UINTVAR_STREAM(NULL, &it->file);
        it->cap = (u32) MEMFILE_READ_UINTVAR_STREAM(NULL, &it->file);

        col_it_rewind(it);

        return true;
}

void internal_col_it_skip__fast(col_it *col)
{
        u32 skip = col->cap * INTERNAL_GET_TYPE_VALUE_SIZE(col->field_type);
        MEMFILE_SEEK__UNSAFE(&col->file, col->header_begin +
                                       UINTVAR_STREAM_REQUIRED_BLOCKS(col->num) +
                                       UINTVAR_STREAM_REQUIRED_BLOCKS(col->cap) + skip);
}

bool col_it_clone(col_it *dst, col_it *src)
{
        MEMFILE_CLONE(&dst->file, &src->file);
        dst->header_begin = src->header_begin;
        dst->begin = src->begin;
        dst->field_type = src->field_type;
        dst->list_type = src->list_type;
        dst->mod_size = src->mod_size;
        dst->cap = src->cap;
        dst->num = src->num;
        return true;
}

bool col_it_insert(insert *in, col_it *it)
{
        return internal_insert_create_for_column(in, it);
}

bool col_it_fast_forward(col_it *it)
{
        COL_IT_VALUES(NULL, NULL, it);
        return true;
}

offset_t col_it_memfilepos(col_it *it)
{
        if (LIKELY(it != NULL)) {
                return MEMFILE_TELL(&it->file);
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return 0;
        }
}

void *col_it_memfile_raw(col_it *it)
{
        return MEMFILE_RAW_DATA(&it->file);
}

offset_t col_it_tell(col_it *it, u32 elem_idx)
{
        if (it) {
                MEMFILE_SAVE_POSITION(&it->file);
                MEMFILE_SEEK(&it->file, it->header_begin);
                u32 num_elements = (u32) MEMFILE_READ_UINTVAR_STREAM(NULL, &it->file);
                MEMFILE_READ_UINTVAR_STREAM(NULL, &it->file);
                offset_t payload_start = MEMFILE_TELL(&it->file);
                ERROR_IF_AND_RETURN(elem_idx >= num_elements, ERR_OUTOFBOUNDS, NULL);
                offset_t ret = payload_start + elem_idx * INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type);
                MEMFILE_RESTORE_POSITION(&it->file);
                return ret;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return 0;
        }
}

bool col_it_is_null(col_it *it, u32 pos)
{
        field_e type;
        u32 nvalues = COL_IT_VALUES_INFO(&type, it);
        ERROR_IF_AND_RETURN(pos >= nvalues, ERR_OUTOFBOUNDS, NULL);
        switch (type) {
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET: {
                        const u8 *values = COL_IT_U8_VALUES(NULL, it);
                        return IS_NULL_U8(values[pos]);
                }
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET: {
                        const u16 *values = COL_IT_U16_VALUES(NULL, it);
                        return IS_NULL_U16(values[pos]);
                }
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET: {
                        const u32 *values = COL_IT_U32_VALUES(NULL, it);
                        return IS_NULL_U32(values[pos]);
                }
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET: {
                        const u64 *values = COL_IT_U64_VALUES(NULL, it);
                        return IS_NULL_U64(values[pos]);
                }
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET: {
                        const i8 *values = COL_IT_I8_VALUES(NULL, it);
                        return IS_NULL_I8(values[pos]);
                }
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET: {
                        const i16 *values = COL_IT_I16_VALUES(NULL, it);
                        return IS_NULL_I16(values[pos]);
                }
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET: {
                        const i32 *values = COL_IT_I32_VALUES(NULL, it);
                        return IS_NULL_I32(values[pos]);
                }
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                        const i64 *values = COL_IT_I64_VALUES(NULL, it);
                        return IS_NULL_I64(values[pos]);
                }
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET: {
                        const float *values = COL_IT_FLOAT_VALUES(NULL, it);
                        return IS_NULL_FLOAT(values[pos]);
                }
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                        const boolean *values = COL_IT_BOOLEAN_VALUES(NULL, it);
                        return IS_NULL_BOOLEAN(values[pos]);
                }
                default:
                        return ERROR(ERR_UNSUPPCONTAINER, NULL);
        }
}

bool col_it_is_boolean(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_u8(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_u16(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_u32(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_u64(col_it *it)
{
        {
                switch (it->field_type) {
                        case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                                return true;
                        default:
                                return false;
                }
        }
}

bool col_it_is_i8(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_i16(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_i32(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_i64(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

bool col_it_is_float(col_it *it)
{
        switch (it->field_type) {
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                        return true;
                default:
                        return false;
        }
}

const boolean *internal_col_it_boolean_values(u32 *nvalues, col_it *it)
{
        return COL_IT_BOOLEAN_VALUES(nvalues, it);
}

const u8 *internal_col_it_u8_values(u32 *nvalues, col_it *it)
{
        return COL_IT_U8_VALUES(nvalues, it);
}

const u16 *internal_col_it_u16_values(u32 *nvalues, col_it *it)
{
        return COL_IT_U16_VALUES(nvalues, it);
}

const u32 *internal_col_it_u32_values(u32 *nvalues, col_it *it)
{
        return COL_IT_U32_VALUES(nvalues, it);
}

const u64 *internal_col_it_u64_values(u32 *nvalues, col_it *it)
{
        return COL_IT_U64_VALUES(nvalues, it);
}

const i8 *internal_col_it_i8_values(u32 *nvalues, col_it *it)
{
        return COL_IT_I8_VALUES(nvalues, it);
}

const i16 *internal_col_it_i16_values(u32 *nvalues, col_it *it)
{
        return COL_IT_I16_VALUES(nvalues, it);
}

const i32 *internal_col_it_i32_values(u32 *nvalues, col_it *it)
{
        return COL_IT_I32_VALUES(nvalues, it);
}

const i64 *internal_col_it_i64_values(u32 *nvalues, col_it *it)
{
        return COL_IT_I64_VALUES(nvalues, it);
}

const float *internal_col_it_float_values(u32 *nvalues, col_it *it)
{
        return COL_IT_FLOAT_VALUES(nvalues, it);
}

bool col_it_remove(col_it *it, u32 pos)
{
        ERROR_IF_AND_RETURN(pos >= it->num, ERR_OUTOFBOUNDS, NULL);
        MEMFILE_SAVE_POSITION(&it->file);

        offset_t payload_start = internal_column_get_payload_off(it);

        /** remove element */
        size_t elem_size = INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type);
        MEMFILE_SEEK(&it->file, payload_start + pos * elem_size);
        MEMFILE_INPLACE_REMOVE(&it->file, elem_size);

        /** add an empty element at the end to restore the column capacity property */
        MEMFILE_SEEK(&it->file, payload_start + it->num * elem_size);
        MEMFILE_INPLACE_INSERT(&it->file, elem_size);

        /** update element counter */
        MEMFILE_SEEK(&it->file, it->header_begin);
        u32 num_elems = MEMFILE_PEEK_UINTVAR_STREAM(NULL, &it->file);
        assert(num_elems > 0);
        num_elems--;
        signed_offset_t shift = MEMFILE_UPDATE_UINTVAR_STREAM(&it->file, num_elems);
        it->num = num_elems;

        MEMFILE_RESTORE_POSITION(&it->file);
        MEMFILE_SEEK_FROM_HERE(&it->file, shift);

        return true;
}

bool col_it_is_multiset(col_it *it)
{
        abstract_type_class_e type_class = abstract_list_derivable_to_class(it->list_type);
        return abstract_is_multiset(type_class);
}

bool col_it_is_sorted(col_it *it)
{
        abstract_type_class_e type_class = abstract_list_derivable_to_class(it->list_type);
        return abstract_is_sorted(type_class);
}

bool col_it_update_type(col_it *it, list_type_e derivation)
{
        if (!FIELD_IS_COLUMN_OR_SUBTYPE(it->field_type)) {
                return false;
        }

        MEMFILE_SAVE_POSITION(&it->file);
        MEMFILE_SEEK(&it->file, it->begin);

        list_container_e container;
        list_by_column_type(&container, it->field_type);
        derived_e derive_marker = abstract_derive_list_to(container, derivation);
        abstract_write_derived_type(&it->file, derive_marker);

        MEMFILE_RESTORE_POSITION(&it->file);

        return true;
}

bool col_it_set_null(col_it *it, u32 pos)
{
        ERROR_IF_AND_RETURN(pos >= it->num, ERR_OUTOFBOUNDS, NULL)

        MEMFILE_SAVE_POSITION(&it->file);

        offset_t payload_start = internal_column_get_payload_off(it);
        MEMFILE_SEEK(&it->file, payload_start + pos * INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type));

        switch (it->field_type) {
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                        u8 null_value = CARBON_BOOLEAN_COLUMN_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u8));
                }
                        break;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET: {
                        u8 null_value = U8_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u8));
                }
                        break;
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET: {
                        u16 null_value = U16_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u16));
                }
                        break;
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET: {
                        u32 null_value = U32_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u32));
                }
                        break;
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET: {
                        u64 null_value = U64_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u64));
                }
                        break;
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET: {
                        i8 null_value = I8_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i8));
                }
                        break;
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET: {
                        i16 null_value = I16_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i16));
                }
                        break;
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET: {
                        i32 null_value = I32_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i32));
                }
                        break;
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                        i64 null_value = I64_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i64));
                }
                        break;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET: {
                        float null_value = CARBON_NULL_FLOAT;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(float));
                }
                        break;
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        MEMFILE_RESTORE_POSITION(&it->file);
                        return ERROR(ERR_UNSUPPCONTAINER, NULL);
                default:
                        MEMFILE_RESTORE_POSITION(&it->file);
                        ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }

        MEMFILE_RESTORE_POSITION(&it->file);

        return true;
}

#define push_array_element(num_values, data, data_cast_type, null_check, insert_func)                                  \
for (u32 i = 0; i < num_values; i++) {                                                                                 \
        data_cast_type datum = ((data_cast_type *)data)[i];                                                            \
        if (LIKELY(null_check(datum) == false)) {                                                                      \
                insert_func(&array_ins);                                                                               \
        } else {                                                                                                       \
                insert_null(&array_ins);                                                                         \
        }                                                                                                              \
}

#define push_array_element_wvalue(num_values, data, data_cast_type, null_check, insert_func)                           \
for (u32 i = 0; i < num_values; i++) {                                                                                 \
        data_cast_type datum = ((data_cast_type *)data)[i];                                                            \
        if (LIKELY(null_check(datum) == false)) {                                                                      \
                insert_func(&array_ins, datum);                                                                        \
        } else {                                                                                                       \
                insert_null(&array_ins);                                                                         \
        }                                                                                                              \
}

static bool rewrite_column_to_array(col_it *it)
{
        abstract_type_class_e type_class;
        list_type_e list_type;
        arr_it array;
        insert array_ins;

        MEMFILE_SAVE_POSITION(&it->file);
        u8 marker = MEMFILE_PEEK_BYTE(&it->file);
        assert(FIELD_IS_COLUMN_OR_SUBTYPE(marker));

        type_class = abstract_get_class(marker);
        list_type = abstract_class_to_list_derivable(type_class);

        /** Potentially tailing space after the last ']' marker of the outer most array is used for temporary space */
        MEMFILE_SEEK_TO_END(&it->file);
        offset_t array_marker_begin = MEMFILE_TELL(&it->file);

        size_t capacity = it->num * INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type);
        internal_insert_array(&it->file, list_type, capacity);
        internal_arr_it_create(&array, &it->file, array_marker_begin);
        arr_it_insert_begin(&array_ins, &array);

        field_e type;
        u32 num_values;
        const void *data = COL_IT_VALUES(&type, &num_values, it);
        switch (type) {
                case FIELD_NULL:
                        while (num_values--) {
                                insert_null(&array_ins);
                        }
                        break;
                case FIELD_TRUE:
                        push_array_element(num_values, data, u8, IS_NULL_BOOLEAN, insert_true);
                        break;
                case FIELD_FALSE:
                        push_array_element(num_values, data, u8, IS_NULL_BOOLEAN, insert_false);
                        break;
                case FIELD_NUMBER_U8:
                        push_array_element_wvalue(num_values, data, u8, IS_NULL_U8, insert_u8);
                        break;
                case FIELD_NUMBER_U16:
                        push_array_element_wvalue(num_values, data, u16, IS_NULL_U16, insert_u16);
                        break;
                case FIELD_NUMBER_U32:
                        push_array_element_wvalue(num_values, data, u32, IS_NULL_U32, insert_u32);
                        break;
                case FIELD_NUMBER_U64:
                        push_array_element_wvalue(num_values, data, u64, IS_NULL_U64, insert_u64);
                        break;
                case FIELD_NUMBER_I8:
                        push_array_element_wvalue(num_values, data, i8, IS_NULL_I8, insert_i8);
                        break;
                case FIELD_NUMBER_I16:
                        push_array_element_wvalue(num_values, data, i16, IS_NULL_I16, insert_i16);
                        break;
                case FIELD_NUMBER_I32:
                        push_array_element_wvalue(num_values, data, i32, IS_NULL_I32, insert_i32);
                        break;
                case FIELD_NUMBER_I64:
                        push_array_element_wvalue(num_values, data, i64, IS_NULL_I64, insert_i64);
                        break;
                case FIELD_NUMBER_FLOAT:
                        push_array_element_wvalue(num_values, data, float, IS_NULL_FLOAT, insert_float);
                        break;
                default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                        return false;
        }

        arr_it_insert_end(&array_ins);
        assert(array_marker_begin < internal_arr_it_memfilepos(&array));

        MEMFILE_RESTORE_POSITION(&it->file);
        return true;
}

bool col_it_set_true(col_it *it, u32 pos)
{
        ERROR_IF_AND_RETURN(pos >= it->num, ERR_OUTOFBOUNDS, NULL)

        MEMFILE_SAVE_POSITION(&it->file);

        offset_t payload_start = internal_column_get_payload_off(it);
        MEMFILE_SEEK(&it->file, payload_start + pos * INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type));

        switch (it->field_type) {
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                        u8 value = CARBON_BOOLEAN_COLUMN_TRUE;
                        MEMFILE_WRITE(&it->file, &value, sizeof(u8));
                }
                        break;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET: {
                        u8 null_value = U8_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u8));
                }
                        break;
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET: {
                        u16 null_value = U16_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u16));
                }
                        break;
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET: {
                        //u32 null_value = U32_NULL;
                        //MEMFILE_WRITE(&it->mem, &null_value, sizeof(u32));
                        rewrite_column_to_array(it);


                }
                        break;
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET: {
                        u64 null_value = U64_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(u64));
                }
                        break;
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET: {
                        i8 null_value = I8_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i8));
                }
                        break;
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET: {
                        i16 null_value = I16_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i16));
                }
                        break;
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET: {
                        i32 null_value = I32_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i32));
                }
                        break;
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                        i64 null_value = I64_NULL;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(i64));
                }
                        break;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET: {
                        float null_value = CARBON_NULL_FLOAT;
                        MEMFILE_WRITE(&it->file, &null_value, sizeof(float));
                }
                        break;
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        MEMFILE_RESTORE_POSITION(&it->file);
                        return ERROR(ERR_UNSUPPCONTAINER, NULL);
                default:
                        MEMFILE_RESTORE_POSITION(&it->file);
                        ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }

        MEMFILE_RESTORE_POSITION(&it->file);

        return true;
}

bool col_it_set_false(col_it *it, u32 pos)
{
        UNUSED(it)
        UNUSED(pos)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_u8(col_it *it, u32 pos, u8 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_u16(col_it *it, u32 pos, u16 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_u32(col_it *it, u32 pos, u32 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_u64(col_it *it, u32 pos, u64 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_i8(col_it *it, u32 pos, i8 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_i16(col_it *it, u32 pos, i16 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_i32(col_it *it, u32 pos, i32 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_i64(col_it *it, u32 pos, i64 value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_set_float(col_it *it, u32 pos, float value)
{
        UNUSED(it)
        UNUSED(pos)
        UNUSED(value)
        ERROR(ERR_NOTIMPLEMENTED, NULL); // TODO: implement
        return false;
}

bool col_it_rewind(col_it *it)
{
        offset_t playload_start = internal_column_get_payload_off(it);
        ERROR_IF_AND_RETURN(playload_start >= MEMFILE_SIZE(&it->file), ERR_OUTOFBOUNDS, NULL);
        return MEMFILE_SEEK(&it->file, playload_start);
}

#define COL_IT_PRINT(it, nvalues, type, null_check)                                             \
{                                                                                               \
        const type *value = internal_col_it_##type##_values(&nvalues, it);                               \
        for (u32 i = 0; i < nvalues; i++) {                                                     \
                type x = value[i];                                                              \
                if (null_check(x)) {                                                            \
                        str_buf_add(dst, "null");                                               \
                } else {                                                                        \
                        str_buf_add_##type(dst, value[i]);                                      \
                }                                                                               \
                if (i + 1 < nvalues) {                                                          \
                        str_buf_add(dst, ", ");                                                 \
                }                                                                               \
        }                                                                                       \
}

bool col_it_print(str_buf *dst, col_it *it)
{
        u32 nvalues;

        str_buf_add_char(dst, '[');

        if (col_it_is_boolean(it)) {
                COL_IT_PRINT(it, nvalues, boolean, IS_NULL_BOOLEAN)
        } else if (col_it_is_i8(it)) {
                COL_IT_PRINT(it, nvalues, i8, IS_NULL_I8)
        } else if (col_it_is_i16(it)) {
                COL_IT_PRINT(it, nvalues, i16, IS_NULL_I16)
        } else if (col_it_is_i32(it)) {
                COL_IT_PRINT(it, nvalues, i32, IS_NULL_I32)
        } else if (col_it_is_i64(it)) {
                COL_IT_PRINT(it, nvalues, i64, IS_NULL_I64)
        } else if (col_it_is_u8(it)) {
                COL_IT_PRINT(it, nvalues, u8, IS_NULL_U8)
        } else if (col_it_is_u16(it)) {
                COL_IT_PRINT(it, nvalues, u16, IS_NULL_U16)
        } else if (col_it_is_u32(it)) {
                COL_IT_PRINT(it, nvalues, u32, IS_NULL_U32)
        } else if (col_it_is_u64(it)) {
                COL_IT_PRINT(it, nvalues, u64, IS_NULL_U64)
        } else if (col_it_is_float(it)) {
                COL_IT_PRINT(it, nvalues, float, IS_NULL_FLOAT)
        } else {
                str_buf_add_char(dst, ']');
                return ERROR(ERR_UNSUPPORTEDTYPE, "column has unsupported type");
        }

        str_buf_add_char(dst, ']');
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/carbon/commit.h>
#include <karbonit/stdx/unique_id.h>
#include <karbonit/std/hash.h>

bool commit_create(memfile *file)
{
        u64 init_rev = 0;
        unique_id_create(&init_rev);

        MEMFILE_ENSURE_SPACE(file, sizeof(u64));
        MEMFILE_WRITE(file, &init_rev, sizeof(u64));

        return true;
}

bool commit_skip(memfile *file)
{
        MEMFILE_SKIP(file, sizeof(u64));
        return true;
}

bool commit_read(u64 *commit_hash, memfile *file)
{
        *commit_hash = *MEMFILE_READ_TYPE(file, u64);
        return true;
}

bool commit_peek(u64 *commit_hash, memfile *file)
{
        *commit_hash = *MEMFILE_PEEK_TYPE(file, u64);
        return true;
}

bool commit_update(memfile *file, const char *base, u64 len)
{
        u64 commit_hash;
        commit_compute(&commit_hash, base, len);
        MEMFILE_WRITE(file, &commit_hash, sizeof(u64));
        return true;
}

bool commit_compute(u64 *commit_hash, const void *base, u64 len)
{
        *commit_hash = HASH64_FNV(len, base);
        return true;
}

const char *commit_to_str(str_buf *dst, u64 commit_hash)
{
        if (dst) {
                str_buf_clear(dst);
                str_buf_add_u64_as_hex(dst, commit_hash);
                return str_buf_cstr(dst);
        } else {
                return NULL;
        }
}

bool commit_append_to_str(str_buf *dst, u64 commit_hash)
{
        str_buf_add_u64_as_hex(dst, commit_hash);
        return true;
}

u64 commit_from_str(const char *commit_str)
{
        if (commit_str && strlen(commit_str) == 16) {
                char *illegal_char;
                errno = 0;
                u64 ret = strtoull(commit_str, &illegal_char, 16);
                if (ret == 0 && commit_str == illegal_char) {
                        return 0;
                } else if (ret == ULLONG_MAX && errno) {
                        return 0;
                } else if (*illegal_char) {
                        return 0;
                } else {
                        return ret;
                }
        } else {
                ERROR(ERR_ILLEGALARG, NULL);
                return 0;
        }
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/container.h>
#include <karbonit/carbon/field.h>

bool list_by_column_type(list_container_e *out, int field_type)
{
        switch (field_type) {
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                        *out = LIST_COLUMN_U8;
                        break;
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                        *out = LIST_COLUMN_U16;
                        break;
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                        *out = LIST_COLUMN_U32;
                        break;
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                        *out = LIST_COLUMN_U64;
                        break;
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                        *out = LIST_COLUMN_I8;
                        break;
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                        *out = LIST_COLUMN_I16;
                        break;
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                        *out = LIST_COLUMN_I32;
                        break;
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                        *out = LIST_COLUMN_I64;
                        break;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                        *out = LIST_COLUMN_FLOAT;
                        break;
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        *out = LIST_COLUMN_BOOLEAN;
                        break;
                default: ERROR(ERR_TYPEMISMATCH, NULL);
                        return false;
        }
        return true;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/dot-eval.h>
#include <karbonit/carbon/find.h>
#include <karbonit/carbon/revise.h>

static inline pstatus_e _dot_eval_traverse_column(dot_eval *state,
                                                  const dot *path, u32 current_path_pos,
                                                  col_it *it);

static inline pstatus_e _dot_eval_traverse_array(dot_eval *state,
                                                 const dot *path, u32 current_path_pos,
                                                 arr_it *it, bool is_record);

void dot_eval_exec(dot_eval *eval, const dot *path,
                   rec *doc)
{
        ZERO_MEMORY(eval, sizeof(dot_eval));
        eval->doc = doc;
        rec_read(&eval->root_it, eval->doc);
        eval->status = _dot_eval_traverse_array(eval, path, 0, &eval->root_it, true);
}

bool dot_eval_begin_mutable(dot_eval *eval, const dot *path,
                                         rev *context)
{
        eval->doc = context->revised;
        if (!revise_iterator_open(&eval->root_it, context)) {
            return ERROR(ERR_OPPFAILED, "revise iterator cannot be opened");
        }
        eval->status = _dot_eval_traverse_array(eval, path, 0, &eval->root_it, true);
        return true;
}

bool dot_eval_status(pstatus_e *status, dot_eval *state)
{
        *status = state->status;
        return true;
}

bool carbon_path_exists(rec *doc, const char *path)
{
        find find;
        find_from_string(&find, path, doc);
        bool result = find_has_result(&find);
        return result;
}

bool carbon_path_is_array(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_ARRAY_OR_SUBTYPE(field_type);
        }

        return result;
}

bool carbon_path_is_column(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_COLUMN_OR_SUBTYPE(field_type);
        }

        return result;
}

bool carbon_path_is_object(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_OBJECT_OR_SUBTYPE(field_type);
        }

        return result;
}

bool carbon_path_is_container(rec *doc, const char *path)
{
        return (carbon_path_is_array(doc, path) || carbon_path_is_column(doc, path) ||
                carbon_path_is_object(doc, path));
}

bool carbon_path_is_null(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_BASE_NULL(field_type);
        }

        return result;
}

bool carbon_path_is_number(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_NUMBER(field_type);
        }

        return result;
}

bool carbon_path_is_boolean(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_BOOLEAN(field_type);
        }

        return result;
}

bool carbon_path_is_string(rec *doc, const char *path)
{
        find find;
        field_e field_type;
        bool result = false;

        if (find_from_string(&find, path, doc)) {
                find_result_type(&field_type, &find);
                result = FIELD_IS_STRING(field_type);
        }

        return result;
}

static inline pstatus_e _dot_eval_traverse_object(dot_eval *state,
                                                  const dot *path, u32 current_path_pos,
                                                  obj_it *it)
{
        DECLARE_AND_INIT(dot_node_type_e, node_type)
        DECLARE_AND_INIT(u32, length)
        DECLARE_AND_INIT(bool, status)

        dot_type_at(&node_type, current_path_pos, path);
        assert(node_type == DOT_NODE_KEY);

        status = obj_it_next(it);
        dot_len(&length, path);
        const char *needle = dot_key_at(current_path_pos, path);
        u64 needle_len = strlen(needle);
        u32 next_path_pos = current_path_pos + 1;

        if (!status) {
                /** empty document */
                return PATH_EMPTY_DOC;
        } else {
                string_field prop_key;
                do {
                        prop_key = internal_obj_it_prop_name(it);
                        if (prop_key.len == needle_len && strncmp(prop_key.str, needle, needle_len) == 0) {
                                if (next_path_pos == length) {
                                        state->result.container = OBJECT;
                                        internal_obj_it_clone(&state->result.containers.object, it);
                                        return PATH_RESOLVED;
                                } else {
                                        /** path end not reached, traverse further if possible */
                                        assert(next_path_pos < length);

                                        field_e prop_type;
                                        internal_obj_it_prop_type(&prop_type, it);

                                        if (!FIELD_IS_TRAVERSABLE(prop_type)) {
                                                return PATH_NOTTRAVERSABLE;
                                        } else {
                                                assert(prop_type == FIELD_OBJECT_UNSORTED_MULTIMAP ||
                                                           prop_type == FIELD_DERIVED_OBJECT_SORTED_MULTIMAP ||
                                                           prop_type == FIELD_DERIVED_OBJECT_UNSORTED_MAP ||
                                                           prop_type == FIELD_DERIVED_OBJECT_SORTED_MAP ||
                                                           prop_type == FIELD_ARRAY_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_ARRAY_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_ARRAY_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_ARRAY_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_U8_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U8_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U8_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_U16_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U16_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U16_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_U32_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U32_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U32_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_U64_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U64_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_U64_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_I8_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I8_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I8_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_I16_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I16_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I16_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_I32_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I32_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I32_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_I64_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I64_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_I64_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_FLOAT_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET ||
                                                           prop_type == FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET ||
                                                           prop_type == FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET);
                                                switch (prop_type) {
                                                        case FIELD_OBJECT_UNSORTED_MULTIMAP:
                                                        case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                                                        case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                                                        case FIELD_DERIVED_OBJECT_SORTED_MAP: {
                                                                obj_it sub_it;
                                                                ITEM_GET_OBJECT(&sub_it, &(it->prop.value));
                                                                pstatus_e ret = _dot_eval_traverse_object(state,
                                                                                                          path,
                                                                                                          next_path_pos,
                                                                                                          &sub_it);
                                                                return ret;
                                                        }
                                                        case FIELD_ARRAY_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                                                        case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                                                        case FIELD_DERIVED_ARRAY_SORTED_SET: {
                                                                arr_it sub_it;
                                                                ITEM_GET_ARRAY(&sub_it, &(it->prop.value));
                                                                pstatus_e ret = _dot_eval_traverse_array(state,
                                                                                                         path,
                                                                                                         next_path_pos,
                                                                                                         &sub_it,
                                                                                                         false);
                                                                return ret;
                                                        }
                                                        case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                                                        case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                                                        case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                                                        case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                                                        case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                                                        case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                                                        case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                                                        case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                                                        case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                                                        case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                                                        case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                                                        case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                                                                col_it sub_it;
                                                                ITEM_GET_COLUMN(&sub_it, &(it->prop.value));
                                                                return _dot_eval_traverse_column(state,
                                                                                                 path,
                                                                                                 next_path_pos,
                                                                                                 &sub_it);
                                                        }
                                                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                                return PATH_INTERNAL;
                                                }
                                        }
                                }
                        }
                } while (obj_it_next(it));
        }

        return PATH_NOSUCHKEY;
}

static inline pstatus_e _dot_eval_traverse_array(dot_eval *state,
                                                     const dot *path, u32 current_path_pos,
                                                     arr_it *it, bool is_record)
{
        assert(state);
        assert(path);
        assert(it);
        assert(current_path_pos < VEC_LENGTH(&path->nodes));

        DECLARE_AND_INIT(field_e, elem_type)
        DECLARE_AND_INIT(dot_node_type_e, node_type)
        DECLARE_AND_INIT(u32, length)
        DECLARE_AND_INIT(pstatus_e, status)
        DECLARE_AND_INIT(u32, requested_array_idx)
        DECLARE_AND_INIT(u32, current_array_idx)

        dot_type_at(&node_type, current_path_pos, path);

        dot_len(&length, path);

        if (!arr_it_next(it)) {
                /** empty document */
                return PATH_EMPTY_DOC;
        } else {
                bool is_unit_array = arr_it_is_unit(it);
                switch (node_type) {
                        case DOT_NODE_IDX:
                                dot_idx_at(&requested_array_idx, current_path_pos, path);

                                while (current_array_idx < requested_array_idx && arr_it_next(it)) {
                                        current_array_idx++;
                                }
                                assert(current_array_idx <= requested_array_idx);
                                if (current_array_idx != requested_array_idx) {
                                        /** root array has too less elements to reach the requested index */
                                        return PATH_NOSUCHINDEX;
                                }

                                /** requested index is reached; depending on the subsequent path, lookup may stops */
                                arr_it_field_type(&elem_type, it);
                                u32 next_path_pos = current_path_pos + 1;
                                if (is_unit_array && is_record &&
                                        FIELD_IS_COLUMN_OR_SUBTYPE(elem_type)) {
                                        col_it sub_it;
                                        ITEM_GET_COLUMN(&sub_it, &(it->item));
                                        return _dot_eval_traverse_column(state,
                                                                         path,
                                                                         next_path_pos,
                                                                         &sub_it);
                                } else {
                                        if (next_path_pos < length) {
                                                /** path must be further evaluated in the next step, which requires a container
                                                 * type (for traversability) */
                                                dot_node_type_e next_node_type;
                                                dot_type_at(&next_node_type, next_path_pos, path);
                                                if (!FIELD_IS_TRAVERSABLE(elem_type)) {
                                                        /** the array element is not a container; path evaluation stops here */
                                                        return PATH_NOTTRAVERSABLE;
                                                } else {
                                                        /** array element is traversable */
                                                        switch (next_node_type) {
                                                                case DOT_NODE_IDX:
                                                                        /** next node in path is an array index which requires that
                                                                         * the current array element is an array or column */
                                                                        if (!FIELD_IS_LIST_OR_SUBTYPE(elem_type)) {
                                                                                return PATH_NOCONTAINER;
                                                                        } else {
                                                                                if (FIELD_IS_ARRAY_OR_SUBTYPE(elem_type)) {
                                                                                        arr_it sub_it;
                                                                                        ITEM_GET_ARRAY(&sub_it, &(it->item));
                                                                                        status = _dot_eval_traverse_array(
                                                                                                state,
                                                                                                path,
                                                                                                next_path_pos,
                                                                                                &sub_it, false);
                                                                                        return status;
                                                                                } else {
                                                                                        assert(FIELD_IS_COLUMN_OR_SUBTYPE(elem_type));
                                                                                        col_it sub_it;
                                                                                        ITEM_GET_COLUMN(&sub_it, &(it->item));
                                                                                        return _dot_eval_traverse_column(
                                                                                                state,
                                                                                                path,
                                                                                                next_path_pos,
                                                                                                &sub_it);
                                                                                }
                                                                        }
                                                                case DOT_NODE_KEY:
                                                                        /** next node in path is a key name which requires that
                                                                         * the current array element is of type object */
                                                                        if (!FIELD_IS_OBJECT_OR_SUBTYPE(
                                                                                elem_type)) {
                                                                                return PATH_NOTANOBJECT;
                                                                        } else {
                                                                                obj_it sub_it;
                                                                                ITEM_GET_OBJECT(&sub_it, &(it->item));
                                                                                status = _dot_eval_traverse_object(
                                                                                        state,
                                                                                        path,
                                                                                        next_path_pos,
                                                                                        &sub_it);
                                                                                return status;
                                                                        }
                                                                default: ERROR(ERR_INTERNALERR, NULL);
                                                                        return PATH_INTERNAL;
                                                        }
                                                }
                                        } else {
                                                /** path end is reached */
                                                state->result.container = ARRAY;
                                                internal_arr_it_clone(&state->result.containers.array, it);
                                                return PATH_RESOLVED;
                                        }
                                }

                case DOT_NODE_KEY:
                        /** first array element exists, which must be of type object */
                        arr_it_field_type(&elem_type, it);
                        if (!FIELD_IS_OBJECT_OR_SUBTYPE(elem_type)) {
                                /** first array element is not of type object and a key lookup cannot
                                 * be executed, consequentially */
                                return PATH_NOTANOBJECT;
                        } else {
                                /** next node in path is a key name which requires that
                                                                 * the current array element is of type object */
                                if (!FIELD_IS_OBJECT_OR_SUBTYPE(elem_type)) {
                                        return PATH_NOTANOBJECT;
                                } else {
                                        if (is_unit_array && is_record) {
                                                obj_it sub_it;
                                                ITEM_GET_OBJECT(&sub_it, &(it->item));
                                                status = _dot_eval_traverse_object(state,
                                                                                   path,
                                                                                   current_path_pos,
                                                                                   &sub_it);
                                                return status;
                                        } else {
                                                return PATH_NOSUCHKEY;
                                        }
                                }
                        }
                                break;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                return PATH_INTERNAL;
                }
        }
}

static inline pstatus_e _dot_eval_traverse_column(dot_eval *state,
                                                      const dot *path, u32 current_path_pos,
                                                      col_it *it)
{
        DECLARE_AND_INIT(u32, total_len)
        DECLARE_AND_INIT(u32, requested_idx)
        DECLARE_AND_INIT(u32, nun_values_contained)
        DECLARE_AND_INIT(dot_node_type_e, node_type)
        DECLARE_AND_INIT(field_e, column_type)
        dot_len(&total_len, path);
        if (current_path_pos + 1 != total_len) {
                /** a column cannot contain further containers; since the current path node is not
                 * the last one, traversal cannot be continued */
                return PATH_NONESTING;
        } else {
                dot_type_at(&node_type, current_path_pos, path);
                assert(node_type == DOT_NODE_IDX);
                dot_idx_at(&requested_idx, current_path_pos, path);
                nun_values_contained = COL_IT_VALUES_INFO(&column_type, it);
                if (requested_idx >= nun_values_contained) {
                        /** requested index does not exists in this column */
                        return PATH_NOSUCHINDEX;
                } else {
                        state->result.container = COLUMN;
                        col_it_clone(&state->result.containers.column.it, it);
                        state->result.containers.column.elem_pos = requested_idx;
                        return PATH_RESOLVED;
                }
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <ctype.h>
#include <karbonit/utils/convert.h>
#include <karbonit/carbon/dot.h>
#include <karbonit/std/string.h>
#include <karbonit/utils/strings.h>

enum dot_token_type {
        TOKEN_DOT,
        TOKEN_STRING,
        TOKEN_NUMBER,
        TOKEN_UNKNOWN,
        TOKEN_EOF
};

struct dot_token {
        enum dot_token_type type;
        const char *str;
        u32 len;
};

static const char *next_token(struct dot_token *token, const char *str)
{
        assert(token);
        assert(str);

        str = strings_skip_blanks(str);
        char c = *str;
        if (c) {
                if (isalpha(c)) {
                        token->type = TOKEN_STRING;
                        token->str = str;
                        bool skip_esc = false;
                        u32 strlen = 0;
                        while (c && (isalpha(c) && (c != '\n') && (c != '\t') && (c != '\r') && (c != ' '))) {
                                if (!skip_esc) {
                                        if (c == '\\') {
                                                skip_esc = true;
                                        }
                                } else {
                                        skip_esc = false;
                                }
                                strlen++;
                                c = *(++str);
                        }
                        token->len = strlen;
                } else if (c == '\"') {
                        token->type = TOKEN_STRING;
                        token->str = str;
                        c = *(++str);
                        bool skip_esc = false;
                        bool end_found = false;
                        u32 strlen = 1;
                        while (c && !end_found) {
                                if (!skip_esc) {
                                        if (c == '\\') {
                                                skip_esc = true;
                                        } else if (c == '\"') {
                                                end_found = true;
                                        }
                                } else {
                                        skip_esc = false;
                                }

                                strlen++;
                                c = *(++str);
                        }
                        token->len = strlen;
                } else if (c == '.') {
                        token->type = TOKEN_DOT;
                        token->str = str;
                        token->len = 1;
                        str++;
                } else if (isdigit(c)) {
                        token->type = TOKEN_NUMBER;
                        token->str = str;
                        u32 strlen = 0;
                        while (c && isdigit(c)) {
                                c = *(++str);
                                strlen++;
                        }
                        token->len = strlen;
                } else {
                        token->type = TOKEN_UNKNOWN;
                        token->str = str;
                        token->len = strlen(str);
                }
        } else {
                token->type = TOKEN_EOF;
        }
        return str;
}

bool dot_create(dot *path)
{
        vec_create(&path->nodes, sizeof(dot_node), 256);
        return true;
}

void dot_clear(dot *path)
{
        vec_clear(&path->nodes);
}

bool dot_from_string(dot *path, const char *path_string)
{
        UNUSED(path_string);

        struct dot_token token;
        int status = ERR_NOERR;
        dot_create(path);

        enum path_entry {
                DOT, ENTRY
        } expected_entry = ENTRY;
        path_string = next_token(&token, path_string);
        while (token.type != TOKEN_EOF) {
                expected_entry = token.type == TOKEN_DOT ? DOT : ENTRY;
                switch (token.type) {
                        case TOKEN_DOT:
                                if (expected_entry != DOT) {
                                        status = ERR_PARSE_DOT_EXPECTED;
                                        goto cleanup_and_error;
                                }
                                break;
                        case TOKEN_STRING:
                                if (expected_entry != ENTRY) {
                                        status = ERR_PARSE_ENTRY_EXPECTED;
                                        goto cleanup_and_error;
                                } else {
                                        dot_add_nkey(path, token.str, token.len);
                                }
                                break;
                        case TOKEN_NUMBER:
                                if (expected_entry != ENTRY) {
                                        status = ERR_PARSE_ENTRY_EXPECTED;
                                        goto cleanup_and_error;
                                } else {
                                        u64 num = convert_atoiu64(token.str);
                                        dot_add_idx(path, num);
                                }
                                break;
                        case TOKEN_UNKNOWN:
                                status = ERR_PARSE_UNKNOWN_TOKEN;
                                goto cleanup_and_error;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                break;
                }
                path_string = next_token(&token, path_string);
        }

        return true;

        cleanup_and_error:
        dot_drop(path);
        ERROR(status, NULL);
        return false;
}

void dot_add_key(dot *dst, const char *key)
{
        dot_add_nkey(dst, key, strlen(key));
}

void dot_add_nkey(dot *dst, const char *key, size_t len)
{
        dot_node *node = VEC_NEW_AND_GET(&dst->nodes, dot_node);
        bool enquoted = strings_is_enquoted_wlen(key, len);
        node->type = DOT_NODE_KEY;
        node->name.string = strndup(enquoted ? key + 1 : key, len);
        if (enquoted) {
                char *str_wo_rightspaces = strings_remove_tailing_blanks(node->name.string);
                size_t l = strlen(str_wo_rightspaces);
                node->name.string[l - 1] = '\0';
        }
        assert(!strings_is_enquoted(node->name.string));
}

void dot_add_idx(dot *dst, u32 idx)
{
        dot_node *node = VEC_NEW_AND_GET(&dst->nodes, dot_node);
        node->type = DOT_NODE_IDX;
        node->name.idx = idx;
}

bool dot_len(u32 *len, const dot *path)
{
        *len = VEC_LENGTH(&path->nodes);
        return true;
}

bool dot_is_empty(const dot *path)
{
        return (VEC_LENGTH(&path->nodes) == 0);
}

bool dot_type_at(dot_node_type_e *type_out, u32 pos, const dot *path)
{
        if (LIKELY(pos < VEC_LENGTH(&path->nodes))) {
                *type_out = VEC_GET(&path->nodes, pos, dot_node)->type;
        } else {
                return ERROR(ERR_OUTOFBOUNDS, NULL);
        }
        return true;
}

bool dot_idx_at(u32 *idx, u32 pos, const dot *path)
{
        ERROR_IF_AND_RETURN(pos >= VEC_LENGTH(&path->nodes), ERR_OUTOFBOUNDS, NULL);
        ERROR_IF_AND_RETURN(VEC_GET(&path->nodes, pos, dot_node)->type != DOT_NODE_IDX, ERR_TYPEMISMATCH, NULL);

        *idx = VEC_GET(&path->nodes, pos, dot_node)->name.idx;
        return true;
}

const char *dot_key_at(u32 pos, const dot *path)
{
        ERROR_IF_AND_RETURN(pos >= VEC_LENGTH(&path->nodes), ERR_OUTOFBOUNDS, NULL);
        ERROR_IF_AND_RETURN(VEC_GET(&path->nodes, pos, dot_node)->type != DOT_NODE_KEY, ERR_TYPEMISMATCH, NULL);

        return VEC_GET(&path->nodes, pos, dot_node)->name.string;
}

bool dot_drop(dot *path)
{
        for (u32 i = 0; i < VEC_LENGTH(&path->nodes); i++) {
                dot_node *node = VEC_GET(&path->nodes, i, dot_node);
                if (node->type == DOT_NODE_KEY) {
                        free(node->name.string);
                }
        }
        vec_drop(&path->nodes);
        return true;
}

bool dot_to_str(str_buf *sb, dot *path)
{
        for (u32 i = 0; i < VEC_LENGTH(&path->nodes); i++) {
                dot_node *node = VEC_GET(&path->nodes, i, dot_node);
                switch (node->type) {
                        case DOT_NODE_KEY: {
                                bool empty_str = strlen(node->name.string) == 0;
                                bool quotes_required =
                                        empty_str || strings_contains_blank_char(node->name.string);
                                if (quotes_required) {
                                        str_buf_add_char(sb, '"');
                                }
                                if (!empty_str) {
                                        str_buf_add(sb, node->name.string);
                                }
                                if (quotes_required) {
                                        str_buf_add_char(sb, '"');
                                }
                        }
                                break;
                        case DOT_NODE_IDX:
                                str_buf_add_u32(sb, node->name.idx);
                                break;
                }
                if (i + 1 < VEC_LENGTH(&path->nodes)) {
                        str_buf_add_char(sb, '.');
                }
        }
        return true;
}

bool dot_fprint(FILE *file, dot *path)
{
        str_buf sb;
        str_buf_create(&sb);
        dot_to_str(&sb, path);
        fprintf(file, "%s", str_buf_cstr(&sb));
        str_buf_drop(&sb);
        return true;
}

bool dot_print(dot *path)
{
        return dot_fprint(stdout, path);
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/mem/memfile.h>
#include <karbonit/carbon/field.h>
#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/mime.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/abstract.h>

inline const char *field_str(field_e type)
{
        switch (type) {
                case FIELD_NULL:
                        return NULL_STR;
                case FIELD_TRUE:
                        return TRUE_STR;
                case FIELD_FALSE:
                        return FALSE_STR;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                        return OBJECT_UNSORTED_MULTIMAP_STR;
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                        return OBJECT_SORTED_MULTIMAP_STR;
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                        return OBJECT_UNSORTED_MAP_STR;
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                        return OBJECT_SORTED_MAP_STR;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                        return ARRAY_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                        return ARRAY_SORTED_MULTISET_STR;
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                        return ARRAY_UNSORTED_SET_STR;
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                        return ARRAY_SORTED_SET_STR;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                        return COLUMN_U8_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                        return COLUMN_U8_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                        return COLUMN_U8_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                        return COLUMN_U8_SORTED_SET_STR;
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                        return COLUMN_U16_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                        return COLUMN_U16_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                        return COLUMN_U16_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                        return COLUMN_U16_SORTED_SET_STR;
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                        return COLUMN_U32_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                        return COLUMN_U32_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                        return COLUMN_U32_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                        return COLUMN_U32_SORTED_SET_STR;
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                        return COLUMN_U64_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                        return COLUMN_U64_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                        return COLUMN_U64_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                        return COLUMN_U64_SORTED_SET_STR;
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                        return COLUMN_I8_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                        return COLUMN_I8_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                        return COLUMN_I8_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                        return COLUMN_I8_SORTED_SET_STR;
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                        return COLUMN_I16_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                        return COLUMN_I16_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                        return COLUMN_I16_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                        return COLUMN_I16_SORTED_SET_STR;
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                        return COLUMN_I32_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                        return COLUMN_I32_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                        return COLUMN_I32_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                        return COLUMN_I32_SORTED_SET_STR;
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                        return COLUMN_I64_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                        return COLUMN_I64_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                        return COLUMN_I64_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                        return COLUMN_I64_SORTED_SET_STR;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                        return COLUMN_FLOAT_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                        return COLUMN_FLOAT_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                        return COLUMN_FLOAT_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                        return COLUMN_FLOAT_SORTED_SET_STR;
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                        return COLUMN_BOOLEAN_UNSORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                        return COLUMN_BOOLEAN_SORTED_MULTISET_STR;
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                        return COLUMN_BOOLEAN_UNSORTED_SET_STR;
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        return COLUMN_BOOLEAN_SORTED_SET_STR;
                case FIELD_STRING:
                        return STRING_STR;
                case FIELD_NUMBER_U8:
                        return NUMBER_U8_STR;
                case FIELD_NUMBER_U16:
                        return NUMBER_U16_STR;
                case FIELD_NUMBER_U32:
                        return NUMBER_U32_STR;
                case FIELD_NUMBER_U64:
                        return NUMBER_U64_STR;
                case FIELD_NUMBER_I8:
                        return NUMBER_I8_STR;
                case FIELD_NUMBER_I16:
                        return NUMBER_I16_STR;
                case FIELD_NUMBER_I32:
                        return NUMBER_I32_STR;
                case FIELD_NUMBER_I64:
                        return NUMBER_I64_STR;
                case FIELD_NUMBER_FLOAT:
                        return NUMBER_FLOAT_STR;
                case FIELD_BINARY_CUSTOM:
                case FIELD_BINARY:
                        return BINARY_STR;
                default:
                        ERROR(ERR_NOTFOUND, NULL);
                        return NULL;
        }
}

inline bool carbon_field_skip(memfile *file)
{
        u8 type_marker = *MEMFILE_PEEK_TYPE(file, u8);

        switch (type_marker) {
                case FIELD_NULL:
                        carbon_field_skip_null(file);
                        break;
                case FIELD_TRUE:
                case FIELD_FALSE:
                        carbon_field_skip_boolean(file);
                        break;
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_I8:
                        carbon_field_skip_8(file);
                        break;
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_I16:
                        carbon_field_skip_16(file);
                        break;
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_I32:
                        carbon_field_skip_32(file);
                        break;
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I64:
                        carbon_field_skip_64(file);
                        break;
                case FIELD_NUMBER_FLOAT:
                        carbon_field_skip_float(file);
                        break;
                case FIELD_STRING:
                        carbon_field_skip_string(file);
                        break;
                case FIELD_BINARY:
                        carbon_field_skip_binary(file);
                        break;
                case FIELD_BINARY_CUSTOM:
                        carbon_field_skip_custom_binary(file);
                        break;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                        carbon_field_skip_array(file, type_marker);
                        break;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        carbon_field_skip_column(file);
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                        carbon_field_skip_object(file, type_marker);
                        break;
                default: ERROR(ERR_CORRUPTED, NULL);
                        return false;
        }
        return true;
}

inline bool carbon_field_skip_object(memfile *file, u8 marker)
{
        if (abstract_is_instanceof_object(marker)) {
                obj_it skip_it;
                internal_obj_it_create(&skip_it, file, MEMFILE_TELL(file));
                internal_obj_it_fast_forward(&skip_it);
                MEMFILE_SEEK(file, MEMFILE_TELL(&skip_it.file));
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, "marker does not encode an object container or sub type");
        }
}

inline bool carbon_field_skip_array(memfile *file, u8 marker)
{
        if (abstract_is_instanceof_array(marker)) {
                arr_it skip_it;
                internal_arr_it_create(&skip_it, file, MEMFILE_TELL(file));
                internal_arr_it_fast_forward(&skip_it);
                MEMFILE_SEEK(file, MEMFILE_TELL(&skip_it.file));
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, "marker does not encode an array container or sub type");
        }
}

inline bool carbon_field_skip_column(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(!FIELD_IS_COLUMN_OR_SUBTYPE(type_marker), ERR_TYPEMISMATCH, NULL);

        col_it skip_it;
        col_it_create(&skip_it, file, MEMFILE_TELL(file) - sizeof(u8));
        col_it_fast_forward(&skip_it);
        MEMFILE_SEEK(file, MEMFILE_TELL(&skip_it.file));
        return true;
}

inline bool carbon_field_skip_binary(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_BINARY, ERR_TYPEMISMATCH, NULL);
        /** read and skip mime type with variable-length integer type */
        u64 mime = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
        UNUSED(mime);

        /** read blob length */
        u64 blob_len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);

        /** skip blob */
        MEMFILE_SKIP(file, blob_len);
        return true;
}

inline bool carbon_field_skip_custom_binary(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_BINARY_CUSTOM, ERR_TYPEMISMATCH, NULL);
        /** read custom type str_buf length, and skip the type str_buf */
        u64 custom_type_str_len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
        MEMFILE_SKIP(file, custom_type_str_len);

        /** read blob length, and skip blob data */
        u64 blob_len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
        MEMFILE_SKIP(file, blob_len);
        return true;
}

inline bool carbon_field_skip_string(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_STRING, ERR_TYPEMISMATCH, NULL);
        u64 strlen = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
        MEMFILE_SKIP(file, strlen);
        return true;
}

inline bool carbon_field_skip_float(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_NUMBER_FLOAT, ERR_TYPEMISMATCH, NULL);
        MEMFILE_SKIP(file, sizeof(float));
        return true;
}

inline bool carbon_field_skip_boolean(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_TRUE && type_marker != FIELD_FALSE, ERR_TYPEMISMATCH, NULL);
        return true;
}

inline bool carbon_field_skip_null(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_NULL, ERR_TYPEMISMATCH, NULL);
        return true;
}

inline bool carbon_field_skip_8(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_NUMBER_I8 && type_marker != FIELD_NUMBER_U8,
                 ERR_TYPEMISMATCH, NULL);
        assert(sizeof(u8) == sizeof(i8));
        MEMFILE_SKIP(file, sizeof(u8));
        return true;
}

inline bool carbon_field_skip_16(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_NUMBER_I16 && type_marker != FIELD_NUMBER_U16,
                 ERR_TYPEMISMATCH, NULL);
        assert(sizeof(u16) == sizeof(i16));
        MEMFILE_SKIP(file, sizeof(u16));
        return true;
}

inline bool carbon_field_skip_32(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_NUMBER_I32 && type_marker != FIELD_NUMBER_U32,
                 ERR_TYPEMISMATCH, NULL);
        assert(sizeof(u32) == sizeof(i32));
        MEMFILE_SKIP(file, sizeof(u32));
        return true;
}

inline bool carbon_field_skip_64(memfile *file)
{
        u8 type_marker = *MEMFILE_READ_TYPE(file, u8);

        ERROR_IF_AND_RETURN(type_marker != FIELD_NUMBER_I64 && type_marker != FIELD_NUMBER_U64,
                 ERR_TYPEMISMATCH, NULL);
        assert(sizeof(u64) == sizeof(i64));
        MEMFILE_SKIP(file, sizeof(u64));
        return true;
}

inline field_e field_for_column(list_type_e derivation, col_it_type_e type)
{
        switch (derivation) {
                case LIST_UNSORTED_MULTISET:
                        switch (type) {
                                case COLUMN_U8:
                                        return FIELD_COLUMN_U8_UNSORTED_MULTISET;
                                case COLUMN_U16:
                                        return FIELD_COLUMN_U16_UNSORTED_MULTISET;
                                case COLUMN_U32:
                                        return FIELD_COLUMN_U32_UNSORTED_MULTISET;
                                case COLUMN_U64:
                                        return FIELD_COLUMN_U64_UNSORTED_MULTISET;
                                case COLUMN_I8:
                                        return FIELD_COLUMN_I8_UNSORTED_MULTISET;
                                case COLUMN_I16:
                                        return FIELD_COLUMN_I16_UNSORTED_MULTISET;
                                case COLUMN_I32:
                                        return FIELD_COLUMN_I32_UNSORTED_MULTISET;
                                case COLUMN_I64:
                                        return FIELD_COLUMN_I64_UNSORTED_MULTISET;
                                case COLUMN_FLOAT:
                                        return FIELD_COLUMN_FLOAT_UNSORTED_MULTISET;
                                case COLUMN_BOOLEAN:
                                        return FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET;
                                default: ERROR(ERR_INTERNALERR, NULL);
                                        return 0;
                        }
                case LIST_SORTED_MULTISET:
                        switch (type) {
                                case COLUMN_U8:
                                        return FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET;
                                case COLUMN_U16:
                                        return FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET;
                                case COLUMN_U32:
                                        return FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET;
                                case COLUMN_U64:
                                        return FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET;
                                case COLUMN_I8:
                                        return FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET;
                                case COLUMN_I16:
                                        return FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET;
                                case COLUMN_I32:
                                        return FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET;
                                case COLUMN_I64:
                                        return FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET;
                                case COLUMN_FLOAT:
                                        return FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET;
                                case COLUMN_BOOLEAN:
                                        return FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET;
                                default: ERROR(ERR_INTERNALERR, NULL);
                                        return 0;
                        }
                case LIST_UNSORTED_SET:
                        switch (type) {
                                case COLUMN_U8:
                                        return FIELD_DERIVED_COLUMN_U8_UNSORTED_SET;
                                case COLUMN_U16:
                                        return FIELD_DERIVED_COLUMN_U16_UNSORTED_SET;
                                case COLUMN_U32:
                                        return FIELD_DERIVED_COLUMN_U32_UNSORTED_SET;
                                case COLUMN_U64:
                                        return FIELD_DERIVED_COLUMN_U64_UNSORTED_SET;
                                case COLUMN_I8:
                                        return FIELD_DERIVED_COLUMN_I8_UNSORTED_SET;
                                case COLUMN_I16:
                                        return FIELD_DERIVED_COLUMN_I16_UNSORTED_SET;
                                case COLUMN_I32:
                                        return FIELD_DERIVED_COLUMN_I32_UNSORTED_SET;
                                case COLUMN_I64:
                                        return FIELD_DERIVED_COLUMN_I64_UNSORTED_SET;
                                case COLUMN_FLOAT:
                                        return FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET;
                                case COLUMN_BOOLEAN:
                                        return FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET;
                                default: ERROR(ERR_INTERNALERR, NULL);
                                        return 0;
                        }
                case LIST_SORTED_SET:
                        switch (type) {
                                case COLUMN_U8:
                                        return FIELD_DERIVED_COLUMN_U8_SORTED_SET;
                                case COLUMN_U16:
                                        return FIELD_DERIVED_COLUMN_U16_SORTED_SET;
                                case COLUMN_U32:
                                        return FIELD_DERIVED_COLUMN_U32_SORTED_SET;
                                case COLUMN_U64:
                                        return FIELD_DERIVED_COLUMN_U64_SORTED_SET;
                                case COLUMN_I8:
                                        return FIELD_DERIVED_COLUMN_I8_SORTED_SET;
                                case COLUMN_I16:
                                        return FIELD_DERIVED_COLUMN_I16_SORTED_SET;
                                case COLUMN_I32:
                                        return FIELD_DERIVED_COLUMN_I32_SORTED_SET;
                                case COLUMN_I64:
                                        return FIELD_DERIVED_COLUMN_I64_SORTED_SET;
                                case COLUMN_FLOAT:
                                        return FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET;
                                case COLUMN_BOOLEAN:
                                        return FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET;
                                default: ERROR(ERR_INTERNALERR, NULL);
                                        return 0;
                        }
                default: ERROR(ERR_INTERNALERR, NULL);
                        return 0;
        }
}

inline field_e
field_column_entry_to_regular_type(field_e type, bool is_null, bool is_true)
{
        if (is_null) {
                return FIELD_NULL;
        } else {
                switch (type) {
                        case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                                return FIELD_NUMBER_U8;
                        case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                                return FIELD_NUMBER_U16;
                        case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                                return FIELD_NUMBER_U32;
                        case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                                return FIELD_NUMBER_U64;
                        case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                                return FIELD_NUMBER_I8;
                        case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                                return FIELD_NUMBER_I16;
                        case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                                return FIELD_NUMBER_I32;
                        case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                                return FIELD_NUMBER_I64;
                        case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                                return FIELD_NUMBER_FLOAT;
                        case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                        case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                        case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                                return is_true ? FIELD_TRUE : FIELD_FALSE;
                        default: ERROR(ERR_INTERNALERR, NULL);
                                return 0;
                }
        }
}

inline field_class_e field_get_class(field_e type)
{
        switch (type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                        return CLASS_CONSTANT;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        return CLASS_CONTAINER;
                case FIELD_STRING:
                        return CLASS_CHARACTER_STRING;
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                        return CLASS_NUMBER;
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        return CLASS_BINARY_STRING;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return 0;
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/carbon/dot.h>
#include <karbonit/carbon/find.h>
#include <karbonit/stdinc.h>
#include <karbonit/types.h>
#include <stdint.h>
#include <karbonit/json.h>

static void result_from_array(find *find, arr_it *it);

static void result_from_object(find *find, obj_it *it);

static inline bool
result_from_column(find *find, u32 requested_idx, col_it *it);

bool find_from_string(find *out, const char *dot, rec *doc)
{
        struct dot path;
        dot_from_string(&path, dot);
        bool ret = find_from_dot(out, &path, doc);
        dot_drop(&path);
        return ret;
}

bool find_from_dot(find *out, const dot *path, rec *doc)
{
        internal_find_exec(out, path, doc);
        return find_has_result(out);
}

bool internal_find_exec(find *find, const dot *path, rec *doc)
{
        ZERO_MEMORY(find, sizeof(find));
        find->doc = doc;

        dot_eval_exec(&find->eval, path, doc);
        if (find_has_result(find)) {
                switch (find->eval.result.container) {
                        case ARRAY:
                                result_from_array(find, &find->eval.result.containers.array);
                                break;
                        case COLUMN:
                                result_from_column(find, find->eval.result.containers.column.elem_pos,
                                                   &find->eval.result.containers.column.it);
                                break;
                        case OBJECT:
                                result_from_object(find, &find->eval.result.containers.object);
                                break;
                        default:
                                return ERROR(ERR_INTERNALERR, "unknown container type");
                }
        }
        return find_has_result(find);
}

bool find_has_result(find *find)
{
        return DOT_EVAL_HAS_RESULT(&find->eval);
}

const char *find_result_to_str(str_buf *dst_str, find *find)
{
        if (!find_has_result(find)) {
                /* undefined */
                json_from_undef(dst_str);
        } else {
                if (find_result_is_array(find)) {
                        json_from_array(dst_str, find_result_array(find));
                } else if (find_result_is_object(find)) {
                        json_from_object(dst_str, find_result_object(find));
                } else if (find_result_is_column(find)) {
                        json_from_column(dst_str, find_result_column(find));
                } else if (find_result_is_binary(find)) {
                        json_from_binary(dst_str, find_result_binary(find));
                } else if (find_result_is_boolean(find)) {
                        bool val;
                        find_result_boolean(&val, find);
                        json_from_boolean(dst_str, val);
                } else if (find_result_is_unsigned(find)) {
                        u64 val;
                        find_result_unsigned(&val, find);
                        json_from_unsigned(dst_str, val);
                } else if (find_result_is_signed(find)) {
                        i64 val;
                        find_result_signed(&val, find);
                        json_from_signed(dst_str, val);
                } else if (find_result_is_float(find)) {
                        float val;
                        find_result_float(&val, find);
                        json_from_float(dst_str, val);
                } else if (find_result_is_string(find)) {
                        string_field sf;
                        sf.str = find_result_string(&sf.len, find);
                        json_from_string(dst_str, &sf);
                } else if (find_result_is_null(find)) {
                        json_from_null(dst_str);
                } else {
                        /* undefined */
                        json_from_undef(dst_str);
                }
        }
        return str_buf_cstr(dst_str);
}

bool find_result_type(field_e *type, find *find)
{
        if(!DOT_EVAL_HAS_RESULT(&find->eval)) {
            return false;
        } else {
            *type = find->type;
            return true;
        }
}

bool find_update_array_type(find *find, list_type_e derivation)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_ARRAY_OR_SUBTYPE(type)) {
                memfile mod;
                arr_it *it = find_result_array(find);
                MEMFILE_CLONE(&mod, &it->file);
                MEMFILE_SEEK_FROM_HERE(&mod, -sizeof(u8));
                derived_e derive_marker = abstract_derive_list_to(LIST_ARRAY, derivation);
                abstract_write_derived_type(&mod, derive_marker);
                return true;

        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: array type update must be invoked on array or sub type");
        }
}

bool find_array_is_multiset(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_ARRAY_OR_SUBTYPE(type)) {
                arr_it *it = find_result_array(find);
                return arr_it_is_multiset(it);
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: array type query must be invoked on array or sub type");
        }
}

bool find_array_is_sorted(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_ARRAY_OR_SUBTYPE(type)) {
                arr_it *it = find_result_array(find);
                return arr_it_is_sorted(it);
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: array type query must be invoked on array or sub type");
        }
}

bool find_update_column_type(find *find, list_type_e derivation)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_COLUMN_OR_SUBTYPE(type)) {
                col_it *it = find_result_column(find);
                MEMFILE_SAVE_POSITION(&it->file);
                MEMFILE_SEEK(&it->file, it->begin);

                list_container_e list_container;
                list_by_column_type(&list_container, it->field_type);
                derived_e derive_marker = abstract_derive_list_to(list_container, derivation);
                abstract_write_derived_type(&it->file, derive_marker);

                MEMFILE_RESTORE_POSITION(&it->file);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: column type update must be invoked on column or sub type");
        }
}

bool find_column_is_multiset(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_COLUMN_OR_SUBTYPE(type)) {
                col_it *it = find_result_column(find);
                return col_it_is_multiset(it);
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: column query must be invoked on column or sub type");
        }
}

bool find_column_is_sorted(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_COLUMN_OR_SUBTYPE(type)) {
                col_it *it = find_result_column(find);
                return col_it_is_sorted(it);
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: column query must be invoked on column or sub type");
        }
}

bool find_update_object_type(find *find, map_type_e derivation)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_OBJECT_OR_SUBTYPE(type)) {
                obj_it *it = find_result_object(find);
                MEMFILE_SAVE_POSITION(&it->file);
                MEMFILE_SEEK(&it->file, it->begin);

                derived_e derive_marker = abstract_derive_map_to(derivation);
                abstract_write_derived_type(&it->file, derive_marker);

                MEMFILE_RESTORE_POSITION(&it->file);
                return true;

        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: object type update must be invoked on object or sub type");
        }
}

bool find_object_is_multimap(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_OBJECT_OR_SUBTYPE(type)) {
                obj_it *it = find_result_object(find);
                return obj_it_is_multimap(it);
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: object query must be invoked on object or sub type");
        }
}

bool find_object_is_sorted(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_OBJECT_OR_SUBTYPE(type)) {
                obj_it *it = find_result_object(find);
                return obj_it_is_sorted(it);
        } else {
                return ERROR(ERR_TYPEMISMATCH, "find: object query must be invoked on object or sub type");
        }
}

bool find_multimap(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_OBJECT_OR_SUBTYPE(type)) {
                return find_object_is_multimap(find);
        } else {
                return false;
        }
}

bool find_multiset(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_ARRAY_OR_SUBTYPE(type)) {
                return find_array_is_multiset(find);
        } else if (FIELD_IS_COLUMN_OR_SUBTYPE(type)) {
                return find_column_is_multiset(find);
        } else {
                return false;
        }
}

bool find_sorted(find *find)
{
        field_e type;
        find_result_type(&type, find);
        if (FIELD_IS_ARRAY_OR_SUBTYPE(type)) {
                return find_array_is_sorted(find);
        } else if (FIELD_IS_COLUMN_OR_SUBTYPE(type)) {
                return find_column_is_sorted(find);
        } else {
                return find_object_is_sorted(find);
        }
}

bool find_result_is_array(find *find)
{
        return FIELD_IS_ARRAY_OR_SUBTYPE(find->type);
}

bool find_result_is_object(find *find)
{
        return FIELD_IS_OBJECT_OR_SUBTYPE(find->type);
}

bool find_result_is_column(find *find)
{
        return FIELD_IS_COLUMN_OR_SUBTYPE(find->type);
}

bool find_result_is_boolean(find *find)
{
        return FIELD_IS_BOOLEAN(find->type);
}

bool find_result_is_undefined(find *find)
{
        return !find_has_result(find);
}

bool find_result_is_unsigned(find *find)
{
        return FIELD_IS_UNSIGNED(find->type);
}

bool find_result_is_number(find *find)
{
        return find_result_is_integer(find) || find_result_is_float(find);
}

bool find_result_is_integer(find *find)
{
        return find_result_is_signed(find) || find_result_is_unsigned(find);
}

bool find_result_is_signed(find *find)
{
        return FIELD_IS_SIGNED(find->type);
}

bool find_result_is_float(find *find)
{
        return FIELD_IS_FLOATING(find->type);
}

bool find_result_is_null(find *find)
{
        return FIELD_IS_BASE_NULL(find->type);
}

bool find_result_is_string(find *find)
{
        return FIELD_IS_STRING(find->type);
}

bool find_result_is_binary(find *find)
{
        return FIELD_IS_BINARY(find->type);
}

bool find_result_is_contained_in_column(find *find)
{
        return find->column.is_parent;
}

bool __check_path_evaluator_has_result(find *find)
{
        assert(find);
        if (UNLIKELY(!(DOT_EVAL_HAS_RESULT(&find->eval)))) {
                return ERROR(ERR_ILLEGALSTATE, "no path evaluation result available");
        } else {
                return true;
        }
}

arr_it *find_result_array(find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return NULL;
        }

        if (UNLIKELY(!FIELD_IS_ARRAY_OR_SUBTYPE(find->type))) {
                ERROR(ERR_TYPEMISMATCH, "container must be array or sub type");
                return NULL;
        }

        return &find->value.array;
}

obj_it *find_result_object(find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return NULL;
        }

        if (UNLIKELY(!FIELD_IS_OBJECT_OR_SUBTYPE(find->type))) {
                ERROR(ERR_TYPEMISMATCH, "container must be object or sub type");
                return NULL;
        }

        return &find->value.object;
}

col_it *find_result_column(find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return NULL;
        }

        if (UNLIKELY(!FIELD_IS_COLUMN_OR_SUBTYPE(find->type))) {
                ERROR(ERR_TYPEMISMATCH, "container must be column or sub type");
                return NULL;
        }

        return &find->value.column;
}

bool find_result_boolean(bool *result, find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return false;
        }

        if (UNLIKELY(!FIELD_IS_BOOLEAN(find->type))) {
                return ERROR(ERR_TYPEMISMATCH, "result value must be of boolean type");
        }

        *result = find->value.boolean;
        return true;
}

bool find_result_unsigned(u64 *out, find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return false;
        }

        if (UNLIKELY(!FIELD_IS_UNSIGNED(find->type))) {
                return ERROR(ERR_TYPEMISMATCH, "result value must be of unsigned type");
        }

        *out = find->value.unsigned_number;
        return true;
}

bool find_result_signed(i64 *out, find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return false;
        }

        if (UNLIKELY(!FIELD_IS_SIGNED(find->type))) {
                return ERROR(ERR_TYPEMISMATCH, "result value must be of signed type");
        }

        *out = find->value.signed_number;
        return true;
}

bool find_result_float(float *out, find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return false;
        }

        if (UNLIKELY(!FIELD_IS_FLOATING(find->type))) {
                return ERROR(ERR_TYPEMISMATCH, "result value must be of float type");
        }

        *out = find->value.float_number;
        return true;
}

const char *find_result_string(u64 *str_len, find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return NULL;
        }

        if (UNLIKELY(!FIELD_IS_STRING(find->type))) {
                ERROR(ERR_TYPEMISMATCH, "result value must be of string type");
                return NULL;
        }
        *str_len = find->value.string.len;
        return find->value.string.str;
}

binary_field *find_result_binary(find *find)
{
        if (!__check_path_evaluator_has_result(find)) {
            return NULL;
        }

        if (UNLIKELY(!FIELD_IS_BINARY(find->type))) {
                ERROR(ERR_TYPEMISMATCH, "result value must be of binary type");
                return NULL;
        }

        return &find->value.binary;
}

static void result_from_array(find *find, arr_it *it)
{
        find->type = it->field.type;
        find->offset = it->field_offset;
        find->column.is_parent = false;
        switch (find->type) {
                case FIELD_NULL:
                        /** no value to be stored */
                        break;
                case FIELD_TRUE:
                case FIELD_FALSE:
                        find->value.boolean = find->type == FIELD_TRUE ? true : false;
                        break;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                        ITEM_GET_ARRAY(&find->value.array, &(it->item));
                        find->value.array.file.mode = find->doc->file.mode;
                        break;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        ITEM_GET_COLUMN(&find->value.column, &(it->item));
                        find->value.column.file.mode = find->doc->file.mode;
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                        ITEM_GET_OBJECT(&find->value.object, &(it->item));
                        find->value.object.file.mode = find->doc->file.mode;
                        break;
                case FIELD_STRING:
                        find->value.string = ITEM_GET_STRING(&(it->item), NULL_STRING);
                        break;
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                        find->value.unsigned_number = ITEM_GET_UNSIGNED(&(it->item), NULL_UNSIGNED);
                        break;
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                        find->value.signed_number = ITEM_GET_SIGNED(&(it->item), NULL_SIGNED);
                        break;
                case FIELD_NUMBER_FLOAT:
                        find->value.float_number = ITEM_GET_FLOAT(&(it->item), CARBON_NULL_FLOAT);
                        break;
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        find->value.binary = ITEM_GET_BINARY(&(it->item), NULL_BINARY);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        break;
        }
}

static void result_from_object(find *find, obj_it *it)
{
        internal_obj_it_prop_type(&find->type, it);
        find->offset = it->last_off;
        find->column.is_parent = false;
        switch (find->type) {
                case FIELD_NULL:
                        /** no value to be stored */
                        break;
                case FIELD_TRUE:
                case FIELD_FALSE:
                        find->value.boolean = find->type == FIELD_TRUE ? true : false;
                        break;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                        ITEM_GET_ARRAY(&find->value.array, &(it->prop.value));
                        find->value.array.file.mode = find->doc->file.mode;
                        break;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        ITEM_GET_COLUMN(&find->value.column, &(it->prop.value));
                        find->value.column.file.mode = find->doc->file.mode;
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                        ITEM_GET_OBJECT(&find->value.object, &(it->prop.value));
                        find->value.object.file.mode = find->doc->file.mode;
                        break;
                case FIELD_STRING:
                        find->value.string = ITEM_GET_STRING(&(it->prop.value), NULL_STRING);
                        break;
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                        find->value.unsigned_number = ITEM_GET_UNSIGNED(&(it->prop.value), NULL_UNSIGNED);
                        break;
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                        find->value.signed_number = ITEM_GET_SIGNED(&(it->prop.value), NULL_SIGNED);
                        break;
                case FIELD_NUMBER_FLOAT:
                        find->value.float_number = ITEM_GET_FLOAT(&(it->prop.value), CARBON_NULL_FLOAT);
                        break;
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        find->value.binary = ITEM_GET_BINARY(&(it->prop.value), NULL_BINARY);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        break;
        }
}

static inline bool
result_from_column(find *find, u32 requested_idx, col_it *it)
{
#ifndef NDEBUG
        u32 max_idx = COL_IT_VALUES_INFO(&find->type, it);
        assert(requested_idx < max_idx);
#endif
        find->offset = it->begin;
        find->column.is_parent = true;

        switch (find->type) {
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                        u8 field_value = COL_IT_BOOLEAN_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_BOOLEAN(field_value)) {
                                find->type = FIELD_NULL;
                        } else if (field_value == CARBON_BOOLEAN_COLUMN_TRUE) {
                                find->type = FIELD_TRUE;
                        } else if (field_value == CARBON_BOOLEAN_COLUMN_FALSE) {
                                find->type = FIELD_FALSE;
                        } else {
                                ERROR(ERR_INTERNALERR, NULL);
                        }
                }
                        break;
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET: {
                        u8 field_value = COL_IT_U8_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_U8(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_U8;
                                find->value.unsigned_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET: {
                        u16 field_value = COL_IT_U16_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_U16(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_U16;
                                find->value.unsigned_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET: {
                        u32 field_value = COL_IT_U32_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_U32(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_U32;
                                find->value.unsigned_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET: {
                        u64 field_value = COL_IT_U64_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_U64(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_U64;
                                find->value.unsigned_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET: {
                        i8 field_value = COL_IT_I8_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_I8(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_I8;
                                find->value.signed_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET: {
                        i16 field_value = COL_IT_I16_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_I16(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_I16;
                                find->value.signed_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET: {
                        i32 field_value = COL_IT_I32_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_I32(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_I32;
                                find->value.signed_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                        i64 field_value = COL_IT_I64_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_I64(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_I64;
                                find->value.signed_number = field_value;
                        }
                }
                        break;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET: {
                        float field_value = COL_IT_FLOAT_VALUES(NULL, it)[requested_idx];
                        if (IS_NULL_FLOAT(field_value)) {
                                find->type = FIELD_NULL;
                        } else {
                                find->type = FIELD_NUMBER_FLOAT;
                                find->value.float_number = field_value;
                        }
                }
                        break;
                default:
                        return ERROR(ERR_UNSUPPORTEDTYPE, NULL);
        }
        return true;
}/*
 * func - high-level callable functions on records to query, update and remove elements and containers
 *
 * Copyright 2020 Marcus Pinnecke
 */

#include <karbonit/carbon/func.h>
#include <karbonit/carbon/find.h>
#include <karbonit/carbon/rewrite.h>
#include <karbonit/carbon/revise.h>
#include <karbonit/json.h>

// ---------------------------------------------------------------------------------------------------------------------

/*!
 * \brief Tests whether the specific dot-notated path <code>path</code> resolves to an existing element in the document
 * <code>doc</code>.
 *
 * The function returns <code>TRUE</code> if (and only if) an non-undefined non-null element exists that is pointed to by
 * <code>path</code>. If the element does not exist, or in case the value of that element is <code>undef</code> or
 * <code>null</code>, <code>FALSE</code> is returned.
 *
 * \param doc non-null pointer to the Carbon record for which <code>path</code> should be evaluated
 * \param path non-null pointer to a dot-notated path that should be evaluated for <code>doc</code>
 * \returns <code>TRUE</code> if <code>path</code> points to an existing element. In all other cases (including errors),
 *          <code>FALSE</code> is returned.
 */
inline bool func_rec_exists(const rec *doc, const dot *path)
{
        find eval;
        return (path && dot_is_empty(path)) || (doc && path && find_from_dot(&eval, path, (rec *) doc) &&
               !find_result_is_null(&eval) && !find_result_is_undefined(&eval));
}

// ---------------------------------------------------------------------------------------------------------------------

/*!
 * \brief Gets the value of the element which is pointed to by a given dot-notated path.
 *
 * The function invokes internally a dot-path evaluation and prints the result into the string buffer <code>buf</code>,
 * which c-string is the return value of this function.
 *
 * \attention The buffer <code>buf</code> is cleaned up before used. In case the buffer is non-empty before the call,
 *      its content is deleted.
 *
 * \note In case the path evaluation fails (e.g., the path points to an not existing element), <code>undef</code> (rather
 * than <code>null</code>) is returned.
 *
 * \note In case <code>path</code> is empty, the entire record, formatted as json, is returned.
 *
 * \param doc non-null pointer to the Carbon record for which <code>path</code> should be evaluated
 * \param path non-null pointer to a dot-notated path that should be evaluated for <code>doc</code>
 * \param buf non-null pointer to an already created string buffer
 * \return the string buffers c-string which is the json formatted result of the path evaluation. In case of an error,
 *         <code>undef</code> is returned.
 */
inline const char *func_rec_get(const rec *doc, const dot *path, str_buf *buf)
{
        find eval;
        str_buf_clear(buf);
        if (!doc || !path || !buf) {
                return json_from_undef(buf);
        } else {
                if (dot_is_empty(path)) {
                        return json_from_record(buf, (rec *) doc);
                } else {
                        find_from_dot(&eval, path, (rec *) doc);
                        return find_result_to_str(buf, &eval);
                }
        }
}

// ---------------------------------------------------------------------------------------------------------------------

/*!
 * \brief Sets the value of the element in <code>doc</code> pointed by a dot-notated path <code>path</code> to <code>json</code>.
 *
 * This function performs an update or create operation in the record <code>doc</code> potentially modifying
 * <code>doc</code>, or writing directly to <code>rev</code>.
 *
 * An <b>update</b> is executed if <code>path</code> evaluates to an existing element in <code>doc</code>. In case
 * the path does not point to an existing element, the elements for this path is <b>created</b> as needed to and its
 * value is set accordingly.
 *
 * The parameter <b>patch</b> controls whether the input record <code>doc</code> is modified or whether a new
 * revision of <code>doc</code> is created leading <code>doc</code> untouched. If <b>patch</b> is turned on,
 * <code>doc</code> is modified and the input parameter <code>rev</code> is unused (and may be <code>NULL</code>).
 * Otherwise, if <b>patch</b> is turned off, a revision of <code>doc</code> is executed and stored in the non-null
 * input parameter <code>rev</code>. In other words, this update resp. create function affects the object
 * <code>doc</code> only if <code>patch</code> is set to <code>FALSE</code>.
 *
 * \note If <b>patch</b> is turned off, this function is thread-safe. In this case, <code>doc</code> is not
 * touched, and <code>rev</code> is a new revision (including a new revision number) of <code>doc</code>. Is
 * <b>patch</b> is turned on, <code>doc</code> is modified on-the-fly without changes to the revision number.
 * In this case, the function is not thread-safe.
 *
 * \param rev A pointer to an uninitialized Carbon record that will contain the revision of <code>doc</code>
 *            having the change applied. The pointer must be non-null if <code>patch</code> is set to <code>FALSE</code>,
 *            and can be null if <code>patch</code> is set to <code>TRUE</code>.
 * \param doc A non-null pointer to an already created Carbon record which is either target of modification (if
 *            <code>patch</code> is turned on), or template for the revision <code>rev</code> (if <code>patch</code>
 *            is turned off).
 * \param path A non-null dot-notated path that points to an (potentially not existing) element in <code>doc</code>
 * \param json A valid json text that defines the new-to-set value for the element pointed by <code>path</code>
 * \param patch A flag controlling whether a patch (<code>patch</code> is turned on), or a revision (<code>patch</code>
 *              is turned off) is executed on <code>doc</code>.
 * \return The pointer to the record which has been modified, or <code>NULL</code> in case of an error. This pointer
 *         points to <code>doc</code> if <code>patch</code> is set to <code>TRUE</code>, and to <code>rev</code>
 *         if <code>patch</code> is set to <code>FALSE</code>.
 */
rec *func_rec_set(rec *rev, rec *doc, const dot *path, const rec *import, bool patch)
{
        find eval;

        if (!path || !import || !doc) {
                ERROR(ERR_ILLEGALARG, "illegal arguments");
                return NULL;
        } else if (!patch && !rev) {
                ERROR(ERR_ILLEGALARG, "illegal parameter configuration");
                return NULL;
        } else {
                if (!patch) {
                        rec_clone(rev, doc);
                        revise_commit_update(rev);
                }
                bool elem_exists = find_from_dot(&eval, path, doc);
                if (elem_exists) {
                        memfile src_file;
                        rec *subj = patch ? doc : rev;
                        internal_rec_get_first(&src_file, (rec *) import);
                        MEMFILE_SEEK__UNSAFE(&subj->file, eval.offset);
                        if (find_result_is_contained_in_column(&eval)) {
                                // TODO: implement column rewrite
                                ERROR(ERR_NOTIMPLEMENTED, "column rewrite not implemented");
                                return NULL;
                        } else {
                                rewrite_field(&subj->file, &src_file);
                        }
                        return subj;
                } else {
                        // TODO: implement path creation
                        ERROR(ERR_NOTIMPLEMENTED, "path creation not implemented");
                        return NULL;
                }
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/uintvar/stream.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/mime.h>
#include <karbonit/carbon/container.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/string-field.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/utils/numbers.h>

#define check_type_if_container_is_column(in, expr)                                                              \
if (UNLIKELY(in->context_type == COLUMN && !(expr))) {                                            \
        ERROR(ERR_TYPEMISMATCH, "Element type does not match container type");        \
}

#define check_type_range_if_container_is_column(in, expected1, expected2, expected3)                             \
if (UNLIKELY(in->context_type == COLUMN && in->context.column->type != expected1 &&                 \
        in->context.column->type != expected2 && in->context.column->type != expected3)) {                 \
        ERROR_WDETAILS(&in->err, ERR_TYPEMISMATCH, "Element type does not match container type");        \
}

static bool
write_field_data(insert *in, u8 field_marker, const void *base, u64 nbytes);

static bool push_in_column(insert *in, const void *base, field_e type);

static bool push_media_type_for_array(insert *in, field_e type);

static void internal_create(insert *in, memfile *src, offset_t pos);

static void write_binary_blob(insert *in, const void *value, size_t nbytes);

void internal_insert_create_for_array(insert *in, arr_it *context)
{
        in->context_type = ARRAY;
        in->context.array = context;
        in->position = 0;

        offset_t pos = 0;
        if (context->eof) {
                pos = MEMFILE_TELL(&context->file);
        } else {
                pos = context->last_off ? context->last_off : 0;
        }

        internal_create(in, &context->file, pos);
}

bool internal_insert_create_for_column(insert *in, col_it *context)
{
        in->context_type = COLUMN;
        in->context.column = context;
        internal_create(in, &context->file, MEMFILE_TELL(&context->file));
        return true;
}

bool internal_insert_create_for_object(insert *in, obj_it *context)
{
        in->context_type = OBJECT;
        in->context.object = context;

        offset_t pos;
        if (context->eof) {
                pos = MEMFILE_TELL(&context->file);
        } else {
                pos = context->last_off;
        }

        internal_create(in, &context->file, pos);
        return true;
}

bool insert_null(insert *in)
{
        if (UNLIKELY(in->context_type == COLUMN &&
                !FIELD_IS_COLUMN_OR_SUBTYPE(in->context.column->field_type))) {
                ERROR(ERR_TYPEMISMATCH, "Element type does not match container type");
        }

        switch (in->context_type) {
                case ARRAY:
                        return push_media_type_for_array(in, FIELD_NULL);
                case COLUMN: {
                        switch (in->context.column->field_type) {
                                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U8_SORTED_SET: {
                                        u8 value = U8_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U16_SORTED_SET: {
                                        u16 value = U16_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U32_SORTED_SET: {
                                        u32 value = U32_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_U64_SORTED_SET: {
                                        u64 value = U64_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I8_SORTED_SET: {
                                        i8 value = I8_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I16_SORTED_SET: {
                                        i16 value = I16_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I32_SORTED_SET: {
                                        i32 value = I32_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                                        i64 value = I64_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET: {
                                        float value = CARBON_NULL_FLOAT;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                                        u8 value = CARBON_BOOLEAN_COLUMN_NULL;
                                        return push_in_column(in, &value, in->context.column->field_type);
                                }
                                default:
                                        return ERROR(ERR_INTERNALERR, NULL);
                        }
                }
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_true(insert *in)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_BOOL_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        return push_media_type_for_array(in, FIELD_TRUE);
                case COLUMN: {
                        u8 value = CARBON_BOOLEAN_COLUMN_TRUE;
                        return push_in_column(in, &value, FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET);
                }
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_false(insert *in)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_BOOL_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        return push_media_type_for_array(in, FIELD_FALSE);
                case COLUMN: {
                        u8 value = CARBON_BOOLEAN_COLUMN_FALSE;
                        return push_in_column(in, &value, FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET);
                }
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_u8(insert *in, u8 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_U8_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_U8, &value, sizeof(u8));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_U8_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_u16(insert *in, u16 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_U16_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_U16, &value, sizeof(u16));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_U16_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_u32(insert *in, u32 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_U32_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_U32, &value, sizeof(u32));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_U32_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_u64(insert *in, u64 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_U64_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_U64, &value, sizeof(u64));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_U64_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_i8(insert *in, i8 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_I8_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_I8, &value, sizeof(i8));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_I8_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_i16(insert *in, i16 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_I16_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_I16, &value, sizeof(i16));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_I16_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_i32(insert *in, i32 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_I32_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_I32, &value, sizeof(i32));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_I32_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_i64(insert *in, i64 value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_I64_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_I64, &value, sizeof(i64));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_I64_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_unsigned(insert *in, u64 value)
{
        ERROR_IF_AND_RETURN(in->context_type == COLUMN, ERR_INSERT_TOO_DANGEROUS, NULL)

        switch (num_min_type_signed(value)) {
                case NUM_I8:
                        return insert_u8(in, (u8) value);
                case NUM_I16:
                        return insert_u16(in, (u16) value);
                case NUM_I32:
                        return insert_u32(in, (u32) value);
                case NUM_I64:
                        return insert_u64(in, (u64) value);
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_signed(insert *in, i64 value)
{
        ERROR_IF_AND_RETURN(in->context_type == COLUMN, ERR_INSERT_TOO_DANGEROUS, NULL)

        switch (num_min_type_signed(value)) {
                case NUM_I8:
                        return insert_i8(in, (i8) value);
                case NUM_I16:
                        return insert_i16(in, (i16) value);
                case NUM_I32:
                        return insert_i32(in, (i32) value);
                case NUM_I64:
                        return insert_i64(in, (i64) value);
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_float(insert *in, float value)
{
        check_type_if_container_is_column(in, FIELD_IS_COLUMN_FLOAT_OR_SUBTYPE(in->context.column->field_type));
        switch (in->context_type) {
                case ARRAY:
                        write_field_data(in, FIELD_NUMBER_FLOAT, &value, sizeof(float));
                        break;
                case COLUMN:
                        push_in_column(in, &value, FIELD_COLUMN_FLOAT_UNSORTED_MULTISET);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
        return true;
}

bool insert_string(insert *in, const char *value)
{
        return insert_nchar(in, value, strlen(value));
}

bool insert_nchar(insert *in, const char *value, u64 value_len)
{
        UNUSED(in);
        UNUSED(value);
        ERROR_IF_AND_RETURN(in->context_type != ARRAY, ERR_UNSUPPCONTAINER, NULL);

        return string_field_nchar_write(&in->file, value, value_len);
}

static void _insert_binary(insert *in, const void *value, size_t nbytes,
                          const char *file_ext, const char *user_type)
{
        if (user_type && strlen(user_type) > 0) {
                /** write media type 'user binary' */
                push_media_type_for_array(in, FIELD_BINARY_CUSTOM);

                /** write length of 'user_type' str_buf with variable-length integer type */
                u64 user_type_strlen = strlen(user_type);

                MEMFILE_WRITE_UINTVAR_STREAM(NULL, &in->file, user_type_strlen);

                /** write 'user_type' str_buf */
                MEMFILE_ENSURE_SPACE(&in->file, user_type_strlen);
                MEMFILE_WRITE(&in->file, user_type, user_type_strlen);

                /** write binary blob */
                write_binary_blob(in, value, nbytes);

        } else {
                /** write media type 'binary' */
                push_media_type_for_array(in, FIELD_BINARY);

                /** write mime type with variable-length integer type */
                u64 mime_id = mime_by_ext(file_ext);

                /** write mime type id */
                MEMFILE_WRITE_UINTVAR_STREAM(NULL, &in->file, mime_id);

                /** write binary blob */
                write_binary_blob(in, value, nbytes);
        }
}

bool insert_binary(insert *in, const void *value, size_t nbytes,
                          const char *file_ext, const char *user_type)
{
        ERROR_IF_AND_RETURN(in->context_type != ARRAY, ERR_UNSUPPCONTAINER, NULL);
        _insert_binary(in, value, nbytes, file_ext, user_type);
        return true;
}

insert *__insert_map_begin(obj_state *out,
                                                  insert *in, map_type_e derivation,
                                                  u64 object_capacity)
{
        ERROR_IF_AND_RETURN(!out, ERR_NULLPTR, NULL);
        if (!in) {
                ERROR(ERR_NULLPTR, NULL);
                return false;
        }

        *out = (obj_state) {
                .parent = in,
                .it = MALLOC(sizeof(obj_it)),
                .begin = MEMFILE_TELL(&in->file),
                .end = 0
        };


        internal_insert_object(&in->file, derivation, object_capacity);
        u64 payload_start = MEMFILE_TELL(&in->file) - 1;

        internal_obj_it_create(out->it, &in->file, payload_start);
        internal_obj_it_insert_begin(&out->in, out->it);

        return &out->in;
}

insert *insert_object_begin(obj_state *out,
                                                  insert *in,
                                                  u64 object_capacity)
{
        return __insert_map_begin(out, in, MAP_UNSORTED_MULTIMAP, object_capacity);
}

bool insert_object_end(obj_state *state)
{
        obj_it scan;
        internal_obj_it_create(&scan, &state->parent->file, MEMFILE_TELL(&state->parent->file) - 1);
        while (obj_it_next(&scan)) {}

        assert(*MEMFILE_PEEK(&scan.file, sizeof(char)) == MOBJECT_END);
        MEMFILE_READ(&scan.file, sizeof(char));

        state->end = MEMFILE_TELL(&scan.file);

        MEMFILE_SKIP(&scan.file, 1);

        MEMFILE_SEEK(&state->parent->file, MEMFILE_TELL(&scan.file) - 1);
        free(state->it);
        return true;
}

insert *insert_object_map_begin(obj_state *out, insert *in,
                                              map_type_e derivation, u64 object_capacity)
{
        return __insert_map_begin(out, in, derivation, object_capacity);
}

bool insert_object_map_end(obj_state *state)
{
        return insert_object_end(state);
}

insert *__insert_array_list_begin(arr_state *state_out,
                                                 insert *inserter_in, list_type_e derivation, u64 array_capacity)
{
        ERROR_IF_AND_RETURN(!state_out, ERR_NULLPTR, NULL);
        if (!inserter_in) {
                ERROR(ERR_NULLPTR, NULL);
                return false;
        }

        ERROR_IF_AND_RETURN(inserter_in->context_type != ARRAY && inserter_in->context_type != OBJECT,
                     ERR_UNSUPPCONTAINER, NULL);

        *state_out = (arr_state) {
                .parent = inserter_in,
                .array = MALLOC(sizeof(arr_it)),
                .begin = MEMFILE_TELL(&inserter_in->file),
                .end = 0
        };

        internal_insert_array(&inserter_in->file, derivation, array_capacity);
        u64 payload_start = MEMFILE_TELL(&inserter_in->file) - 1;

        internal_arr_it_create(state_out->array, &inserter_in->file, payload_start);
        arr_it_insert_begin(&state_out->nested, state_out->array);

        return &state_out->nested;
}

insert *insert_array_begin(arr_state *state_out,
                                                    insert *inserter_in, u64 array_capacity)
{
        return __insert_array_list_begin(state_out, inserter_in, LIST_UNSORTED_MULTISET, array_capacity);
}

bool insert_array_end(arr_state *state_in)
{
        arr_it scan;
        internal_arr_it_create(&scan, &state_in->parent->file,
                               MEMFILE_TELL(&state_in->parent->file) - 1);

        internal_arr_it_fast_forward(&scan);

        state_in->end = MEMFILE_TELL(&scan.file);
        MEMFILE_SKIP(&scan.file, 1);

        MEMFILE_SEEK(&state_in->parent->file, MEMFILE_TELL(&scan.file) - 1);
        free(state_in->array);
        return true;
}

insert *insert_array_list_begin(arr_state *state_out, insert *inserter_in, list_type_e derivation, u64 array_capacity)
{
        return __insert_array_list_begin(state_out, inserter_in, derivation, array_capacity);
}

bool insert_array_list_end(arr_state *state_in)
{
        return insert_array_end(state_in);
}


insert *__insert_column_list_begin(col_state *state_out,
                                                     insert *inserter_in,
                                                     list_type_e derivation,
                                                     col_it_type_e type,
                                                     u64 cap)
{
        ERROR_IF_AND_RETURN(!state_out, ERR_NULLPTR, NULL);
        ERROR_IF_AND_RETURN(!inserter_in, ERR_NULLPTR, NULL);
        ERROR_IF_AND_RETURN(inserter_in->context_type != ARRAY && inserter_in->context_type != OBJECT,
                     ERR_UNSUPPCONTAINER, NULL);

        field_e field_type = field_for_column(derivation, type);

        *state_out = (col_state) {
                .parent = inserter_in,
                .nested_column = MALLOC(sizeof(col_it)),
                .type = field_type,
                .begin = MEMFILE_TELL(&inserter_in->file),
                .end = 0
        };

        u64 container_start_off = MEMFILE_TELL(&inserter_in->file);
        internal_insert_column(&inserter_in->file, derivation, type, cap);

        col_it_create(state_out->nested_column, &inserter_in->file,
                                    container_start_off);
        col_it_insert(&state_out->nested, state_out->nested_column);

        return &state_out->nested;
}

insert *insert_column_begin(col_state *state_out,
                                                     insert *inserter_in,
                                                     col_it_type_e type,
                                                     u64 cap)
{
        return __insert_column_list_begin(state_out, inserter_in, LIST_UNSORTED_MULTISET, type, cap);
}

bool insert_column_end(col_state *state_in)
{
        col_it scan;
        col_it_create(&scan, &state_in->parent->file,
                                state_in->nested_column->begin);
        col_it_fast_forward(&scan);

        state_in->end = MEMFILE_TELL(&scan.file);
        MEMFILE_SEEK(&state_in->parent->file, MEMFILE_TELL(&scan.file));

        free(state_in->nested_column);
        return true;
}

insert *insert_column_list_begin(col_state *state_out, insert *inserter_in, list_type_e derivation, col_it_type_e type, u64 cap)
{
        return __insert_column_list_begin(state_out, inserter_in, derivation, type, cap);
}

bool insert_column_list_end(col_state *state_in)
{
        return insert_column_end(state_in);
}

static bool inserter_refresh_mod_size(insert *in, i64 mod_size)
{
        assert(mod_size > 0);

        i64 *target = NULL;
        switch (in->context_type) {
                case OBJECT:
                        target = &in->context.object->mod_size;
                        break;
                case ARRAY:
                        target = &in->context.array->mod_size;
                        break;
                case COLUMN:
                        target = &in->context.column->mod_size;
                        break;
                default: ERROR(ERR_UNSUPPCONTAINER, NULL);
                        return false;
        }
        *target += mod_size;
        return true;
}

bool insert_prop_null(insert *in, const char *key)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        push_media_type_for_array(in, FIELD_NULL);
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_true(insert *in, const char *key)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        push_media_type_for_array(in, FIELD_TRUE);
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_false(insert *in, const char *key)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        push_media_type_for_array(in, FIELD_FALSE);
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_u8(insert *in, const char *key, u8 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_U8, &value, sizeof(u8));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_u16(insert *in, const char *key, u16 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_U16, &value, sizeof(u16));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_u32(insert *in, const char *key, u32 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_U32, &value, sizeof(u32));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_u64(insert *in, const char *key, u64 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_U64, &value, sizeof(u64));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_i8(insert *in, const char *key, i8 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_I8, &value, sizeof(i8));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_i16(insert *in, const char *key, i16 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_I16, &value, sizeof(i16));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_i32(insert *in, const char *key, i32 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_I32, &value, sizeof(i32));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_i64(insert *in, const char *key, i64 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_I64, &value, sizeof(i64));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_unsigned(insert *in, const char *key, u64 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL)

        switch (num_min_type_unsigned(value)) {
                case NUM_U8:
                        return insert_prop_u8(in, key, (u8) value);
                case NUM_U16:
                        return insert_prop_u16(in, key, (u16) value);
                case NUM_U32:
                        return insert_prop_u32(in, key, (u32) value);
                case NUM_U64:
                        return insert_prop_u64(in, key, (u64) value);
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_prop_signed(insert *in, const char *key, i64 value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL)

        switch (num_min_type_signed(value)) {
                case NUM_I8:
                        return insert_prop_i8(in, key, (i8) value);
                case NUM_I16:
                        return insert_prop_i16(in, key, (i16) value);
                case NUM_I32:
                        return insert_prop_i32(in, key, (i32) value);
                case NUM_I64:
                        return insert_prop_i64(in, key, (i64) value);
                default: ERROR(ERR_INTERNALERR, NULL);
                        return false;
        }
}

bool insert_prop_float(insert *in, const char *key, float value)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        write_field_data(in, FIELD_NUMBER_FLOAT, &value, sizeof(float));
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_string(insert *in, const char *key, const char *value)
{
        return insert_prop_nchar(in, key, value, strlen(value));
}

bool insert_prop_nchar(insert *in, const char *key, const char *value, u64 value_len)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        string_field_nchar_write(&in->file, value, value_len);
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

bool insert_prop_binary(insert *in, const char *key, const void *value,
                               size_t nbytes, const char *file_ext, const char *user_type)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        offset_t prop_start = MEMFILE_TELL(&in->file);
        string_field_nomarker_write(&in->file, key);
        _insert_binary(in, value, nbytes, file_ext, user_type);
        offset_t prop_end = MEMFILE_TELL(&in->file);
        inserter_refresh_mod_size(in, prop_end - prop_start);
        return true;
}

static insert *__insert_prop_object_container_begin(obj_state *out,
                                                       insert *in, map_type_e derivation, const char *key,
                                                       u64 object_capacity)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        string_field_nomarker_write(&in->file, key);
        return insert_object_map_begin(out, in, derivation, object_capacity);
}

insert *insert_prop_object_begin(obj_state *out,
                                                          insert *in, const char *key,
                                                          u64 object_capacity)
{
        return __insert_prop_object_container_begin(out, in, MAP_UNSORTED_MULTIMAP,
                                                           key, object_capacity);
}

u64 insert_prop_object_end(obj_state *state)
{
        insert_object_end(state);
        return state->end - state->begin;
}

insert *insert_prop_map_begin(obj_state *out, insert *in, map_type_e derivation, const char *key, u64 object_capacity)
{
        return __insert_prop_object_container_begin(out, in, derivation,
                                                           key, object_capacity);
}

u64 insert_prop_map_end(obj_state *state)
{
        return insert_prop_object_end(state);
}

insert *insert_prop_array_begin(arr_state *state,
                                                         insert *in, const char *key,
                                                         u64 array_capacity)
{
        ERROR_IF_AND_RETURN(in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        string_field_nomarker_write(&in->file, key);
        return insert_array_begin(state, in, array_capacity);
}

u64 insert_prop_array_end(arr_state *state)
{
        insert_array_end(state);
        return state->end - state->begin;
}

insert *insert_prop_column_begin(col_state *state_out,
                                                          insert *inserter_in, const char *key,
                                                          col_it_type_e type, u64 cap)
{
        ERROR_IF_AND_RETURN(inserter_in->context_type != OBJECT, ERR_UNSUPPCONTAINER, NULL);
        string_field_nomarker_write(&inserter_in->file, key);
        return insert_column_begin(state_out, inserter_in, type, cap);
}

u64 insert_prop_column_end(col_state *state_in)
{
        insert_column_end(state_in);
        return state_in->end - state_in->begin;
}

static bool
write_field_data(insert *in, u8 field_marker, const void *base, u64 nbytes)
{
        assert(in->context_type == ARRAY || in->context_type == OBJECT);

        MEMFILE_ENSURE_SPACE(&in->file, sizeof(u8) + nbytes);
        MEMFILE_WRITE(&in->file, &field_marker, sizeof(u8));
        return MEMFILE_WRITE(&in->file, base, nbytes);
}

static bool push_in_column(insert *in, const void *base, field_e type)
{
        assert(in->context_type == COLUMN);

        size_t type_size = INTERNAL_GET_TYPE_VALUE_SIZE(type);

        MEMFILE_SAVE_POSITION(&in->file);

        // Increase element counter
        MEMFILE_SEEK(&in->file, in->context.column->header_begin);
        u32 num_elems = MEMFILE_PEEK_UINTVAR_STREAM(NULL, &in->file);
        num_elems++;
        MEMFILE_UPDATE_UINTVAR_STREAM(&in->file, num_elems);
        in->context.column->num = num_elems;

        u32 capacity = MEMFILE_READ_UINTVAR_STREAM(NULL, &in->file);

        if (UNLIKELY(num_elems > capacity)) {
                MEMFILE_SAVE_POSITION(&in->file);

                u32 new_capacity = (capacity + 1) * 1.7f;

                // Update capacity counter
                MEMFILE_SEEK(&in->file, in->context.column->header_begin);
                MEMFILE_SKIP_UINTVAR_STREAM(&in->file); // skip num element counter
                MEMFILE_UPDATE_UINTVAR_STREAM(&in->file, new_capacity);
                in->context.column->cap = new_capacity;

                size_t payload_start = internal_column_get_payload_off(in->context.column);
                MEMFILE_SEEK(&in->file, payload_start + (num_elems - 1) * type_size);
                MEMFILE_ENSURE_SPACE(&in->file, (new_capacity - capacity) * type_size);

                MEMFILE_RESTORE_POSITION(&in->file);
        }

        size_t payload_start = internal_column_get_payload_off(in->context.column);
        MEMFILE_SEEK(&in->file, payload_start + (num_elems - 1) * type_size);
        MEMFILE_WRITE(&in->file, base, type_size);

        MEMFILE_RESTORE_POSITION(&in->file);
        return true;
}

static bool push_media_type_for_array(insert *in, field_e type)
{
        MEMFILE_ENSURE_SPACE(&in->file, sizeof(media_type));
        return mime_write(&in->file, type);
}

static void internal_create(insert *in, memfile *src, offset_t pos)
{
        MEMFILE_CLONE(&in->file, src);
        in->position = pos ? pos : MEMFILE_TELL(src);
        MEMFILE_SEEK(&in->file, in->position);
}

static void write_binary_blob(insert *in, const void *value, size_t nbytes)
{
        /** write blob length */
        MEMFILE_WRITE_UINTVAR_STREAM(NULL, &in->file, nbytes);

        /** write blob */
        MEMFILE_ENSURE_SPACE(&in->file, nbytes);
        MEMFILE_WRITE(&in->file, value, nbytes);
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file is for internal usage only; do not call these functions from outside
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/uintvar/stream.h>
#include <karbonit/rec.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/mime.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/key.h>
#include <karbonit/carbon/commit.h>
#include <karbonit/json/json-parser.h>
#include <karbonit/carbon/obj-it.h>

static void marker_insert(memfile *memfile, u8 marker);

static bool array_is_slot_occupied(bool *is_empty_slot, bool *is_array_end, arr_it *it);

static bool object_it_is_slot_occupied(bool *is_empty_slot, bool *is_object_end, obj_it *it);

static bool is_slot_occupied(bool *is_empty_slot, bool *is_array_end, memfile *file, u8 end_marker);

static bool array_next_no_load(bool *is_empty_slot, bool *is_array_end, arr_it *it);

static bool object_it_next_no_load(bool *is_empty_slot, bool *is_array_end, obj_it *it);

static void int_carbon_from_json_elem(insert *ins, const json_element *elem, bool is_root);

static void int_insert_prop_object(insert *oins, json_object *obj);



static void
insert_embedded_container(memfile *memfile, u8 begin_marker, u8 end_marker, u8 capacity)
{
        MEMFILE_ENSURE_SPACE(memfile, sizeof(u8));
        marker_insert(memfile, begin_marker);

        MEMFILE_ENSURE_SPACE(memfile, capacity + sizeof(u8));

        offset_t payload_begin = MEMFILE_TELL(memfile);
        MEMFILE_SEEK(memfile, payload_begin + capacity);

        marker_insert(memfile, end_marker);

        /** seek to first entry in container */
        MEMFILE_SEEK(memfile, payload_begin);
}

bool internal_insert_object(memfile *file, map_type_e derivation, size_t nbytes)
{
        assert(derivation == MAP_UNSORTED_MULTIMAP || derivation == MAP_SORTED_MULTIMAP ||
               derivation == MAP_UNSORTED_MAP || derivation == MAP_SORTED_MAP);
        derived_e begin_marker = abstract_derive_map_to(derivation);
        insert_embedded_container(file, begin_marker, MOBJECT_END, nbytes);
        return true;
}

bool internal_insert_array(memfile *file, list_type_e derivation, size_t nbytes)
{
        assert(derivation == LIST_UNSORTED_MULTISET || derivation == LIST_SORTED_MULTISET ||
               derivation == LIST_UNSORTED_SET || derivation == LIST_SORTED_SET);
        derived_e begin_marker = abstract_derive_list_to(LIST_ARRAY, derivation);
        insert_embedded_container(file, begin_marker, MARRAY_END, nbytes);
        return true;
}

bool internal_insert_column(memfile *memfile_in, list_type_e derivation, col_it_type_e type,
                              size_t capactity)
{
        assert(derivation == LIST_UNSORTED_MULTISET || derivation == LIST_SORTED_MULTISET ||
               derivation == LIST_UNSORTED_SET || derivation == LIST_SORTED_SET);

        field_e column_type = field_for_column(derivation, type);

        MEMFILE_ENSURE_SPACE(memfile_in, sizeof(u8));
        marker_insert(memfile_in, column_type);

        u32 num_elements = 0;
        u32 cap_elements = capactity;

        MEMFILE_WRITE_UINTVAR_STREAM(NULL, memfile_in, num_elements);
        MEMFILE_WRITE_UINTVAR_STREAM(NULL, memfile_in, cap_elements);

        offset_t payload_begin = MEMFILE_TELL(memfile_in);

        size_t type_size = INTERNAL_GET_TYPE_VALUE_SIZE(column_type);

        size_t nbytes = capactity * type_size;
        MEMFILE_ENSURE_SPACE(memfile_in, nbytes + sizeof(u8) + 2 * sizeof(u32));

        /** seek to first entry in column */
        MEMFILE_SEEK(memfile_in, payload_begin);

        return true;
}

bool internal_object_it_next(bool *is_empty_slot, bool *is_object_end, obj_it *it)
{
        if (internal_object_it_refresh(is_empty_slot, is_object_end, it)) {
                internal_object_it_prop_value_skip(it);
                return true;
        } else {
                return false;
        }
}

bool internal_object_it_refresh(bool *is_empty_slot, bool *is_object_end, obj_it *it)
{
        if (object_it_is_slot_occupied(is_empty_slot, is_object_end, it)) {
                internal_object_it_prop_key_access(it);
                internal_field_data_access(&it->file, &it->field.value.data);
                return true;
        } else {
                return false;
        }
}

bool internal_object_it_prop_key_access(obj_it *it)
{
        it->field.key.start = MEMFILE_TELL(&it->file);
        it->field.key.name_len = MEMFILE_READ_UINTVAR_STREAM(NULL, &it->file);
        it->field.key.name = MEMFILE_PEEK(&it->file, it->field.key.name_len);
        MEMFILE_SKIP(&it->file, it->field.key.name_len);
        it->field.value.start = MEMFILE_TELL(&it->file);
        it->field.value.data.type = *MEMFILE_PEEK_TYPE(&it->file, u8);

        return true;
}

bool internal_object_it_prop_value_skip(obj_it *it)
{
        MEMFILE_SEEK(&it->file, it->field.value.start);
        return carbon_field_skip(&it->file);
}

bool internal_object_it_prop_skip(obj_it *it)
{
        it->field.key.name_len = MEMFILE_READ_UINTVAR_STREAM(NULL, &it->file);
        MEMFILE_SKIP(&it->file, it->field.key.name_len);
        return carbon_field_skip(&it->file);
}

bool internal_object_skip_contents(bool *is_empty_slot, bool *is_array_end, obj_it *it)
{
        while (object_it_next_no_load(is_empty_slot, is_array_end, it)) {}
        return true;
}

bool internal_array_skip_contents(bool *is_empty_slot, bool *is_array_end, arr_it *it)
{
        while (array_next_no_load(is_empty_slot, is_array_end, it)) {}
        return true;
}

bool internal_array_refresh(bool *is_empty_slot, bool *is_array_end, arr_it *it)
{
        if (array_is_slot_occupied(is_empty_slot, is_array_end, it)) {
                internal_array_field_read(it);
                internal_field_data_access(&it->file, &it->field);
                return true;
        } else {
                return false;
        }
}

bool internal_array_field_read(arr_it *it)
{
        ERROR_IF_AND_RETURN(MEMFILE_REMAIN_SIZE(&it->file) < 1, ERR_ILLEGALOP, NULL);
        MEMFILE_SAVE_POSITION(&it->file);
        it->field_offset = MEMFILE_TELL(&it->file);
        u8 media_type = *MEMFILE_READ(&it->file, 1);
        ERROR_IF_AND_RETURN(media_type == 0, ERR_NOTFOUND, NULL)
        ERROR_IF_AND_RETURN(media_type == MARRAY_END, ERR_OUTOFBOUNDS, NULL)
        it->field.type = media_type;
        MEMFILE_RESTORE_POSITION(&it->file);
        return true;
}

bool internal_field_data_access(memfile *file, field *field)
{
        MEMFILE_SAVE_POSITION(file);
        MEMFILE_SKIP(file, sizeof(media_type));

        switch (field->type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                        break;
                case FIELD_STRING: {
                        u8 nbytes;
                        uintvar_stream_t len = (uintvar_stream_t) MEMFILE_PEEK(file, 1);
                        field->len = UINTVAR_STREAM_READ(&nbytes, len);

                        MEMFILE_SKIP(file, nbytes);
                }
                        break;
                case FIELD_BINARY: {
                        /** read mime type with variable-length integer type */
                        u64 mime_id = MEMFILE_READ_UINTVAR_STREAM(NULL, file);

                        field->mime = mime_by_id(mime_id);
                        field->mime_len = strlen(field->mime);

                        /** read blob length */
                        field->len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);

                        /** the mem points now to the actual blob data, which is used by the iterator to set the field */
                }
                        break;
                case FIELD_BINARY_CUSTOM: {
                        /** read mime type str_buf */
                        field->mime_len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
                        field->mime = MEMFILE_READ(file, field->mime_len);

                        /** read blob length */
                        field->len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);

                        /** the mem points now to the actual blob data, which is used by the iterator to set the field */
                }
                        break;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:

                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:

                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                        field->data = MEMFILE_PEEK__FAST(file) - sizeof(u8);
                        break;
                default:
                        return ERROR(ERR_CORRUPTED, NULL);
        }

        field->data = MEMFILE_PEEK(file, 1);
        MEMFILE_RESTORE_POSITION(file);
        return true;
}

offset_t internal_column_get_payload_off(col_it *it)
{
        MEMFILE_SAVE_POSITION(&it->file);
        MEMFILE_SEEK(&it->file, it->header_begin);
        MEMFILE_SKIP_UINTVAR_STREAM(&it->file); // skip num of elements
        MEMFILE_SKIP_UINTVAR_STREAM(&it->file); // skip capacity of elements
        offset_t result = MEMFILE_TELL(&it->file);
        MEMFILE_RESTORE_POSITION(&it->file);
        return result;
}

u64 internal_header_get_commit_hash(rec *doc)
{
        assert(doc);
        u64 rev = 0;
        key_e rec_key_type;

        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);

        key_skip(&rec_key_type, &doc->file);
        if (rec_key_type != KEY_NOKEY) {
                commit_read(&rev, &doc->file);
        }

        MEMFILE_RESTORE_POSITION(&doc->file);
        return rev;
}

void internal_history_push(vec ofType(offset_t) *vec, offset_t off)
{
        assert(vec);
        vec_push(vec, &off, 1);
}

void internal_history_clear(vec ofType(offset_t) *vec)
{
        assert(vec);
        vec_clear(vec);
}

offset_t internal_history_pop(vec ofType(offset_t) *vec)
{
        assert(vec);
        assert(internal_history_has(vec));
        return *(offset_t *) vec_pop(vec);
}

offset_t internal_history_peek(vec ofType(offset_t) *vec)
{
        assert(vec);
        assert(internal_history_has(vec));
        return *(offset_t *) vec_peek(vec);
}

bool internal_history_has(vec ofType(offset_t) *vec)
{
        assert(vec);
        return !vec_is_empty(vec);
}

bool internal_field_clone(field *dst, field *src)
{
        dst->type = src->type;
        dst->data = src->data;
        dst->len = src->len;
        dst->mime = src->mime;
        dst->mime_len = src->mime_len;
        return true;
}

bool internal_field_field_type(field_e *type, field *field)
{
        *type = field->type;
        return true;
}

bool internal_field_bool_value(bool *value, field *field)
{
        bool is_true = field->type == FIELD_TRUE;
        bool is_false = field->type == FIELD_FALSE;
        if (LIKELY(is_true || is_false)) {
                *value = is_true;
                return true;
        } else {
                ERROR(ERR_TYPEMISMATCH, NULL);
                return false;
        }
}

bool internal_field_is_null(bool *is_null, field *field)
{
        *is_null = field->type == FIELD_NULL;
        return true;
}

const char *internal_field_string_value(u64 *strlen, field *field)
{
        *strlen = field->len;
        return field->data;
}

bool
internal_field_binary_value(binary_field *out, field *field)
{
        ERROR_IF_AND_RETURN(field->type != FIELD_BINARY &&
                 field->type != FIELD_BINARY_CUSTOM,
                 ERR_TYPEMISMATCH, NULL);
        out->blob = field->data;
        out->blob_len = field->len;
        out->mime = field->mime;
        out->mime_len = field->mime_len;
        return true;
}

bool internal_field_remove(memfile *memfile, field_e type)
{
        assert((field_e) *MEMFILE_PEEK(memfile, sizeof(u8)) == type);
        offset_t start_off = MEMFILE_TELL(memfile);
        MEMFILE_SKIP(memfile, sizeof(u8));
        size_t rm_nbytes = sizeof(u8); /** at least the type marker must be removed */
        switch (type) {
        case FIELD_NULL:
        case FIELD_TRUE:
        case FIELD_FALSE:
                /** nothing to do */
                break;
        case FIELD_NUMBER_U8:
        case FIELD_NUMBER_I8:
                rm_nbytes += sizeof(u8);
                break;
        case FIELD_NUMBER_U16:
        case FIELD_NUMBER_I16:
                rm_nbytes += sizeof(u16);
                break;
        case FIELD_NUMBER_U32:
        case FIELD_NUMBER_I32:
                rm_nbytes += sizeof(u32);
                break;
        case FIELD_NUMBER_U64:
        case FIELD_NUMBER_I64:
                rm_nbytes += sizeof(u64);
                break;
        case FIELD_NUMBER_FLOAT:
                rm_nbytes += sizeof(float);
                break;
        case FIELD_STRING: {
                u8 len_nbytes;  /** number of bytes used to store str_buf length */
                u64 str_len; /** the number of characters of the str_buf field */

                str_len = MEMFILE_READ_UINTVAR_STREAM(&len_nbytes, memfile);

                rm_nbytes += len_nbytes + str_len;
        }
                break;
        case FIELD_BINARY: {
                u8 mime_nbytes; /** number of bytes for mime type */
                u8 blob_length_nbytes; /** number of bytes to store blob length */
                u64 blob_nbytes; /** number of bytes to store actual blob data */

                /** get bytes used for mime type id */
                MEMFILE_READ_UINTVAR_STREAM(&mime_nbytes, memfile);

                /** get bytes used for blob length info */
                blob_nbytes = MEMFILE_READ_UINTVAR_STREAM(&blob_length_nbytes, memfile);

                rm_nbytes += mime_nbytes + blob_length_nbytes + blob_nbytes;
        }
                break;
        case FIELD_BINARY_CUSTOM: {
                u8 custom_type_strlen_nbytes; /** number of bytes for type name str_buf length info */
                u8 custom_type_strlen; /** number of characters to encode type name str_buf */
                u8 blob_length_nbytes; /** number of bytes to store blob length */
                u64 blob_nbytes; /** number of bytes to store actual blob data */

                /** get bytes for custom type str_buf len, and the actual length */
                custom_type_strlen = MEMFILE_READ_UINTVAR_STREAM(&custom_type_strlen_nbytes, memfile);
                MEMFILE_SKIP(memfile, custom_type_strlen);

                /** get bytes used for blob length info */
                blob_nbytes = MEMFILE_READ_UINTVAR_STREAM(&blob_length_nbytes, memfile);

                rm_nbytes += custom_type_strlen_nbytes + custom_type_strlen + blob_length_nbytes + blob_nbytes;
        }
                break;
        case FIELD_ARRAY_UNSORTED_MULTISET:
        case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
        case FIELD_DERIVED_ARRAY_UNSORTED_SET:
        case FIELD_DERIVED_ARRAY_SORTED_SET: {
                arr_it it;

                offset_t begin_off = MEMFILE_TELL(memfile);
                internal_arr_it_create(&it, memfile, begin_off - sizeof(u8));
                internal_arr_it_fast_forward(&it);
                offset_t end_off = internal_arr_it_memfilepos(&it);

                assert(begin_off < end_off);
                rm_nbytes += (end_off - begin_off);
        }
                break;
        case FIELD_COLUMN_U8_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
        case FIELD_COLUMN_U16_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
        case FIELD_COLUMN_U32_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
        case FIELD_COLUMN_U64_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
        case FIELD_COLUMN_I8_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
        case FIELD_COLUMN_I16_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
        case FIELD_COLUMN_I32_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
        case FIELD_COLUMN_I64_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
        case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
        case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
        case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
        case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                col_it it;

                offset_t begin_off = MEMFILE_TELL(memfile);
                col_it_create(&it, memfile, begin_off - sizeof(u8));
                col_it_fast_forward(&it);
                offset_t end_off = col_it_memfilepos(&it);

                assert(begin_off < end_off);
                rm_nbytes += (end_off - begin_off);
        }
                break;
        case FIELD_OBJECT_UNSORTED_MULTIMAP:
        case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
        case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
        case FIELD_DERIVED_OBJECT_SORTED_MAP: {
                obj_it it;

                offset_t begin_off = MEMFILE_TELL(memfile);
                internal_obj_it_create(&it, memfile, begin_off - sizeof(u8));
                internal_obj_it_fast_forward(&it);
                offset_t end_off = internal_obj_it_memfile_pos(&it);

                assert(begin_off < end_off);
                rm_nbytes += (end_off - begin_off);
        }
                break;
        default:
                return ERROR(ERR_INTERNALERR, NULL);
        }
        MEMFILE_SEEK(memfile, start_off);
        MEMFILE_INPLACE_REMOVE(memfile, rm_nbytes);

        return true;
}

static void int_insert_array_array(insert *array_ins, json_array *array)
{
        arr_state state;
        insert *sub_ins = insert_array_begin(&state, array_ins,
                                                                      array->elements.elements.num_elems * 256);
        for (u32 i = 0; i < array->elements.elements.num_elems; i++) {
                const json_element *elem = VEC_GET(&array->elements.elements, i, json_element);
                int_carbon_from_json_elem(sub_ins, elem, false);
        }
        insert_array_end(&state);
}

static void int_insert_array_string(insert *array_ins, json_string *string)
{
        insert_string(array_ins, string->value);
}

static void int_insert_array_number(insert *array_ins, json_number *number)
{
        switch (number->value_type) {
                case JSON_NUMBER_FLOAT:
                        insert_float(array_ins, number->value.float_number);
                        break;
                case JSON_NUMBER_UNSIGNED:
                        insert_unsigned(array_ins, number->value.unsigned_integer);
                        break;
                case JSON_NUMBER_SIGNED:
                        insert_signed(array_ins, number->value.signed_integer);
                        break;
                default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
        }
}

static void int_insert_array_true(insert *array_ins)
{
        insert_true(array_ins);
}

static void int_insert_array_false(insert *array_ins)
{
        insert_false(array_ins);
}

static void int_insert_array_null(insert *array_ins)
{
        insert_null(array_ins);
}

static void int_insert_array_elements(insert *array_ins, json_array *array)
{
        for (u32 i = 0; i < array->elements.elements.num_elems; i++) {
                json_element *elem = VEC_GET(&array->elements.elements, i, json_element);
                switch (elem->value.value_type) {
                        case JSON_VALUE_OBJECT: {
                                obj_state state;
                                insert *sub_obj = insert_object_begin(&state, array_ins,
                                                                                               elem->value.value.object->value->members.num_elems *
                                                                                               256);
                                int_insert_prop_object(sub_obj, elem->value.value.object);
                                insert_object_end(&state);
                        }
                                break;
                        case JSON_VALUE_ARRAY:
                                int_insert_array_array(array_ins, elem->value.value.array);
                                break;
                        case JSON_VALUE_STRING:
                                int_insert_array_string(array_ins, elem->value.value.string);
                                break;
                        case JSON_VALUE_NUMBER:
                                int_insert_array_number(array_ins, elem->value.value.number);
                                break;
                        case JSON_VALUE_TRUE:
                                int_insert_array_true(array_ins);
                                break;
                        case JSON_VALUE_FALSE:
                                int_insert_array_false(array_ins);
                                break;
                        case JSON_VALUE_NULL:
                                int_insert_array_null(array_ins);
                                break;
                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                break;
                }
        }
}

#define insert_into_array(ins, elem, ctype, accessor)                                                                  \
{                                                                                                                      \
        for (u32 k = 0; k < elem->value.value.array->elements.elements.num_elems; k++) {                               \
                json_element *array_elem = VEC_GET(                                                             \
                        &elem->value.value.array->elements.elements, k, json_element);                          \
                if (array_elem->value.value_type == JSON_VALUE_NULL) {                                                 \
                        insert_null(ins);                                                                       \
                } else {                                                                                               \
                        insert_##ctype(ins, array_elem->value.value.number->value.accessor);                    \
                }                                                                                                      \
        }                                                                                                              \
}

#define insert_into_column(ins, elem, field_type, column_type, ctype, accessor)                                        \
({                                                                                                                     \
        col_state state;                                                                       \
        u64 approx_cap_nbytes = elem->value.value.array->elements.elements.num_elems *                                 \
                                INTERNAL_GET_TYPE_VALUE_SIZE(field_type);                                            \
        insert *cins = insert_column_begin(&state, ins,                                           \
                                                                column_type, approx_cap_nbytes);                       \
        for (u32 k = 0; k < elem->value.value.array->elements.elements.num_elems; k++) {                               \
                json_element *array_elem = VEC_GET(&elem->value.value.array->elements.elements,                 \
                                                          k, json_element);                                     \
                if (array_elem->value.value_type == JSON_VALUE_NULL) {                                                 \
                        insert_null(cins);                                                                      \
                } else {                                                                                               \
                        insert_##ctype(cins, (ctype) array_elem->value.value.number->value.accessor);           \
                }                                                                                                      \
        }                                                                                                              \
        insert_column_end(&state);                                                                              \
})

#define prop_insert_into_column(ins, prop, key, field_type, column_type, ctype, accessor)                                   \
({                                                                                                                     \
        col_state state;                                                                       \
        u64 approx_cap_nbytes = prop->value.value.value.array->elements.elements.num_elems *                                 \
                                INTERNAL_GET_TYPE_VALUE_SIZE(field_type);                                            \
        insert *cins = insert_prop_column_begin(&state, ins, key,                                          \
                                                                column_type, approx_cap_nbytes);                       \
        for (u32 k = 0; k < prop->value.value.value.array->elements.elements.num_elems; k++) {                               \
                json_element *array_elem = VEC_GET(&prop->value.value.value.array->elements.elements,                 \
                                                          k, json_element);                                     \
                if (array_elem->value.value_type == JSON_VALUE_NULL) {                                                 \
                        insert_null(cins);                                                                      \
                } else {                                                                                               \
                        insert_##ctype(cins, (ctype) array_elem->value.value.number->value.accessor);           \
                }                                                                                                      \
        }                                                                                                              \
        insert_prop_column_end(&state);                                                                              \
})

static void int_insert_prop_object(insert *oins, json_object *obj)
{
        for (u32 i = 0; i < obj->value->members.num_elems; i++) {
                json_prop *prop = VEC_GET(&obj->value->members, i, json_prop);
                switch (prop->value.value.value_type) {
                        case JSON_VALUE_OBJECT: {
                                obj_state state;
                                insert *sub_obj = insert_prop_object_begin(&state, oins,
                                                                                                    prop->key.value,
                                                                                                    prop->value.value.value.object->value->members.num_elems *
                                                                                                    256);
                                int_insert_prop_object(sub_obj, prop->value.value.value.object);
                                insert_prop_object_end(&state);
                        }
                                break;
                        case JSON_VALUE_ARRAY: {
                                json_list_type_e type;
                                json_array_get_type(&type, prop->value.value.value.array);
                                switch (type) {
                                        case JSON_LIST_EMPTY: {
                                                arr_state state;
                                                insert_prop_array_begin(&state, oins, prop->key.value, 0);
                                                insert_prop_array_end(&state);
                                        }
                                                break;
                                        case JSON_LIST_VARIABLE_OR_NESTED: {
                                                arr_state state;
                                                u64 approx_cap_nbytes =
                                                        prop->value.value.value.array->elements.elements.num_elems *
                                                        256;
                                                insert *array_ins = insert_prop_array_begin(
                                                        &state, oins,
                                                        prop->key.value, approx_cap_nbytes);
                                                int_insert_array_elements(array_ins, prop->value.value.value.array);
                                                insert_prop_array_end(&state);
                                        }
                                                break;
                                        case JSON_LIST_FIXED_U8:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_U8,
                                                                        COLUMN_U8,
                                                                        u8, unsigned_integer);
                                                break;
                                        case JSON_LIST_FIXED_U16:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_U16,
                                                                        COLUMN_U16,
                                                                        u16, unsigned_integer);
                                                break;
                                        case JSON_LIST_FIXED_U32:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_U32,
                                                                        COLUMN_U32,
                                                                        u32, unsigned_integer);
                                                break;
                                        case JSON_LIST_FIXED_U64:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_U64,
                                                                        COLUMN_U64,
                                                                        u64, unsigned_integer);
                                                break;
                                        case JSON_LIST_FIXED_I8:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_I8,
                                                                        COLUMN_I8,
                                                                        i8, signed_integer);
                                                break;
                                        case JSON_LIST_FIXED_I16:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_I16,
                                                                        COLUMN_I16,
                                                                        i16, signed_integer);
                                                break;
                                        case JSON_LIST_FIXED_I32:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_I32,
                                                                        COLUMN_I32,
                                                                        i32, signed_integer);
                                                break;
                                        case JSON_LIST_FIXED_I64:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_I64,
                                                                        COLUMN_I64,
                                                                        i64, signed_integer);
                                                break;
                                        case JSON_LIST_FIXED_FLOAT:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        FIELD_NUMBER_FLOAT,
                                                                        COLUMN_FLOAT,
                                                                        float, float_number);
                                                break;
                                        case JSON_LIST_FIXED_NULL: {
                                                arr_state state;
                                                u64 approx_cap_nbytes = prop->value.value.value.array->elements.elements.num_elems;
                                                insert *array_ins = insert_prop_array_begin(
                                                        &state, oins, prop->key.value,
                                                        approx_cap_nbytes);
                                                for (u32 k = 0; k <
                                                                    prop->value.value.value.array->elements.elements.num_elems; k++) {
                                                        insert_null(array_ins);
                                                }
                                                insert_prop_array_end(&state);
                                        }
                                                break;
                                        case JSON_LIST_FIXED_BOOLEAN: {
                                                col_state state;
                                                u64 cap_nbytes = prop->value.value.value.array->elements.elements.num_elems;
                                                insert *array_ins = insert_prop_column_begin(
                                                        &state, oins,
                                                        prop->key.value,
                                                        COLUMN_BOOLEAN, cap_nbytes);
                                                for (u32 k = 0; k <
                                                                    prop->value.value.value.array->elements.elements.num_elems; k++) {
                                                        json_element *array_elem = VEC_GET(
                                                                &prop->value.value.value.array->elements.elements, k,
                                                                json_element);
                                                        if (array_elem->value.value_type == JSON_VALUE_TRUE) {
                                                                insert_true(array_ins);
                                                        } else if (array_elem->value.value_type == JSON_VALUE_FALSE) {
                                                                insert_false(array_ins);
                                                        } else if (array_elem->value.value_type == JSON_VALUE_NULL) {
                                                                insert_null(array_ins);
                                                        } else {
                                                                ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                        }
                                                }
                                                insert_prop_column_end(&state);
                                        }
                                                break;
                                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                break;
                                }
                        }
                                break;
                        case JSON_VALUE_STRING:
                                insert_prop_string(oins, prop->key.value, prop->value.value.value.string->value);
                                break;
                        case JSON_VALUE_NUMBER:
                                switch (prop->value.value.value.number->value_type) {
                                        case JSON_NUMBER_FLOAT:
                                                insert_prop_float(oins, prop->key.value,
                                                                         prop->value.value.value.number->value.float_number);
                                                break;
                                        case JSON_NUMBER_UNSIGNED:
                                                insert_prop_unsigned(oins, prop->key.value,
                                                                            prop->value.value.value.number->value.unsigned_integer);
                                                break;
                                        case JSON_NUMBER_SIGNED:
                                                insert_prop_signed(oins, prop->key.value,
                                                                          prop->value.value.value.number->value.signed_integer);
                                                break;
                                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                break;
                                }
                                break;
                        case JSON_VALUE_TRUE:
                                insert_prop_true(oins, prop->key.value);
                                break;
                        case JSON_VALUE_FALSE:
                                insert_prop_false(oins, prop->key.value);
                                break;
                        case JSON_VALUE_NULL:
                                insert_prop_null(oins, prop->key.value);
                                break;
                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                break;
                }
        }
}

static void int_carbon_from_json_elem(insert *ins, const json_element *elem, bool is_root)
{
        switch (elem->value.value_type) {
                case JSON_VALUE_OBJECT: {
                        obj_state state;
                        insert *oins = insert_object_begin(&state, ins,
                                                                                    elem->value.value.object->value->members.num_elems *
                                                                                    256);
                        int_insert_prop_object(oins, elem->value.value.object);
                        insert_object_end(&state);
                }
                        break;
                case JSON_VALUE_ARRAY: {
                        json_list_type_e type;
                        json_array_get_type(&type, elem->value.value.array);
                        switch (type) {
                                case JSON_LIST_EMPTY: {
                                        if (is_root) {
                                                /** nothing to do */
                                        } else {
                                                arr_state state;
                                                insert_array_begin(&state, ins, 0);
                                                insert_array_end(&state);
                                        }
                                }
                                        break;
                                case JSON_LIST_VARIABLE_OR_NESTED: {
                                        u64 approx_cap_nbytes =
                                                elem->value.value.array->elements.elements.num_elems * 256;
                                        if (is_root) {
                                                int_insert_array_elements(ins, elem->value.value.array);
                                        } else {
                                                arr_state state;
                                                insert *array_ins = insert_array_begin(&state,
                                                                                                                ins,
                                                                                                                approx_cap_nbytes);
                                                int_insert_array_elements(array_ins, elem->value.value.array);
                                                insert_array_end(&state);
                                        }
                                }
                                        break;
                                case JSON_LIST_FIXED_U8:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_U8,
                                                                   COLUMN_U8,
                                                                   u8, unsigned_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_U16:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_U16,
                                                                   COLUMN_U16,
                                                                   u16, unsigned_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_U32:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_U32,
                                                                   COLUMN_U32,
                                                                   u32, unsigned_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_U64:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_U64,
                                                                   COLUMN_U64,
                                                                   u64, unsigned_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_I8:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_I8,
                                                                   COLUMN_I8,
                                                                   i8, signed_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_I16:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_I16,
                                                                   COLUMN_I16,
                                                                   u16, signed_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_I32:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_I32,
                                                                   COLUMN_I32,
                                                                   u32, signed_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_I64:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_I64,
                                                                   COLUMN_I64,
                                                                   u64, signed_integer);
                                        }
                                        break;
                                case JSON_LIST_FIXED_FLOAT:
                                        if (is_root) {
                                                insert_into_array(ins, elem, float, float_number)
                                        } else {
                                                insert_into_column(ins, elem, FIELD_NUMBER_FLOAT,
                                                                   COLUMN_FLOAT,
                                                                   float, float_number);
                                        }
                                        break;
                                case JSON_LIST_FIXED_NULL: {
                                        u64 approx_cap_nbytes = elem->value.value.array->elements.elements.num_elems;
                                        if (is_root) {
                                                for (u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        insert_null(ins);
                                                }
                                        } else {
                                                arr_state state;
                                                insert *array_ins = insert_array_begin(&state,
                                                                                                                ins,
                                                                                                                approx_cap_nbytes);
                                                for (u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        insert_null(array_ins);
                                                }
                                                insert_array_end(&state);
                                        }
                                }
                                        break;
                                case JSON_LIST_FIXED_BOOLEAN: {
                                        if (is_root) {
                                                for (u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        json_element *array_elem = VEC_GET(
                                                                &elem->value.value.array->elements.elements, i,
                                                                json_element);
                                                        if (array_elem->value.value_type == JSON_VALUE_TRUE) {
                                                                insert_true(ins);
                                                        } else if (array_elem->value.value_type == JSON_VALUE_FALSE) {
                                                                insert_false(ins);
                                                        } else if (array_elem->value.value_type == JSON_VALUE_NULL) {
                                                                insert_null(ins);
                                                        } else {
                                                                ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                        }
                                                }
                                        } else {
                                                col_state state;
                                                u64 cap_nbytes = elem->value.value.array->elements.elements.num_elems;
                                                insert *array_ins = insert_column_begin(&state,
                                                                                                                 ins,
                                                                                                                 COLUMN_BOOLEAN,
                                                                                                                 cap_nbytes);
                                                for (u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        json_element *array_elem = VEC_GET(
                                                                &elem->value.value.array->elements.elements, i,
                                                                json_element);
                                                        if (array_elem->value.value_type == JSON_VALUE_TRUE) {
                                                                insert_true(array_ins);
                                                        } else if (array_elem->value.value_type == JSON_VALUE_FALSE) {
                                                                insert_false(array_ins);
                                                        } else if (array_elem->value.value_type == JSON_VALUE_NULL) {
                                                                insert_null(array_ins);
                                                        } else {
                                                                ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                        }
                                                }
                                                insert_column_end(&state);
                                        }
                                }
                                        break;
                                default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                        break;
                        }
                }
                        break;
                case JSON_VALUE_STRING:
                        insert_string(ins, elem->value.value.string->value);
                        break;
                case JSON_VALUE_NUMBER:
                        switch (elem->value.value.number->value_type) {
                                case JSON_NUMBER_FLOAT:
                                        insert_float(ins, elem->value.value.number->value.float_number);
                                        break;
                                case JSON_NUMBER_UNSIGNED:
                                        insert_unsigned(ins, elem->value.value.number->value.unsigned_integer);
                                        break;
                                case JSON_NUMBER_SIGNED:
                                        insert_signed(ins, elem->value.value.number->value.signed_integer);
                                        break;
                                default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                        break;
                        }
                        break;
                case JSON_VALUE_TRUE:
                        insert_true(ins);
                        break;
                case JSON_VALUE_FALSE:
                        insert_false(ins);
                        break;
                case JSON_VALUE_NULL:
                        insert_null(ins);
                        break;
                default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                        break;
        }
}

void internal_from_json(rec *doc, const json *data,
                          key_e rec_key_type, const void *primary_key, int mode, u64 approx_doc_capacity_nbyte)
{
        UNUSED(data)
        UNUSED(primary_key)

        rec_new context;
        insert *ins = rec_create_begin_ex(&context, doc, rec_key_type, mode, approx_doc_capacity_nbyte);
        int_carbon_from_json_elem(ins, data->element, true);

        rec_create_end(&context);
}

static void marker_insert(memfile *memfile, u8 marker)
{
        /** check whether marker can be written, otherwise make space for it */
        char c = *MEMFILE_PEEK(memfile, sizeof(u8));
        if (c != 0) {
                MEMFILE_INPLACE_INSERT(memfile, sizeof(u8));
        }
        MEMFILE_WRITE(memfile, &marker, sizeof(u8));
}

static bool array_is_slot_occupied(bool *is_empty_slot, bool *is_array_end, arr_it *it)
{
        return is_slot_occupied(is_empty_slot, is_array_end, &it->file, MARRAY_END);
}

static bool object_it_is_slot_occupied(bool *is_empty_slot, bool *is_object_end, obj_it *it)
{
        return is_slot_occupied(is_empty_slot, is_object_end, &it->file, MOBJECT_END);
}

static bool is_slot_occupied(bool *is_empty_slot, bool *is_end_reached, memfile *file, u8 end_marker)
{
        char c = *MEMFILE_PEEK__FAST(file);
        bool is_empty = c == 0, is_end = c == end_marker;
        OPTIONAL_SET(is_empty_slot, is_empty)
        OPTIONAL_SET(is_end_reached, is_end)
        if (!is_empty && !is_end) {
                return true;
        } else {
                return false;
        }
}

static bool object_it_next_no_load(bool *is_empty_slot, bool *is_array_end, obj_it *it)
{
        if (object_it_is_slot_occupied(is_empty_slot, is_array_end, it)) {
                internal_object_it_prop_skip(it);
                return true;
        } else {
                return false;
        }
}

static bool array_next_no_load(bool *is_empty_slot, bool *is_array_end, arr_it *it)
{
        if (array_is_slot_occupied(is_empty_slot, is_array_end, it)) {
                internal_array_field_read(it);
                carbon_field_skip(&it->file);
                return true;
        } else {
                return false;
        }
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/item.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/utils/numbers.h>


bool internal_item_create_from_object(item *item, obj_it *parent)
{
        item->parent_type = UNTYPED_OBJECT;
        item->parent.object = parent;
        item->idx = parent->pos;
        field_e field_type = parent->field.value.data.type;

        return ITEM_SETUP_VALUE(item, field_type, &parent->field.value.data);
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/key.h>
#include <karbonit/carbon/string-field.h>
#include <karbonit/stdx/unique_id.h>

static void write_nokey(memfile *file)
{
        u8 marker = MNOKEY;
        MEMFILE_WRITE(file, &marker, sizeof(u8));
}

static void write_autokey(memfile *file)
{
        u8 marker = MAUTOKEY;
        unique_id_t key;
        unique_id_create(&key);
        MEMFILE_WRITE(file, &marker, sizeof(u8));
        MEMFILE_WRITE(file, &key, sizeof(unique_id_t));
}

static void write_ukey(memfile *file)
{
        u8 marker = MUKEY;
        u64 key = 0;
        MEMFILE_WRITE(file, &marker, sizeof(u8));
        MEMFILE_WRITE(file, &key, sizeof(u64));
}

static void write_ikey(memfile *file)
{
        u8 marker = MIKEY;
        i64 key = 0;
        MEMFILE_WRITE(file, &marker, sizeof(u8));
        MEMFILE_WRITE(file, &key, sizeof(u64));
}

static void write_skey(memfile *file)
{
        u8 marker = MSKEY;
        const char *key = "";
        MEMFILE_WRITE(file, &marker, sizeof(u8));
        string_field_write(file, key);
}

bool key_create(memfile *file, key_e type)
{
        switch (type) {
                case KEY_NOKEY:
                        write_nokey(file);
                        break;
                case KEY_AUTOKEY:
                        write_autokey(file);
                        break;
                case KEY_UKEY:
                        write_ukey(file);
                        break;
                case KEY_IKEY:
                        write_ikey(file);
                        break;
                case KEY_SKEY:
                        write_skey(file);
                        break;
                default:
                        return false;
        }
        return true;
}

bool key_skip(key_e *out, memfile *file)
{
        key_read(NULL, out, file);
        return true;
}

bool key_write_unsigned(memfile *file, u64 key)
{
        DECLARE_AND_INIT(key_e, rec_key_type)

        key_read_type(&rec_key_type, file);
        if (rec_key_is_unsigned(rec_key_type)) {
                MEMFILE_WRITE(file, &key, sizeof(u64));
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool key_write_signed(memfile *file, i64 key)
{
        DECLARE_AND_INIT(key_e, rec_key_type)

        key_read_type(&rec_key_type, file);
        if (rec_key_is_signed(rec_key_type)) {
                MEMFILE_WRITE(file, &key, sizeof(i64));
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool key_update_string(memfile *file, const char *key)
{
        return key_update_string_wnchar(file, key, strlen(key));
}

bool key_update_string_wnchar(memfile *file, const char *key, size_t length)
{
        DECLARE_AND_INIT(key_e, rec_key_type)
        key_read_type(&rec_key_type, file);
        if (rec_key_is_string(rec_key_type)) {
                string_field_update_wnchar(file, key, length);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool key_write_string(memfile *file, const char *key)
{
        DECLARE_AND_INIT(key_e, rec_key_type)

        key_read_type(&rec_key_type, file);
        if (rec_key_is_string(rec_key_type)) {
                string_field_write(file, key);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool key_read_type(key_e *out, memfile *file)
{
        u8 marker = *MEMFILE_READ_TYPE(file, u8);

        assert(marker == MNOKEY || marker == MAUTOKEY || marker ==
                                                                                                       MUKEY ||
                   marker == MIKEY || marker == MSKEY);

        switch (marker) {
                case MNOKEY:
                        OPTIONAL_SET(out, KEY_NOKEY)
                        break;
                case MAUTOKEY:
                        OPTIONAL_SET(out, KEY_AUTOKEY)
                        break;
                case MUKEY:
                        OPTIONAL_SET(out, KEY_UKEY)
                        break;
                case MIKEY:
                        OPTIONAL_SET(out, KEY_IKEY)
                        break;
                case MSKEY:
                        OPTIONAL_SET(out, KEY_SKEY)
                        break;
                default:
                        return ERROR(ERR_INTERNALERR, NULL);
        }
        return true;
}

const void *key_read(u64 *len, key_e *out, memfile *file)
{
        key_e rec_key_type = 0;
        key_read_type(&rec_key_type, file);

        OPTIONAL_SET(out, rec_key_type)

        switch (rec_key_type) {
                case KEY_NOKEY:
                        OPTIONAL_SET(len, 0)
                        return NULL;
                case KEY_AUTOKEY:
                        OPTIONAL_SET(len, sizeof(unique_id_t))
                        return MEMFILE_READ_TYPE(file, unique_id_t);
                case KEY_UKEY:
                        OPTIONAL_SET(len, sizeof(u64))
                        return MEMFILE_READ_TYPE(file, u64);
                case KEY_IKEY:
                        OPTIONAL_SET(len, sizeof(i64))
                        return MEMFILE_READ_TYPE(file, i64);
                case KEY_SKEY:
                        return string_field_read(len, file);
                default: ERROR(ERR_INTERNALERR, NULL);
                        return NULL;
        }
}

const char *key_type_str(key_e type)
{
        switch (type) {
                case KEY_NOKEY:
                        return "nokey";
                case KEY_AUTOKEY:
                        return "autokey";
                case KEY_UKEY:
                        return "ukey";
                case KEY_IKEY:
                        return "ikey";
                case KEY_SKEY:
                        return "skey";
                default: ERROR(ERR_INTERNALERR, NULL);
                        return NULL;
        }
}/*
 * Copyright 2019 Marcus Pinnecke
 */

#include <karbonit/carbon/markers.h>
#include <karbonit/carbon/traverse.h>
#include <karbonit/carbon/commit.h>

static path_policy_e markers_print_fn_record(const rec *record, const traverse_info *context, traverse_hidden *extra)
{
        str_buf *str = (str_buf *) extra->arg;
        if (context->type == ON_ENTER) {
                extra->json_printer.record_is_array = rec_is_array(record);

                key_e tk;
                rec_key_type(&tk, (rec *) record);
                str_buf_add(str, "[");
                switch (tk) {
                        case KEY_AUTOKEY:
                                str_buf_add(str, "autokey");
                                break;
                        case KEY_UKEY:
                                str_buf_add(str, "ukey");
                                break;
                        case KEY_IKEY:
                                str_buf_add(str, "ikey");
                                break;
                        case KEY_SKEY:
                                str_buf_add(str, "skey");
                                break;
                        case KEY_NOKEY:
                                str_buf_add(str, "nokey");
                                break;
                        default:
                                ERROR(ERR_MARKERMAPPING, "unknown key marker detected");
                                return PATH_PRUNE;
                };

                str_buf_add(str, "]");

                switch (tk) {
                        case KEY_AUTOKEY:
                        case KEY_UKEY: {
                                u64 key;
                                rec_key_unsigned_value(&key, (rec *) record);
                                str_buf_add(str, "[key:");
                                str_buf_add_u64(str, key);
                                str_buf_add(str, "]");
                        }
                                break;
                        case KEY_IKEY: {
                                i64 key;
                                rec_key_signed_value(&key, (rec *) record);
                                str_buf_add(str, "[key:");
                                str_buf_add_i64(str, key);
                                str_buf_add(str, "]");
                        }
                                break;
                        case KEY_SKEY: {
                                u64 keylen;
                                const char *key = key_string_value(&keylen, (rec *) record);
                                str_buf_add(str, "[key:");
                                str_buf_add(str, "[string]");
                                str_buf_add(str, "(len:");
                                str_buf_add_u64(str, keylen);
                                str_buf_add(str, ")");
                                str_buf_add(str, "[value:");
                                str_buf_add_nchar(str, key, keylen);
                                str_buf_add(str, "]");
                                str_buf_add(str, "]");
                        }
                                break;
                        case KEY_NOKEY:
                                break;
                        default:
                                ERROR(ERR_MARKERMAPPING, "unknown key marker detected");
                                return PATH_PRUNE;
                }

                switch (tk) {
                        case KEY_AUTOKEY:
                        case KEY_UKEY:
                        case KEY_IKEY:
                        case KEY_SKEY: {
                                u64 hash;
                                str_buf hash_str;
                                str_buf_create(&hash_str);

                                str_buf_add(str, "[commit:");
                                rec_commit_hash(&hash, (rec *) record);
                                str_buf_add(str, commit_to_str(&hash_str, hash));
                                str_buf_add(str, "]");

                                str_buf_drop(&hash_str);
                        }
                                break;
                        case KEY_NOKEY:
                                break;
                        default:
                                ERROR(ERR_CORRUPTED, "commit hash for unsupported key type");
                                return PATH_PRUNE;
                }
        }

        str_buf_add(str, (context->type == ON_ENTER ? " [array-begin] " : "[array-end]"));

        return PATH_EXPAND;
}

static path_policy_e markers_print_fn_array(const arr_it *array, const traverse_info *context, traverse_hidden *extra)
{
        UNUSED(array)
        str_buf *str = (str_buf *) extra->arg;
        str_buf_add(str, context->type == ON_ENTER ? "[array-begin]" : "[array-end]");
        return PATH_EXPAND;
}

static path_policy_e markers_print_fn_object(const obj_it *object, const traverse_info *context, traverse_hidden *extra)
{
        UNUSED(object)
        str_buf *str = (str_buf *) extra->arg;
        str_buf_add(str, context->type == ON_ENTER ? "[object-begin]" : "[object-end]");
        return PATH_EXPAND;
}

static void markers_print_field(str_buf *str, const item *field, const traverse_info *context)
{
        if (context->type == ON_ENTER) {
                if (ITEM_IS_NULL(field)) {
                        str_buf_add(str, "[null]");
                } else if (ITEM_IS_TRUE(field)) {
                        str_buf_add(str, "[true]");
                } else if (ITEM_IS_FALSE(field)) {
                        str_buf_add(str, "[false]");
                } else if (ITEM_IS_STRING(field)) {
                        string_field sf = ITEM_GET_STRING(field, NULL_STRING);
                        str_buf_add(str, "[string]");
                        str_buf_add(str, "(len:");
                        str_buf_add_u64(str, sf.len);
                        str_buf_add(str, ")");
                        str_buf_add(str, "[value:");
                        str_buf_add_nchar(str, sf.str, sf.len);
                        str_buf_add(str, "]");
                } else if (ITEM_IS_SIGNED(field)) {
                        i64 value = ITEM_GET_SIGNED(field, NULL_INT64);
                        str_buf_add(str, "[signed:");
                        str_buf_add_i64(str, value);
                        str_buf_add_char(str, ']');
                } else if (ITEM_IS_UNSIGNED(field)) {
                        u64 value = ITEM_GET_SIGNED(field, NULL_UINT64);
                        str_buf_add(str, "[unsigned:");
                        str_buf_add_u64(str, value);
                        str_buf_add_char(str, ']');
                } else if (ITEM_IS_FLOAT(field)) {
                        float value = ITEM_GET_FLOAT(field, NULL_FLOAT);
                        str_buf_add(str, "[float:");
                        str_buf_add_float(str, value);
                        str_buf_add_char(str, ']');
                } else if (ITEM_IS_BINARY(field)) {
                        str_buf_add(str, "[binary:");
                        binary_field value = ITEM_GET_BINARY(field, NULL_BINARY);
                        str_buf_add(str, "[mime:");
                        str_buf_add_nchar(str, value.mime, value.mime_len);
                        str_buf_add(str, "][value:");
                        binary_field_value_print(str, &value);
                        str_buf_add(str, "]]");
                } else if (ITEM_IS_COLUMN(field)) {
                        str_buf_add(str, "[column:<");
                        col_it it;
                        ITEM_GET_COLUMN(&it, field);
                        col_it_print(str, &it);
                        str_buf_add(str, ">]");
                }
        }
}

static path_policy_e markers_print_fn_field(const item *item, const traverse_info *context, traverse_hidden *extra)
{
        str_buf *str = (str_buf *) extra->arg;
        markers_print_field(str, item, context);
        return PATH_EXPAND;
}

static path_policy_e markers_print_fn_prop(const prop *prop, const traverse_info *context, traverse_hidden *extra)
{
        str_buf *str = (str_buf *) extra->arg;
        if (context->type == ON_ENTER) {
                str_buf_add(str, "[string]");
                str_buf_add(str, "(len:");
                str_buf_add_u64(str, prop->key.len);
                str_buf_add(str, ")");
                str_buf_add(str, "[value:");
                str_buf_add_nchar(str, prop->key.str, prop->key.len);
                str_buf_add(str, "]");
        }
        markers_print_field(str, &prop->value, context);
        return PATH_EXPAND;
}

traverser_fn markers_print_fn = {
        .create = NULL,
        .drop = NULL,
        .visit_record = markers_print_fn_record,
        .visit_array = markers_print_fn_array,
        .visit_object = markers_print_fn_object,
        .visit_field = markers_print_fn_field,
        .visit_prop = markers_print_fn_prop
};

void markers_print(str_buf *dst, rec *src)
{
        TRAVERSE(dst, &markers_print_fn, VISIT_ALL, traverser_run_from_record, src);
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/mime.h>

#define find_mime_by_ext(needle_ext)                                                    \
({                                                                                      \
        register size_t l = 0;                                                          \
        register size_t r = _global_mime_register - 1;                                   \
        u32 result = _global_mime_register;                                              \
        while (l <= r && r < SIZE_MAX) {                                                \
                register size_t m = l + (r - l) / 2;                                    \
                register int comp = strcmp(global_mime_register[m].ext, needle_ext);      \
                if (comp == 0) {                                                        \
                        result = m;                                                     \
                        break;                                                          \
                }                                                                       \
                if (comp < 0) {                                                         \
                        l = m + 1;                                                      \
                } else {                                                                \
                        r = m - 1;                                                      \
                }                                                                       \
        }                                                                               \
        result;                                                                         \
})

bool mime_write(memfile *dst, field_e type)
{
        media_type t = type;
        MEMFILE_WRITE(dst, &t, sizeof(media_type));
        return true;
}

u32 mime_by_ext(const char *ext)
{
        u32 id;
        if (LIKELY(ext != NULL)) {
                if (LIKELY((id = find_mime_by_ext(ext)) < (u32) _global_mime_register)) {
                        return id;
                }
        }
        id = find_mime_by_ext("bin");
        assert(id < _global_mime_register);
        return id;
}

const char *mime_by_id(u32 id)
{
        if (UNLIKELY(id >= _global_mime_register)) {
                id = find_mime_by_ext("bin");
                assert(id < _global_mime_register);
        }
        return global_mime_register[id].type;
}

const char *mime_ext_by_id(u32 id)
{
        if (UNLIKELY(id >= _global_mime_register)) {
                id = find_mime_by_ext("bin");
                assert(id < _global_mime_register);
        }
        return global_mime_register[id].ext;
}


/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/rec.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/string-field.h>
#include <karbonit/carbon/prop.h>
#include <karbonit/carbon/internal.h>

bool internal_obj_it_create(obj_it *it, memfile *memfile, offset_t payload_start)
{
        it->content_begin = payload_start;
        it->begin = payload_start;
        it->mod_size = 0;
        it->pos = 0;
        it->eof = false;
        it->last_off = payload_start + sizeof(u8);

        MEMFILE_OPEN(&it->file, memfile->memblock, memfile->mode);
        MEMFILE_SEEK(&it->file, payload_start);

#ifndef NDEBUG
        ERROR_IF_AND_RETURN(MEMFILE_REMAIN_SIZE(&it->file) < sizeof(u8), ERR_CORRUPTED, NULL);
#endif

        char marker = MEMFILE_READ_BYTE(&it->file);

        sub_type_e sub_type = abstract_get_container_subtype(marker);
        ERROR_IF_AND_RETURN(sub_type != CONTAINER_OBJECT, ERR_ILLEGALOP,
                              "object begin marker ('{') or abstract derived type marker for 'map' not found");

        it->type = (map_type_e) marker;

        it->content_begin += sizeof(u8);

        obj_it_rewind(it);

        return true;
}

bool internal_obj_it_copy(obj_it *dst, obj_it *src)
{
        internal_obj_it_create(dst, &src->file, src->begin);
        return true;
}

bool internal_obj_it_clone(obj_it *dst, obj_it *src)
{
        MEMFILE_CLONE(&dst->file, &src->file);
        dst->content_begin = src->content_begin;
        dst->begin = src->begin;
        dst->mod_size = src->mod_size;
        dst->pos = src->pos;
        dst->eof = src->eof;
        dst->type = src->type;
        dst->last_off = src->last_off;
        dst->field.key.name_len = src->field.key.name_len;
        dst->field.key.name = src->field.key.name;
        dst->field.key.start = src->field.key.start;
        dst->field.value.start = src->field.value.start;
        internal_field_clone(&dst->field.value.data, &src->field.value.data);
        internal_prop_create(&dst->prop, dst);
        return true;
}

bool obj_it_rewind(obj_it *it)
{
        ERROR_IF_AND_RETURN(it->content_begin >= MEMFILE_SIZE(&it->file), ERR_OUTOFBOUNDS, NULL);
        it->last_off = it->content_begin;
        it->pos = 0;
        return MEMFILE_SEEK(&it->file, it->content_begin);
}

prop *obj_it_next(obj_it *it)
{
        bool is_empty_slot;
        offset_t last_off = MEMFILE_TELL(&it->file);
        if (internal_object_it_next(&is_empty_slot, &it->eof, it)) {
                it->last_off = last_off;
                internal_prop_create(&it->prop, it);
                it->pos++;
                return &it->prop;
        } else {
                /** skip remaining zeros until end of array is reached */
                if (!it->eof) {
                        ERROR_IF_AND_RETURN(!is_empty_slot, ERR_CORRUPTED, NULL);

                        while (*MEMFILE_PEEK(&it->file, 1) == 0) {
                                MEMFILE_SKIP(&it->file, 1);
                        }
                }

                assert(*MEMFILE_PEEK(&it->file, sizeof(char)) == MOBJECT_END);
                return NULL;
        }
}

bool obj_it_has_next(obj_it *it)
{
        bool has_next = obj_it_next(it);
        obj_it_prev(it);
        return has_next;
}

u64 obj_it_length(obj_it *it)
{
        obj_it dup;
        internal_obj_it_clone(&dup, it);

        u64 num_elem = 0;
        while (obj_it_next(&dup)) {
                num_elem++;
        }
        return num_elem;
}

bool obj_it_prev(obj_it *it)
{
        if (it->last_off) {
                offset_t prev_off = it->last_off;
                it->pos--;
                MEMFILE_SEEK(&it->file, prev_off);
                return internal_object_it_refresh(NULL, NULL, it);
        } else {
                return false;
        }
}

void *internal_obj_it_memfile(obj_it *it)
{
        return MEMFILE_RAW_DATA(&it->file);
}

offset_t internal_obj_it_memfile_pos(obj_it *it)
{
        return MEMFILE_TELL(&it->file);
}

bool internal_obj_it_tell(offset_t *key_off, offset_t *value_off, obj_it *it)
{
        OPTIONAL_SET(key_off, it->field.key.start);
        OPTIONAL_SET(value_off, it->field.value.start);
        return true;
}

string_field internal_obj_it_prop_name(obj_it *it)
{
        string_field ret = NULL_STRING;
        if (LIKELY(it != NULL)) {
                ret.len = it->field.key.name_len;
                ret.str = it->field.key.name;
        }
        return ret;
}

static i64 _prop_remove(obj_it *it, field_e type)
{
        i64 prop_size = internal_prop_size(&it->file);
        string_field_nomarker_remove(&it->file);
        if (internal_field_remove(&it->file, type)) {
                internal_object_it_refresh(NULL, NULL, it);
                return prop_size;
        } else {
                return 0;
        }
}

bool internal_obj_it_remove(obj_it *it)
{
        field_e type;
        if (internal_obj_it_prop_type(&type, it)) {
                offset_t prop_off = it->last_off;
                MEMFILE_SEEK(&it->file, prop_off);
                it->mod_size -= _prop_remove(it, type);
                return true;
        } else {
                ERROR(ERR_ILLEGALSTATE, NULL);
                return false;
        }
}

bool internal_obj_it_prop_type(field_e *type, obj_it *it)
{
        return internal_field_field_type(type, &it->field.value.data);
}

bool obj_it_is_multimap(obj_it *it)
{
        abstract_type_class_e type_class = abstract_map_derivable_to_class(it->type);
        return abstract_is_multimap(type_class);
}

bool obj_it_is_sorted(obj_it *it)
{
        abstract_type_class_e type_class = abstract_map_derivable_to_class(it->type);
        return abstract_is_sorted(type_class);
}

void obj_it_update_type(obj_it *it, map_type_e derivation)
{
        MEMFILE_SAVE_POSITION(&it->file);
        MEMFILE_SEEK(&it->file, it->begin);

        derived_e derive_marker = abstract_derive_map_to(derivation);
        abstract_write_derived_type(&it->file, derive_marker);

        MEMFILE_RESTORE_POSITION(&it->file);
}

bool internal_obj_it_insert_begin(insert *in, obj_it *it)
{
        return internal_insert_create_for_object(in, it);
}

void internal_obj_it_insert_end(insert *in)
{
        switch (in->context_type) {
                case OBJECT: internal_obj_it_adjust(in->context.object); break;
                case ARRAY:  internal_arr_it_adjust(in->context.array); break;
                case COLUMN: /* nothing to do */ break;
                default:
                        PANIC(ERR_NOTIMPLEMENTED);
        }
}

void internal_obj_it_adjust(obj_it *it)
{
        MEMFILE_SEEK_FROM_HERE(&it->file, it->mod_size);
        it->mod_size = 0;
}

bool internal_obj_it_fast_forward(obj_it *it)
{
        while (obj_it_next(it)) {}

        assert(*MEMFILE_PEEK(&it->file, sizeof(u8)) == MOBJECT_END);
        MEMFILE_SKIP(&it->file, sizeof(u8));
        return true;
}

bool internal_obj_it_update_name(obj_it *it, const char *key)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(key)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_u8(obj_it *it, u8 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_u16(obj_it *it, u16 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_u32(obj_it *it, u32 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_u64(obj_it *it, u64 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_i8(obj_it *it, i8 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_i16(obj_it *it, i16 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_i32(obj_it *it, i32 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_i64(obj_it *it, i64 value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_float(obj_it *it, float value)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_true(obj_it *it)
{
        // TODO: Implement P1
        UNUSED(it)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_false(obj_it *it)
{
        // TODO: Implement P1
        UNUSED(it)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_null(obj_it *it)
{
        // TODO: Implement P1
        UNUSED(it)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_string(obj_it *it, const char *str)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(str)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_binary(obj_it *it, const void *value, size_t nbytes, const char *file_ext, const char *user_type)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(value)
        UNUSED(nbytes)
        UNUSED(file_ext)
        UNUSED(user_type)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

insert *internal_obj_it_update_array_begin(arr_state *state, obj_it *it)
{
        // TODO: Implement P1
        UNUSED(state)
        UNUSED(it)
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool internal_obj_it_update_array_end(arr_state *state)
{
        // TODO: Implement P1
        UNUSED(state)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

insert *internal_obj_it_update_column_begin(col_state *state, obj_it *it)
{
        // TODO: Implement P1
        UNUSED(state)
        UNUSED(it)
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool internal_obj_it_update_column_end(col_state *state)
{
        // TODO: Implement P1
        UNUSED(state)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

insert *internal_obj_it_update_object_begin(obj_state *state, obj_it *it)
{
        // TODO: Implement P1
        UNUSED(state)
        UNUSED(it)
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool internal_obj_it_update_object_end(obj_state *state)
{
        // TODO: Implement P1
        UNUSED(state)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_from_carbon(obj_it *it, const rec *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_from_array(obj_it *it, const obj_it *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_from_object(obj_it *it, const obj_it *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool internal_obj_it_update_from_column(obj_it *it, const col_it *src)
{
        // TODO: Implement P1
        UNUSED(it)
        UNUSED(src)
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/patch.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/find.h>

void patch(arr_it *it, rec *doc)
{
        offset_t payload_start = INTERNAL_PAYLOAD_AFTER_HEADER(doc);
        internal_arr_it_create(it, &doc->file, payload_start);
        INTERNAL_ARR_IT_SET_MODE(it, READ_WRITE);
}

void patch_find_begin(find *out, const char *dot, rec *doc)
{
        doc->file.mode = READ_WRITE;
        find_from_string(out, dot, doc);
}

void patch_find_end(find *find)
{
        find->doc->file.mode = READ_ONLY;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/hexdump.h>
#include <karbonit/carbon/pindex.h>
#include <karbonit/carbon/key.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/string-field.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/commit.h>

// ---------------------------------------------------------------------------------------------------------------------
//  config
// ---------------------------------------------------------------------------------------------------------------------

#define pindex_CAPACITY 1024

#define PATH_MARKER_PROP_NODE 'P'
#define PATH_MARKER_ARRAY_NODE 'a'
#define PATH_MARKER_COLUMN_NODE 'A'

// ---------------------------------------------------------------------------------------------------------------------
//  types
// ---------------------------------------------------------------------------------------------------------------------

struct pindex_node {
        pindex_node_e type;

        union {
                u64 pos;
                struct {
                        const char *name;
                        u64 name_len;
                        offset_t offset;
                } key;
        } entry;

        field_e field_type;
        offset_t field_offset;

        vec ofType(struct pindex_node) sub_entries;
};

// ---------------------------------------------------------------------------------------------------------------------
//  helper prototypes
// ---------------------------------------------------------------------------------------------------------------------

static void
array_to_str(str_buf *str, pindex *index, bool is_root, unsigned intent_level);

static void array_into_record(insert *ins, pindex *index, bool is_root);

static void prop_to_str(str_buf *str, pindex *index, unsigned intent_level);

static void prop_into_record(insert *ins, pindex *index);

static void column_to_str(str_buf *str, pindex *index, unsigned intent_level);

static void column_into_record(insert *ins, pindex *index);

static void object_build_index(struct pindex_node *parent, obj_it *elem_it);

static void array_build_index(struct pindex_node *parent, arr_it *elem_it);

static void node_flat(memfile *file, struct pindex_node *node);

// ---------------------------------------------------------------------------------------------------------------------
//  helper
// ---------------------------------------------------------------------------------------------------------------------

static void intent(str_buf *str, unsigned intent)
{
        str_buf_add_char(str, '\n');
        for (unsigned i = 0; i < intent; i++) {
                str_buf_add(str, "    ");
        }
}

static void pindex_node_init(struct pindex_node *node)
{
        ZERO_MEMORY(node, sizeof(struct pindex_node));
        vec_create(&node->sub_entries, sizeof(struct pindex_node), 10);
        node->type = PINDEX_ROOT;
}

static void pindex_node_drop(struct pindex_node *node)
{
        for (u32 i = 0; i < node->sub_entries.num_elems; i++) {
                struct pindex_node *sub = VEC_GET(&node->sub_entries, i, struct pindex_node);
                pindex_node_drop(sub);
        }
        vec_drop(&node->sub_entries);
}

static void pindex_node_new_array_element(struct pindex_node *node, u64 pos, offset_t value_off)
{
        pindex_node_init(node);
        node->type = PINDEX_ARRAY_INDEX;
        node->entry.pos = pos;
        node->field_offset = value_off;
}

static void pindex_node_new_column_element(struct pindex_node *node, u64 pos, offset_t value_off)
{
        pindex_node_init(node);
        node->type = PINDEX_COLUMN_INDEX;
        node->entry.pos = pos;
        node->field_offset = value_off;
}

static void pindex_node_new_object_prop(struct pindex_node *node, offset_t key_off, const char *name,
                                            u64 name_len, offset_t value_off)
{
        pindex_node_init(node);
        node->type = PINDEX_PROP_KEY;
        node->entry.key.offset = key_off;
        node->entry.key.name = name;
        node->entry.key.name_len = name_len;
        node->field_offset = value_off;
}

static void pindex_node_set_field_type(struct pindex_node *node, field_e field_type)
{
        node->field_type = field_type;
}

static struct pindex_node *
pindex_node_add_array_elem(struct pindex_node *parent, u64 pos, offset_t value_off)
{
        /** For elements in array, the type marker (e.g., [c]) is contained. That is needed since the element might
         * be a container */
        struct pindex_node *sub = VEC_NEW_AND_GET(&parent->sub_entries, struct pindex_node);
        pindex_node_new_array_element(sub, pos, value_off);
        return sub;
}

static struct pindex_node *
pindex_node_add_column_elem(struct pindex_node *parent, u64 pos, offset_t value_off)
{
        /** For elements in column, there is no type marker since no value is allowed to be a container */
        struct pindex_node *sub = VEC_NEW_AND_GET(&parent->sub_entries, struct pindex_node);
        pindex_node_new_column_element(sub, pos, value_off);
        return sub;
}

static struct pindex_node *pindex_node_add_key_elem(struct pindex_node *parent, offset_t key_off,
                                                            const char *name, u64 name_len, offset_t value_off)
{
        struct pindex_node *sub = VEC_NEW_AND_GET(&parent->sub_entries, struct pindex_node);
        pindex_node_new_object_prop(sub, key_off, name, name_len, value_off);
        return sub;
}

//static void pindex_node_print_level(FILE *file, struct pindex_node *node, unsigned level)
//{
//        for (unsigned i = 0; i < level; i++) {
//                fprintf(file, " ");
//        }
//        if (node->type == PINDEX_ROOT) {
//                fprintf(file, "root");
//        } else if (node->type == PINDEX_ARRAY_INDEX) {
//                fprintf(file, "array_idx(%"PRIu64"), ", node->entry.pos);
//        } else if (node->type == PINDEX_COLUMN_INDEX) {
//                fprintf(file, "column_idx(%"PRIu64"), ", node->entry.pos);
//        } else {
//                fprintf(file, "key('%*.*s', offset: 0x%x), ", 0, (int) node->entry.key.name_len, node->entry.key.name,
//                        (unsigned) node->entry.key.offset);
//        }
//        if (node->type != PINDEX_ROOT) {
//                fprintf(file, "field(type: %s, offset: 0x%x)\n", field_str(node->field_type),
//                        (unsigned) node->field_offset);
//        } else {
//                fprintf(file, "\n");
//        }
//
//        for (u32 i = 0; i < node->sub_entries.num_elems; i++) {
//                struct pindex_node *sub = VEC_GET(&node->sub_entries, i, struct pindex_node);
//                pindex_node_print_level(file, sub, level + 1);
//        }
//}

static const void *
record_ref_read(key_e *rec_key_type, u64 *key_length, u64 *commit_hash, memfile *memfile)
{
        MEMFILE_SAVE_POSITION(memfile);
        MEMFILE_SEEK(memfile, 0);
        const void *ret = key_read(key_length, rec_key_type, memfile);
        u64 *hash = MEMFILE_READ_TYPE(memfile, u64);
        OPTIONAL_SET(commit_hash, *hash);
        MEMFILE_RESTORE_POSITION(memfile);
        return ret;
}

static void record_ref_create(memfile *memfile, rec *doc)
{
        key_e type;
        u64 commit_hash;
        rec_key_type(&type, doc);
        rec_commit_hash(&commit_hash, doc);

        /** write record key */
        MEMFILE_SEEK(memfile, 0);
        key_create(memfile, type);
        switch (type) {
                case KEY_NOKEY: {
                        /** nothing to do */
                }
                        break;
                case KEY_AUTOKEY:
                case KEY_UKEY: {
                        u64 key;
                        rec_key_unsigned_value(&key, doc);
                        MEMFILE_SEEK(memfile, 0);
                        key_write_unsigned(memfile, key);
                }
                        break;
                case KEY_IKEY: {
                        DECLARE_AND_INIT(i64, key)
                        rec_key_signed_value(&key, doc);
                        MEMFILE_SEEK(memfile, 0);
                        key_write_signed(memfile, key);
                }
                        break;
                case KEY_SKEY: {
                        u64 len;
                        const char *key = key_string_value(&len, doc);
                        MEMFILE_SEEK(memfile, 0);
                        key_update_string_wnchar(memfile, key, len);
                }
                        break;
                default: ERROR(ERR_TYPEMISMATCH, NULL);
        }

        /** write record version */
        MEMFILE_WRITE(memfile, &commit_hash, sizeof(u64));
}

static void array_traverse(struct pindex_node *parent, arr_it *it)
{
        u64 sub_elem_pos = 0;
        while (arr_it_next(it)) {
                offset_t sub_elem_off = internal_arr_it_tell(it);
                struct pindex_node *elem_node = pindex_node_add_array_elem(parent, sub_elem_pos, sub_elem_off);
                array_build_index(elem_node, it);

                sub_elem_pos++;
        }
}

static void column_traverse(struct pindex_node *parent, col_it *it)
{
        field_e column_type;
        field_e entry_type;
        u32 nvalues = COL_IT_VALUES_INFO(&column_type, it);

        for (u32 i = 0; i < nvalues; i++) {
                bool is_null = col_it_is_null(it, i);
                bool is_true = false;
                if (FIELD_IS_COLUMN_BOOL_OR_SUBTYPE(column_type)) {
                        is_true = COL_IT_BOOLEAN_VALUES(NULL, it)[i];
                }
                entry_type = field_column_entry_to_regular_type(column_type, is_null, is_true);
                offset_t sub_elem_off = col_it_tell(it, i);

                struct pindex_node *node = pindex_node_add_column_elem(parent, i, sub_elem_off);
                pindex_node_set_field_type(node, entry_type);
        }
}

static void object_traverse(struct pindex_node *parent, obj_it *it)
{
        while (obj_it_next(it)) {
                offset_t key_off = 0, value_off = 0;
                internal_obj_it_tell(&key_off, &value_off, it);
                string_field prop_key = internal_obj_it_prop_name(it);
                struct pindex_node *elem_node = pindex_node_add_key_elem(parent, key_off,
                                                                         prop_key.str, prop_key.len, value_off);
                object_build_index(elem_node, it);
        }
}

static void object_build_index(struct pindex_node *parent, obj_it *elem_it)
{
        field_e field_type = 0;;
        internal_obj_it_prop_type(&field_type, elem_it);
        pindex_node_set_field_type(parent, field_type);

        switch (field_type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        /** path ends here */
                        break;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                        col_it it;
                        ITEM_GET_COLUMN(&it, &(elem_it->prop.value));
                        column_traverse(parent, &it);

                }
                        break;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET: {
                        arr_it it;
                        ITEM_GET_ARRAY(&it, &(elem_it->prop.value));
                        array_traverse(parent, &it);
                }
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP: {
                        obj_it it;
                        ITEM_GET_OBJECT(&it, &(elem_it->prop.value));
                        object_traverse(parent, &it);
                }
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
}

static void array_build_index(struct pindex_node *parent, arr_it *elem_it)
{
        field_e field_type;
        arr_it_field_type(&field_type, elem_it);
        pindex_node_set_field_type(parent, field_type);

        switch (field_type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        /** path ends here */
                        break;
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET: {
                        col_it it;
                        ITEM_GET_COLUMN(&it, &elem_it->item);
                        column_traverse(parent, &it);
                }
                        break;
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET: {
                        arr_it it;
                        ITEM_GET_ARRAY(&it, &elem_it->item);
                        array_traverse(parent, &it);
                }
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP: {
                        obj_it it;
                        ITEM_GET_OBJECT(&it, &elem_it->item);
                        object_traverse(parent, &it);
                }
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
}

static void field_ref_write(memfile *file, struct pindex_node *node)
{
        MEMFILE_WRITE_BYTE(file, node->field_type);
        if (node->field_type != FIELD_NULL && node->field_type != FIELD_TRUE &&
            node->field_type != FIELD_FALSE) {
                /** only in case of field type that is not null, true, or false, there is more information behind
                 * the field offset */
                MEMFILE_WRITE_UINTVAR_STREAM(NULL, file, node->field_offset);
        }
}

static void container_contents_flat(memfile *file, struct pindex_node *node)
{
        MEMFILE_WRITE_UINTVAR_STREAM(NULL, file, node->sub_entries.num_elems);

        /** write position offsets */
        offset_t position_off_latest = MEMFILE_TELL(file);
        for (u32 i = 0; i < node->sub_entries.num_elems; i++) {
                MEMFILE_WRITE_UINTVAR_STREAM(NULL, file, 0);
        }

        for (u32 i = 0; i < node->sub_entries.num_elems; i++) {
                offset_t node_off = MEMFILE_TELL(file);
                struct pindex_node *sub = VEC_GET(&node->sub_entries, i, struct pindex_node);
                node_flat(file, sub);
                MEMFILE_SAVE_POSITION(file);
                MEMFILE_SEEK(file, position_off_latest);
                signed_offset_t shift = MEMFILE_UPDATE_UINTVAR_STREAM(file, node_off);
                position_off_latest = MEMFILE_TELL(file);
                MEMFILE_RESTORE_POSITION(file);
                MEMFILE_SEEK_FROM_HERE(file, shift);
        }
}

static void container_field_flat(memfile *file, struct pindex_node *node)
{
        switch (node->field_type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        /** any path will end with this kind of field, and therefore no subsequent elements exists */
                        assert(node->sub_entries.num_elems == 0);
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET:
                        /** each of these field types allows for further path traversals, and therefore at least one
                         * subsequent path element must exist */
                        container_contents_flat(file, node);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
}

static void prop_flat(memfile *file, struct pindex_node *node)
{
        MEMFILE_WRITE_BYTE(file, PATH_MARKER_PROP_NODE);
        field_ref_write(file, node);
        MEMFILE_WRITE_UINTVAR_STREAM(NULL, file, node->entry.key.offset);
        container_field_flat(file, node);
}

static void array_flat(memfile *file, struct pindex_node *node)
{
        MEMFILE_WRITE_BYTE(file, PATH_MARKER_ARRAY_NODE);
        field_ref_write(file, node);
        if (UNLIKELY(node->type == PINDEX_ROOT)) {
                container_contents_flat(file, node);
        } else {
                container_field_flat(file, node);
        }
}

MAYBE_UNUSED
static void node_into_record(insert *ins, pindex *index)
{
        u8 next = MEMFILE_PEEK_BYTE(&index->memfile);
        switch (next) {
                case PATH_MARKER_PROP_NODE:
                        prop_into_record(ins, index);
                        break;
                case PATH_MARKER_ARRAY_NODE:
                        array_into_record(ins, index, false);
                        break;
                case PATH_MARKER_COLUMN_NODE:
                        column_into_record(ins, index);
                        break;
                default: ERROR(ERR_CORRUPTED, NULL);
        }
}

static void node_to_str(str_buf *str, pindex *index, unsigned intent_level)
{
        u8 next = MEMFILE_PEEK_BYTE(&index->memfile);
        intent_level++;

        switch (next) {
                case PATH_MARKER_PROP_NODE:
                        prop_to_str(str, index, intent_level);
                        break;
                case PATH_MARKER_ARRAY_NODE:
                        array_to_str(str, index, false, intent_level);
                        break;
                case PATH_MARKER_COLUMN_NODE:
                        column_to_str(str, index, intent_level);
                        break;
                default: ERROR(ERR_CORRUPTED, NULL);
        }
}

static u8 field_ref_into_record(insert *ins, pindex *index, bool is_root)
{
        u8 field_type = MEMFILE_READ_BYTE(&index->memfile);

        if (is_root) {
                insert_prop_null(ins, "container");
        } else {
                insert_prop_string(ins, "container", field_str(field_type));
        }


        if (field_type != FIELD_NULL && field_type != FIELD_TRUE &&
            field_type != FIELD_FALSE) {
                /** only in case of field type that is not null, true, or false, there is more information behind
                 * the field offset */
                u64 field_offset = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
                if (is_root) {
                        insert_prop_null(ins, "offset");
                } else {
                        str_buf str;
                        str_buf_create(&str);
                        str_buf_add_u64_as_hex_0x_prefix_compact(&str, field_offset);
                        insert_prop_string(ins, "offset", str_buf_cstr(&str));
                        str_buf_drop(&str);
                }
        } else {
                insert_prop_null(ins, "offset");
        }
        return field_type;
}

static u8 field_ref_to_str(str_buf *str, pindex *index)
{
        u8 field_type = MEMFILE_READ_BYTE(&index->memfile);

        str_buf_add_char(str, '[');
        str_buf_add_char(str, field_type);
        str_buf_add_char(str, ']');

        if (field_type != FIELD_NULL && field_type != FIELD_TRUE &&
            field_type != FIELD_FALSE) {
                /** only in case of field type that is not null, true, or false, there is more information behind
                 * the field offset */
                u64 field_offset = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
                str_buf_add_char(str, '(');
                str_buf_add_u64_as_hex_0x_prefix_compact(str, field_offset);
                str_buf_add_char(str, ')');
        }

        return field_type;
}

static void column_to_str(str_buf *str, pindex *index, unsigned intent_level)
{
        intent(str, intent_level);
        u8 marker = MEMFILE_READ_BYTE(&index->memfile);
        str_buf_add_char(str, '[');
        str_buf_add_char(str, marker);
        str_buf_add_char(str, ']');

        field_ref_to_str(str, index);
}

static u8 _insert_field_ref(insert *ins, pindex *index, bool is_root)
{
        obj_state object;
        insert *oins = insert_prop_object_begin(&object, ins, "record-reference", 1024);
        u8 ret = field_ref_into_record(oins, index, is_root);
        insert_prop_object_end(&object);
        return ret;
}

MAYBE_UNUSED
static void column_into_record(insert *ins, pindex *index)
{
        MEMFILE_SKIP_BYTE(&index->memfile);
        insert_prop_string(ins, "type", "column");
        _insert_field_ref(ins, index, false);
}

static void container_contents_into_record(insert *ins, pindex *index)
{
        u64 num_elems = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
        insert_prop_unsigned(ins, "element-count", num_elems);

        arr_state array;
        insert *ains = insert_prop_array_begin(&array, ins, "element-offsets", 1024);

        str_buf str;
        str_buf_create(&str);
        for (u32 i = 0; i < num_elems; i++) {
                u64 pos_offs = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
                str_buf_clear(&str);
                str_buf_add_u64_as_hex_0x_prefix_compact(&str, pos_offs);
                insert_string(ains, str_buf_cstr(&str));
        }
        str_buf_drop(&str);

        insert_prop_array_end(&array);

        ains = insert_prop_array_begin(&array, ins, "elements", 1024);
        UNUSED(ains)
        for (u32 i = 0; i < num_elems; i++) {
                obj_state node_obj;
                insert *node_obj_ins = insert_object_begin(&node_obj, ains, 1024);
                node_into_record(node_obj_ins, index);
                insert_object_end(&node_obj);
        }
        insert_prop_array_end(&array);

}

static void
container_contents_to_str(str_buf *str, pindex *index, unsigned intent_level)
{
        u64 num_elems = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
        str_buf_add_char(str, '(');
        str_buf_add_u64(str, num_elems);
        str_buf_add_char(str, ')');

        for (u32 i = 0; i < num_elems; i++) {
                u64 pos_offs = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
                str_buf_add_char(str, '(');
                str_buf_add_u64_as_hex_0x_prefix_compact(str, pos_offs);
                str_buf_add_char(str, ')');
        }

        for (u32 i = 0; i < num_elems; i++) {
                node_to_str(str, index, intent_level);
        }
}

static void
container_to_str(str_buf *str, pindex *index, u8 field_type, unsigned intent_level)
{
        switch (field_type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        /** nothing to do */
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                        /** subsequent path elements to be printed */
                        container_contents_to_str(str, index, ++intent_level);
                }
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
}

static void container_into_record(insert *ins, pindex *index, u8 field_type)
{
        switch (field_type) {
                case FIELD_NULL:
                case FIELD_TRUE:
                case FIELD_FALSE:
                case FIELD_STRING:
                case FIELD_NUMBER_U8:
                case FIELD_NUMBER_U16:
                case FIELD_NUMBER_U32:
                case FIELD_NUMBER_U64:
                case FIELD_NUMBER_I8:
                case FIELD_NUMBER_I16:
                case FIELD_NUMBER_I32:
                case FIELD_NUMBER_I64:
                case FIELD_NUMBER_FLOAT:
                case FIELD_BINARY:
                case FIELD_BINARY_CUSTOM:
                        /** nothing to do */
                        break;
                case FIELD_OBJECT_UNSORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_SORTED_MULTIMAP:
                case FIELD_DERIVED_OBJECT_UNSORTED_MAP:
                case FIELD_DERIVED_OBJECT_SORTED_MAP:
                case FIELD_ARRAY_UNSORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_SORTED_MULTISET:
                case FIELD_DERIVED_ARRAY_UNSORTED_SET:
                case FIELD_DERIVED_ARRAY_SORTED_SET:
                case FIELD_COLUMN_U8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U8_SORTED_SET:
                case FIELD_COLUMN_U16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U16_SORTED_SET:
                case FIELD_COLUMN_U32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U32_SORTED_SET:
                case FIELD_COLUMN_U64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_U64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_U64_SORTED_SET:
                case FIELD_COLUMN_I8_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I8_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I8_SORTED_SET:
                case FIELD_COLUMN_I16_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I16_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I16_SORTED_SET:
                case FIELD_COLUMN_I32_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I32_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I32_SORTED_SET:
                case FIELD_COLUMN_I64_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_I64_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_I64_SORTED_SET:
                case FIELD_COLUMN_FLOAT_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_FLOAT_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_FLOAT_SORTED_SET:
                case FIELD_COLUMN_BOOLEAN_UNSORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_MULTISET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_UNSORTED_SET:
                case FIELD_DERIVED_COLUMN_BOOLEAN_SORTED_SET: {
                        /** subsequent path elements to be printed */
                        container_contents_into_record(ins, index);
                }
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
}

static void prop_to_str(str_buf *str, pindex *index, unsigned intent_level)
{
        intent(str, intent_level++);

        u8 marker = MEMFILE_READ_BYTE(&index->memfile);
        str_buf_add_char(str, '[');
        str_buf_add_char(str, marker);
        str_buf_add_char(str, ']');

        u8 field_type = field_ref_to_str(str, index);

        u64 key_offset = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);

        str_buf_add_char(str, '(');
        str_buf_add_u64_as_hex_0x_prefix_compact(str, key_offset);
        str_buf_add_char(str, ')');

        container_to_str(str, index, field_type, intent_level);
}

MAYBE_UNUSED
static void prop_into_record(insert *ins, pindex *index)
{
        MEMFILE_SKIP_BYTE(&index->memfile);
        insert_prop_string(ins, "type", "key");
        u8 field_type = _insert_field_ref(ins, index, false);

        str_buf str;
        str_buf_create(&str);

        u64 key_offset = MEMFILE_READ_UINTVAR_STREAM(NULL, &index->memfile);
        str_buf_add_u64_as_hex_0x_prefix_compact(&str, key_offset);
        insert_prop_string(ins, "key", str_buf_cstr(&str));
        str_buf_drop(&str);

        container_into_record(ins, index, field_type);
}

static void array_into_record(insert *ins, pindex *index, bool is_root)
{
        MEMFILE_SKIP_BYTE(&index->memfile);
        u8 field_type;

        insert_prop_string(ins, "parent", is_root ? "record" : "array");
        field_type = _insert_field_ref(ins, index, is_root);

        obj_state object;
        insert *oins = insert_prop_object_begin(&object, ins, "nodes", 1024);
        if (UNLIKELY(is_root)) {
                container_contents_into_record(oins, index);
        } else {
                container_into_record(oins, index, field_type);
        }
        insert_prop_object_end(&object);
}

static void
array_to_str(str_buf *str, pindex *index, bool is_root, unsigned intent_level)
{
        intent(str, intent_level++);

        u8 marker = MEMFILE_READ_BYTE(&index->memfile);
        str_buf_add_char(str, '[');
        str_buf_add_char(str, marker);
        str_buf_add_char(str, ']');

        u8 field_type = field_ref_to_str(str, index);

        if (UNLIKELY(is_root)) {
                container_contents_to_str(str, index, intent_level);
        } else {
                container_to_str(str, index, field_type, intent_level);
        }
}

static void column_flat(memfile *file, struct pindex_node *node)
{
        MEMFILE_WRITE_BYTE(file, PATH_MARKER_COLUMN_NODE);
        field_ref_write(file, node);
        assert(node->sub_entries.num_elems == 0);
}

static void node_flat(memfile *file, struct pindex_node *node)
{
        switch (node->type) {
                case PINDEX_PROP_KEY:
                        prop_flat(file, node);
                        break;
                case PINDEX_ARRAY_INDEX:
                        array_flat(file, node);
                        break;
                case PINDEX_COLUMN_INDEX:
                        column_flat(file, node);
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
                        return;
        }
}

static void index_flat(memfile *file, struct pindex_node *root_array)
{
        array_flat(file, root_array);
}

static void index_build(memfile *file, rec *doc)
{
        struct pindex_node root_array;

        /** init */
        pindex_node_init(&root_array);

        arr_it it;
        u64 array_pos = 0;
        rec_read(&it, doc);

        /** build index as tree structure */
        while (arr_it_next(&it)) {
                offset_t entry_offset = internal_arr_it_tell(&it);
                struct pindex_node *node = pindex_node_add_array_elem(&root_array, array_pos, entry_offset);
                array_build_index(node, &it);
                array_pos++;
        }

        index_flat(file, &root_array);
        MEMFILE_SHRINK(file);

        /** cleanup */
        pindex_node_drop(&root_array);
}

static void record_ref_to_str(str_buf *str, pindex *index)
{
        u8 rec_key_type = MEMFILE_READ_BYTE(&index->memfile);
        str_buf_add_char(str, '[');
        str_buf_add_char(str, rec_key_type);
        str_buf_add_char(str, ']');

        switch (rec_key_type) {
                case KEY_NOKEY:
                        /** nothing to do */
                        break;
                case KEY_AUTOKEY:
                case KEY_UKEY: {
                        u64 key = MEMFILE_READ_U64(&index->memfile);
                        str_buf_add_char(str, '[');
                        str_buf_add_u64(str, key);
                        str_buf_add_char(str, ']');
                }
                        break;
                case KEY_IKEY: {
                        i64 key = MEMFILE_READ_I64(&index->memfile);
                        str_buf_add_char(str, '[');;
                        str_buf_add_i64(str, key);
                        str_buf_add_char(str, ']');
                }
                        break;
                case KEY_SKEY: {
                        u64 key_len;
                        const char *key = string_field_read(&key_len, &index->memfile);
                        str_buf_add_char(str, '(');
                        str_buf_add_nchar(str, key, key_len);
                        str_buf_add_char(str, ')');
                }
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
        u64 commit_hash = MEMFILE_READ_U64(&index->memfile);
        str_buf_add_char(str, '[');
        str_buf_add_u64(str, commit_hash);
        str_buf_add_char(str, ']');
}

static void record_ref_to_record(insert *roins, pindex *index)
{
        char rec_key_type = MEMFILE_READ_BYTE(&index->memfile);
        insert_prop_string(roins, "key-type", key_type_str(rec_key_type));

        switch (rec_key_type) {
                case KEY_NOKEY:
                        /** nothing to do */
                        break;
                case KEY_AUTOKEY:
                case KEY_UKEY: {
                        u64 key = MEMFILE_READ_U64(&index->memfile);
                        insert_prop_unsigned(roins, "key-value", key);
                }
                        break;
                case KEY_IKEY: {
                        i64 key = MEMFILE_READ_I64(&index->memfile);
                        insert_prop_signed(roins, "key-value", key);
                }
                        break;
                case KEY_SKEY: {
                        u64 key_len;
                        const char *key = string_field_read(&key_len, &index->memfile);
                        insert_prop_nchar(roins, "key-value", key, key_len);
                }
                        break;
                default: ERROR(ERR_INTERNALERR, NULL);
        }
        u64 commit_hash = MEMFILE_READ_U64(&index->memfile);
        str_buf str;
        str_buf_create(&str);
        commit_to_str(&str, commit_hash);
        insert_prop_string(roins, "commit-hash", str_buf_cstr(&str));
        str_buf_drop(&str);
}

// ---------------------------------------------------------------------------------------------------------------------
//  construction and deconstruction
// ---------------------------------------------------------------------------------------------------------------------

bool pindex_create(pindex *index, rec *doc)
{
        MEMBLOCK_CREATE(&index->memblock, pindex_CAPACITY);
        MEMFILE_OPEN(&index->memfile, index->memblock, READ_WRITE);
        record_ref_create(&index->memfile, doc);
        index_build(&index->memfile, doc);
        return true;
}

bool pindex_drop(pindex *index)
{
        UNUSED(index)
        return false;
}

// ---------------------------------------------------------------------------------------------------------------------
//  index data access and meta information
// ---------------------------------------------------------------------------------------------------------------------

const void *pindex_raw_data(u64 *size, pindex *index)
{
        if (size && index) {
                const char *raw = MEMBLOCK_RAW_DATA(index->memfile.memblock);
                MEMBLOCK_SIZE(size, index->memfile.memblock);
                return raw;
        } else {
                return NULL;
        }
}

bool pindex_commit_hash(u64 *commit_hash, pindex *index)
{
        record_ref_read(NULL, NULL, commit_hash, &index->memfile);
        return true;
}

bool pindex_key_type(key_e *rec_key_type, pindex *index)
{
        record_ref_read(rec_key_type, NULL, NULL, &index->memfile);
        return true;
}

bool pindex_key_unsigned_value(u64 *key, pindex *index)
{
        key_e rec_key_type;
        u64 ret = *(u64 *) record_ref_read(&rec_key_type, NULL, NULL, &index->memfile);
        ERROR_IF_AND_RETURN(rec_key_type != KEY_AUTOKEY && rec_key_type != KEY_UKEY, ERR_TYPEMISMATCH, NULL);
        *key = ret;
        return true;
}

bool pindex_key_signed_value(i64 *key, pindex *index)
{
        key_e rec_key_type;
        i64 ret = *(i64 *) record_ref_read(&rec_key_type, NULL, NULL, &index->memfile);
        ERROR_IF_AND_RETURN(rec_key_type != KEY_IKEY, ERR_TYPEMISMATCH, NULL);
        *key = ret;
        return true;
}

const char *pindex_key_string_value(u64 *str_len, pindex *index)
{
        if (str_len && index) {
                key_e rec_key_type;
                const char *ret = (const char *) record_ref_read(&rec_key_type, str_len, NULL, &index->memfile);
                ERROR_IF_AND_RETURN(rec_key_type != KEY_SKEY, ERR_TYPEMISMATCH, NULL);
                return ret;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool pindex_indexes_doc(pindex *index, rec *doc)
{
        u64 index_hash = 0, doc_hash = 0;
        pindex_commit_hash(&index_hash, index);
        rec_commit_hash(&doc_hash, doc);
        if (LIKELY(index_hash == doc_hash)) {
                key_e index_key_type, doc_key_type;
                pindex_key_type(&index_key_type, index);
                rec_key_type(&doc_key_type, doc);
                if (LIKELY(index_key_type == doc_key_type)) {
                        switch (index_key_type) {
                                case KEY_NOKEY:
                                        return true;
                                case KEY_AUTOKEY:
                                case KEY_UKEY: {
                                        u64 index_key, doc_key;
                                        pindex_key_unsigned_value(&index_key, index);
                                        rec_key_unsigned_value(&doc_key, doc);
                                        return index_key == doc_key;
                                }
                                case KEY_IKEY: {
                                        i64 index_key, doc_key;
                                        pindex_key_signed_value(&index_key, index);
                                        rec_key_signed_value(&doc_key, doc);
                                        return index_key == doc_key;
                                }
                                case KEY_SKEY: {
                                        u64 index_key_len, doc_key_len;
                                        const char *index_key = pindex_key_string_value(&index_key_len,
                                                                                                   index);
                                        const char *doc_key = key_string_value(&doc_key_len, doc);
                                        return (index_key_len == doc_key_len) && (strcmp(index_key, doc_key) == 0);
                                }
                                default:
                                        return ERROR(ERR_TYPEMISMATCH, NULL);
                        }
                } else {
                        return false;
                }
        } else {
                return false;
        }
}

// ---------------------------------------------------------------------------------------------------------------------
//  index access and type information
// ---------------------------------------------------------------------------------------------------------------------

bool pindex_it_open(pindex_it *it, pindex *index,
                               rec *doc)
{
        if (pindex_indexes_doc(index, doc)) {
                ZERO_MEMORY(it, sizeof(pindex_it));
                MEMFILE_OPEN(&it->memfile, index->memfile.memblock, READ_ONLY);
                it->doc = doc;
                it->container = ARRAY;
                return true;
        } else {
                return ERROR(ERR_NOTINDEXED, NULL);
        }
}

// ---------------------------------------------------------------------------------------------------------------------
//  diagnostics
// ---------------------------------------------------------------------------------------------------------------------

bool pindex_hexdump(FILE *file, pindex *index)
{
        return MEMFILE_HEXDUMP_PRINTF(file, &index->memfile);
}

void pindex_to_record(rec *doc, pindex *index)
{
        rec_new context;
        obj_state object;

        MEMFILE_SEEK_TO_START(&index->memfile);

        insert *ins = rec_create_begin(&context, doc, KEY_NOKEY, OPTIMIZE);
        insert *oins = insert_object_begin(&object, ins, 1024);

        {
                obj_state ref_object;
                insert *roins = insert_prop_object_begin(&ref_object, oins,
                                                                                  "record-association", 1024);
                record_ref_to_record(roins, index);
                insert_prop_object_end(&ref_object);
        }
        {
                obj_state root_object;
                insert *roins = insert_prop_object_begin(&root_object, oins, "index", 1024);
                array_into_record(roins, index, true);
                insert_prop_object_end(&root_object);
        }

        insert_object_end(&object);
        rec_create_end(&context);
}

const char *pindex_to_str(str_buf *str, pindex *index)
{
        MEMFILE_SEEK_TO_START(&index->memfile);
        record_ref_to_str(str, index);
        array_to_str(str, index, true, 0);
        return str_buf_cstr(str);
}

bool pindex_print(FILE *file, pindex *index)
{
        str_buf str;
        str_buf_create(&str);
        MEMFILE_SAVE_POSITION(&index->memfile);
        MEMFILE_SEEK_TO_START(&index->memfile);
        fprintf(file, "%s", pindex_to_str(&str, index));
        MEMFILE_RESTORE_POSITION(&index->memfile);
        str_buf_drop(&str);
        return true;
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/prop.h>
#include <karbonit/carbon/string-field.h>
#include <karbonit/carbon/field.h>
#include <karbonit/carbon/obj-it.h>

bool internal_prop_create(prop *dst, obj_it *parent)
{
        dst->parent = parent;
        dst->idx = parent->pos;
        dst->key.str = parent->field.key.name;
        dst->key.len = parent->field.key.name_len;
        internal_item_create_from_object(&dst->value, parent);
        return true;
}

u64 internal_prop_size(memfile *file)
{
        offset_t prop_start = MEMFILE_SAVE_POSITION(file);
        string_field_nomarker_skip(file);
        carbon_field_skip(file);
        offset_t prop_end = MEMFILE_TELL(file);
        MEMFILE_RESTORE_POSITION(file);
        return prop_end - prop_start;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/rec.h>
#include <karbonit/carbon/revise.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/dot.h>
#include <karbonit/carbon/find.h>
#include <karbonit/carbon/key.h>
#include <karbonit/carbon/commit.h>
#include <karbonit/carbon/obj-it.h>

static bool internal_pack_array(arr_it *it);

static bool internal_pack_object(obj_it *it);

static bool internal_pack_column(col_it *it);

static bool carbon_header_rev_inc(rec *doc);

// ---------------------------------------------------------------------------------------------------------------------
void revise_begin(rev *context, rec *revised, rec *original)
{
        context->original = original;
        context->revised = revised;
        rec_clone(context->revised, context->original);
}

bool revise_commit_update(rec *doc)
{
        assert(doc);
        return carbon_header_rev_inc(doc);
}

static void key_unsigned_set(rec *doc, u64 key)
{
        assert(doc);
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);

        key_write_unsigned(&doc->file, key);

        MEMFILE_RESTORE_POSITION(&doc->file);
}

static void key_signed_set(rec *doc, i64 key)
{
        assert(doc);
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);

        key_write_signed(&doc->file, key);

        MEMFILE_RESTORE_POSITION(&doc->file);
}

static void key_string_set(rec *doc, const char *key)
{
        assert(doc);
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);

        key_update_string(&doc->file, key);

        MEMFILE_RESTORE_POSITION(&doc->file);
}

bool revise_key_generate(unique_id_t *out, rev *context)
{
        key_e type;
        rec_key_type(&type, context->revised);
        if (type == KEY_AUTOKEY) {
                unique_id_t oid;
                unique_id_create(&oid);
                key_unsigned_set(context->revised, oid);
                OPTIONAL_SET(out, oid);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool revise_key_set_unsigned(rev *context, u64 key_value)
{
        key_e type;
        rec_key_type(&type, context->revised);
        if (type == KEY_UKEY) {
                key_unsigned_set(context->revised, key_value);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool revise_key_set_signed(rev *context, i64 key_value)
{
        key_e type;
        rec_key_type(&type, context->revised);
        if (type == KEY_IKEY) {
                key_signed_set(context->revised, key_value);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

bool revise_key_set_string(rev *context, const char *key_value)
{
        key_e type;
        rec_key_type(&type, context->revised);
        if (type == KEY_SKEY) {
                key_string_set(context->revised, key_value);
                return true;
        } else {
                return ERROR(ERR_TYPEMISMATCH, NULL);
        }
}

void revise_set_list_type(rev *context, list_type_e derivation)
{
        arr_it it;
        revise_iterator_open(&it, context);

        MEMFILE_SEEK_FROM_HERE(&it.file, -sizeof(u8));
        derived_e derive_marker = abstract_derive_list_to(LIST_ARRAY, derivation);
        abstract_write_derived_type(&it.file, derive_marker);
}

bool revise_iterator_open(arr_it *it, rev *context)
{
        offset_t payload_start = INTERNAL_PAYLOAD_AFTER_HEADER(context->revised);
        if (UNLIKELY(context->revised->file.mode != READ_WRITE)) {
                return ERROR(ERR_PERMISSIONS, "revise iterator on read-only record invoked");
        }
        return internal_arr_it_create(it, &context->revised->file, payload_start);
}

bool revise_find_begin(find *out, const char *dot, rev *context)
{
        struct dot path;
        dot_from_string(&path, dot);
        bool status = internal_find_exec(out, &path, context->revised);
        dot_drop(&path);
        return status;
}

bool revise_remove_one(const char *dot, rec *rev_doc, rec *doc)
{
        rev revise;
        revise_begin(&revise, rev_doc, doc);
        bool status = revise_remove(dot, &revise);
        revise_end(&revise);
        return status;
}

bool revise_remove(const char *path, rev *context)
{
        struct dot dot;
        dot_eval eval;
        bool result;

        if (dot_from_string(&dot, path)) {
                dot_eval_begin_mutable(&eval, &dot, context);

                if (eval.status != PATH_RESOLVED) {
                        result = false;
                } else {
                        switch (eval.result.container) {
                                case ARRAY: {
                                        arr_it *it = &eval.result.containers.array;
                                        result = internal_arr_it_remove(it);
                                }
                                        break;
                                case COLUMN: {
                                        col_it *it = &eval.result.containers.column.it;
                                        u32 elem_pos = eval.result.containers.column.elem_pos;
                                        result = col_it_remove(it, elem_pos);
                                }
                                        break;
                                default: ERROR(ERR_INTERNALERR, NULL);
                                        result = false;
                        }
                }

                dot_drop(&dot);
                return result;
        } else {
                ERROR(ERR_DOT_PATH_PARSERR, NULL);
                return false;
        }
}

bool revise_pack(rev *context)
{
        arr_it it;
        revise_iterator_open(&it, context);
        internal_pack_array(&it);
        return true;
}

bool revise_shrink(rev *context)
{
        arr_it it;
        revise_iterator_open(&it, context);
        internal_arr_it_fast_forward(&it);
        if (MEMFILE_REMAIN_SIZE(&it.file) > 0) {
                offset_t first_empty_slot = MEMFILE_TELL(&it.file);
                assert(MEMFILE_SIZE(&it.file) > first_empty_slot);
                offset_t shrink_size = MEMFILE_SIZE(&it.file) - first_empty_slot;
                MEMFILE_CUT(&it.file, shrink_size);
        }

        offset_t size;
        MEMBLOCK_SIZE(&size, it.file.memblock);
        return true;
}

const rec *revise_end(rev *context)
{
        revise_commit_update(context->revised);
        return context->revised;
}

bool revise_abort(rev *context)
{
        rec_drop(context->revised);
        return true;
}

static void optimize_column(col_it *column, memfile *file)
{
        internal_pack_column(column);
        MEMFILE_SEEK__UNSAFE(file, MEMFILE_TELL(&column->file));
}

static void optimize_array(arr_it *array, memfile *file)
{
        internal_pack_array(array);
        assert(*MEMFILE_PEEK(&array->file, sizeof(char)) == MARRAY_END);
        MEMFILE_SKIP(&array->file, sizeof(char));
        MEMFILE_SEEK__UNSAFE(file, MEMFILE_TELL(&array->file));
}

static void optimize_object(obj_it *object, memfile *file)
{
        internal_pack_object(object);
        assert(*MEMFILE_PEEK(&object->file, sizeof(char)) == MOBJECT_END);
        MEMFILE_SKIP(&object->file, sizeof(char));
        MEMFILE_SEEK__UNSAFE(file, MEMFILE_TELL(&object->file));
}

static bool internal_pack_array(arr_it *it)
{
        assert(it);

        /** shrink this array */
        {
                arr_it this_array;
                bool is_empty_slot, is_array_end;

                internal_arr_it_copy(&this_array, it);
                internal_array_skip_contents(&is_empty_slot, &is_array_end, &this_array);

                if (!is_array_end) {

                        ERROR_IF_AND_RETURN(!is_empty_slot, ERR_CORRUPTED, NULL);
                        offset_t first_empty_slot_offset = MEMFILE_TELL(&this_array.file);
                        char final;
                        while ((final = *MEMFILE_READ(&this_array.file, sizeof(char))) == 0) {}
                        assert(final == MARRAY_END);
                        offset_t last_empty_slot_offset = MEMFILE_TELL(&this_array.file) - sizeof(char);
                        MEMFILE_SEEK(&this_array.file, first_empty_slot_offset);
                        assert(last_empty_slot_offset > first_empty_slot_offset);

                        MEMFILE_INPLACE_REMOVE(&this_array.file,
                                               last_empty_slot_offset - first_empty_slot_offset);

                        final = *MEMFILE_READ(&this_array.file, sizeof(char));
                        assert(final == MARRAY_END);
                }
        }

        /** shrink contained containers */
        {
                item *item;
                while ((item = arr_it_next(it))) {
                        if (ITEM_IS_COLUMN(item)) {
                                col_it column;
                                ITEM_GET_COLUMN(&column, item);
                                optimize_column(&column, &it->file);
                        } else if (ITEM_IS_OBJECT(item)) {
                                obj_it object;
                                ITEM_GET_OBJECT(&object, item);
                                optimize_object(&object, &it->file);
                        } else if (ITEM_IS_ARRAY(item)) {
                                arr_it array;
                                ITEM_GET_ARRAY(&array, item);
                                optimize_array(&array, &it->file);
                        }
                }
        }

        assert(*MEMFILE_PEEK(&it->file, sizeof(char)) == MARRAY_END);

        return true;
}

static bool internal_pack_object(obj_it *it)
{
        assert(it);

        /** shrink this object */
        {
                obj_it this_object_it;
                bool is_empty_slot, is_object_end;

                internal_obj_it_copy(&this_object_it, it);
                internal_object_skip_contents(&is_empty_slot, &is_object_end, &this_object_it);

                if (!is_object_end) {

                        ERROR_IF_AND_RETURN(!is_empty_slot, ERR_CORRUPTED, NULL);
                        offset_t first_empty_slot_offset = MEMFILE_TELL(&this_object_it.file);
                        char final;
                        while ((final = *MEMFILE_READ(&this_object_it.file, sizeof(char))) == 0) {}
                        assert(final == MOBJECT_END);
                        offset_t last_empty_slot_offset = MEMFILE_TELL(&this_object_it.file) - sizeof(char);
                        MEMFILE_SEEK(&this_object_it.file, first_empty_slot_offset);
                        assert(last_empty_slot_offset > first_empty_slot_offset);

                        MEMFILE_INPLACE_REMOVE(&this_object_it.file,
                                               last_empty_slot_offset - first_empty_slot_offset);

                        final = *MEMFILE_READ(&this_object_it.file, sizeof(char));
                        assert(final == MOBJECT_END);
                }
        }

        /** shrink contained containers */
        {
                prop *prop;
                while ((prop = obj_it_next(it))) {
                        if (PROP_IS_COLUMN(prop)) {
                                col_it column;
                                PROP_GET_COLUMN(&column, prop);
                                optimize_column(&column, &it->file);
                        } else if (PROP_IS_OBJECT(prop)) {
                                obj_it object;
                                PROP_GET_OBJECT(&object, prop);
                                optimize_object(&object, &it->file);
                        } else if (PROP_IS_ARRAY(prop)) {
                                arr_it array;
                                PROP_GET_ARRAY(&array, prop);
                                optimize_array(&array, &it->file);
                        }
                }
        }

        assert(*MEMFILE_PEEK(&it->file, sizeof(char)) == MOBJECT_END);

        return true;
}

static bool internal_pack_column(col_it *it)
{
        assert(it);

        u32 free_space = (it->cap - it->num) * INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type);
        offset_t payload_start = internal_column_get_payload_off(it);
        u64 payload_size = it->num * INTERNAL_GET_TYPE_VALUE_SIZE(it->field_type);
        MEMFILE_SEEK(&it->file, payload_start);
        MEMFILE_SKIP(&it->file, payload_size);

        if (free_space > 0) {
                MEMFILE_INPLACE_REMOVE(&it->file, free_space);

                MEMFILE_SEEK(&it->file, it->header_begin);
                MEMFILE_SKIP_UINTVAR_STREAM(&it->file); // skip num of elements counter
                MEMFILE_UPDATE_UINTVAR_STREAM(&it->file,
                                              it->num); // update capacity counter to num elems

                MEMFILE_SKIP(&it->file, payload_size);

                return true;
        } else {
                return false;
        }
}

static bool carbon_header_rev_inc(rec *doc)
{
        assert(doc);

        key_e rec_key_type;
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);
        key_read(NULL, &rec_key_type, &doc->file);
        if (rec_has_key(rec_key_type)) {
                u64 raw_data_len = 0;
                const void *raw_data = rec_raw_data(&raw_data_len, doc);
                commit_update(&doc->file, raw_data, raw_data_len);
        }
        MEMFILE_RESTORE_POSITION(&doc->file);

        return true;
}/**
 * rewrite - replace a field by another field
 *
 * Copyright 2020 Marcus Pinnecke
 */

#include <karbonit/carbon/rewrite.h>
#include <karbonit/carbon/field.h>

/*!
 * \brief Replaces the field in <code>dst</code> by the field in <code>src</code>
 *
 * @param dst memory file that is positioned to a field marker
 * @param src memory file that is positioned to a field marker
 * @return <code>TRUE</code> is case of success, and <code>FALSE</code> otherwise
 */
bool rewrite_field(memfile *dst, memfile *src)
{
        u64 dst_start, src_start, dst_end, src_end, dst_span, src_span;

        MEMFILE_SAVE_POSITION(dst);
        MEMFILE_SAVE_POSITION(src);

        dst_start = MEMFILE_TELL(dst);
        src_start = MEMFILE_TELL(src);

        carbon_field_skip(dst);
        carbon_field_skip(src);

        dst_end = MEMFILE_TELL(dst);
        src_end = MEMFILE_TELL(src);

        MEMFILE_RESTORE_POSITION(dst);
        MEMFILE_RESTORE_POSITION(src);

        dst_span = dst_end - dst_start;
        src_span = src_end - src_start;

        if (src_span <= dst_span) { /* new field fit into space of original field */
                MEMFILE_WRITE(dst, MEMFILE_PEEK__FAST(src), src_span);
                u64 num_obsolete = dst_end - MEMFILE_TELL(dst);
                MEMFILE_INPLACE_REMOVE(dst, num_obsolete);
                return true;
        } else { /* new field requires more space that occupied by original field */
                return false;
        }
}

/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/uintvar/stream.h>
#include <karbonit/carbon/mime.h>
#include <karbonit/carbon/field.h>
#include <karbonit/carbon/string-field.h>

static void write_payload(memfile *file, const char *string, size_t str_len)
{
        MEMFILE_WRITE_UINTVAR_STREAM(NULL, file, str_len);
        MEMFILE_ENSURE_SPACE(file, str_len);
        MEMFILE_WRITE(file, string, str_len);
}

bool string_field_nomarker_write(memfile *file, const char *string)
{
        return string_field_nomarker_nchar_write(file, string, strlen(string));
}

bool string_field_nomarker_nchar_write(memfile *file, const char *string, u64 str_len)
{
        write_payload(file, string, str_len);
        return true;
}

bool string_field_nomarker_remove(memfile *file)
{
        u8 len_nbytes;
        u64 str_len = MEMFILE_READ_UINTVAR_STREAM(&len_nbytes, file);
        MEMFILE_SKIP(file, -len_nbytes);
        MEMFILE_INPLACE_REMOVE(file, len_nbytes + str_len);
        return true;
}

bool string_field_remove(memfile *file)
{
        u8 marker = *MEMFILE_READ_TYPE(file, u8);
        if (LIKELY(marker == FIELD_STRING)) {
                MEMFILE_INPLACE_REMOVE(file, sizeof(u8));
                return string_field_nomarker_remove(file);
        } else {
                return ERROR(ERR_MARKERMAPPING, NULL);
        }
}

bool string_field_write(memfile *file, const char *string)
{
        return string_field_nchar_write(file, string, strlen(string));
}

bool string_field_nchar_write(memfile *file, const char *string, u64 str_len)
{
        MEMFILE_ENSURE_SPACE(file, sizeof(media_type));
        mime_write(file, FIELD_STRING);
        string_field_nomarker_nchar_write(file, string, str_len);
        return true;
}

bool string_field_update(memfile *file, const char *string)
{
        return string_field_update_wnchar(file, string, strlen(string));
}

bool string_field_update_wnchar(memfile *file, const char *string, size_t str_len)
{
        u8 marker = *MEMFILE_READ_TYPE(file, u8);
        if (LIKELY(marker == FIELD_STRING)) {
                offset_t payload_start = MEMFILE_TELL(file);
                u32 old_len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
                MEMFILE_SKIP(file, old_len);
                offset_t diff = MEMFILE_TELL(file) - payload_start;
                MEMFILE_SEEK(file, payload_start);
                MEMFILE_INPLACE_REMOVE(file, diff);

                write_payload(file, string, str_len);
                return true;
        } else {
                return ERROR(ERR_MARKERMAPPING, NULL);
        }
}

bool string_field_skip(memfile *file)
{
        return string_field_read(NULL, file);
}

bool string_field_nomarker_skip(memfile *file)
{
        return string_field_nomarker_read(NULL, file);
}

const char *string_field_read(u64 *len, memfile *file)
{
        u8 marker = *MEMFILE_READ_TYPE(file, u8);
        if (LIKELY(marker == FIELD_STRING)) {
                return string_field_nomarker_read(len, file);
        } else {
                ERROR(ERR_MARKERMAPPING, NULL);
                return NULL;
        }
}

const char *string_field_nomarker_read(u64 *len, memfile *file)
{
        u64 str_len = MEMFILE_READ_UINTVAR_STREAM(NULL, file);
        const char *result = MEMFILE_READ(file, str_len);
        OPTIONAL_SET(len, str_len);
        return result;
}/**
 * Copyright 2020 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/traverse.h>

// ---------------------------------------------------------------------------------------------------------------------

#define TRAVERSE_IMPL_SETUP(fn_name)                                                                                   \
static inline void traverse_impl_##fn_name(traverser *t)                                                               \
{                                                                                                                      \
        assert(t);                                                                                                     \
        if (LIKELY(t->impl.fn.fn_name != NULL)) {                                                                      \
                t->impl.fn.fn_name(&t->impl.extra);                                                                    \
        }                                                                                                              \
}

TRAVERSE_IMPL_SETUP(create)
TRAVERSE_IMPL_SETUP(drop)

#define TRAVERSE_IMPL_CALL(fn_name, arg_name)                                                                          \
static inline path_policy_e traverse_impl_##fn_name(traverser *t)                                                      \
{                                                                                                                      \
        assert(t);                                                                                                     \
        if (LIKELY(t->impl.fn.fn_name != NULL)) {                                                                      \
                return t->impl.fn.fn_name((VEC_PEEK(&t->context, container_cntx))->container.arg_name,              \
                                          &t->info, &t->impl.extra);                                                   \
        } else {                                                                                                       \
                return PATH_EXPAND;                                                                                    \
        }                                                                                                              \
}

TRAVERSE_IMPL_CALL(visit_record, record)
TRAVERSE_IMPL_CALL(visit_array, array)
TRAVERSE_IMPL_CALL(visit_object, object)
TRAVERSE_IMPL_CALL(visit_field, item)
TRAVERSE_IMPL_CALL(visit_prop, prop)

// ---------------------------------------------------------------------------------------------------------------------

void traverser_create(traverser *traverse, const traverser_fn *fns, unsigned visit_ops)
{
    traverse->visit_ops = visit_ops;
    traverse->impl.fn = *fns;
    vec_create(&traverse->context, sizeof(container_cntx), 15);
    traverse_impl_create(traverse);
}

static void push_context(traverser *traverse, cntx_type_e type, const void *ptr)
{
        container_cntx cntx = {
                .type = type,
                .container.any = ptr
        };
        vec_push(&traverse->context, &cntx, 1);
}

static void pop_context(traverser *traverse)
{
        assert(!vec_is_empty(&traverse->context));
        vec_pop(&traverse->context);
}

void traverser_run_from_record(traverser *traverse, rec *record, void *arg)
{
        push_context(traverse, CNTX_RECORD, record);
        traverse->impl.extra.arg = arg;

        traverse->info.type = ON_ENTER;
        path_policy_e expand = (traverse->visit_ops & VISIT_CALL_RECORD_ENTER) ? traverse_impl_visit_record(traverse) :
                PATH_EXPAND;

        if (expand == PATH_EXPAND) {
                arr_it it;
                item *item;
                rec_read(&it, (rec *) record);
                while ((item = arr_it_next(&it))) {
                        traverser_run_from_item(traverse, item, arg);
                }
        }

        if (traverse->visit_ops & VISIT_CALL_RECORD_EXIT) {
                traverse->info.type = ON_EXIT;
                traverse_impl_visit_record(traverse);
        }

        pop_context(traverse);
}

void traverser_run_from_array(traverser *traverse, arr_it *it, void *arg)
{
        push_context(traverse, CNTX_ARRAY, it);
        traverse->impl.extra.arg = arg;

        traverse->info.type = ON_ENTER;
        path_policy_e expand = (traverse->visit_ops & VISIT_CALL_ARRAY_ENTER) ? traverse_impl_visit_array(traverse) :
                               PATH_EXPAND;

        if (expand == PATH_EXPAND) {
                item *item;
                while ((item = arr_it_next(it))) {
                        traverser_run_from_item(traverse, item, arg);
                }
        }

        if (traverse->visit_ops & VISIT_CALL_ARRAY_EXIT) {
                traverse->info.type = ON_EXIT;
                traverse_impl_visit_array(traverse);
        }
        pop_context(traverse);
}

void traverser_run_from_object(traverser *traverse, obj_it *it, void *arg)
{
        push_context(traverse, CNTX_OBJECT, it);
        traverse->impl.extra.arg = arg;

        traverse->info.type = ON_ENTER;
        path_policy_e expand = (traverse->visit_ops & VISIT_CALL_OBJECT_ENTER) ? traverse_impl_visit_object(traverse) :
                               PATH_EXPAND;

        if (expand == PATH_EXPAND) {
                prop *p;
                while ((p = obj_it_next(it))) {
                        traverser_run_from_prop(traverse, p, arg);
                }
        }

        if (traverse->visit_ops & VISIT_CALL_OBJECT_EXIT) {
                traverse->info.type = ON_EXIT;
                traverse_impl_visit_object(traverse);
        }

        pop_context(traverse);
}

void traverser_run_from_item(traverser *traverse, item *i, void *arg)
{
        push_context(traverse, CNTX_ITEM, i);
        traverse->impl.extra.arg = arg;

        assert(ITEM_IS_FIELD(i));

        traverse->info.type = ON_ENTER;
        path_policy_e expand = (traverse->visit_ops & VISIT_CALL_FIELD_ENTER) ? traverse_impl_visit_field(traverse) :
                PATH_EXPAND;

        if (expand == PATH_EXPAND) {
                if (ITEM_IS_ARRAY(i)) {
                        arr_it nested_it;
                        ITEM_GET_ARRAY(&nested_it, i);
                        traverser_run_from_array(traverse, &nested_it, arg);
                } else if (ITEM_IS_OBJECT(i)) {
                        obj_it nested_it;
                        ITEM_GET_OBJECT(&nested_it, i);
                        traverser_run_from_object(traverse, &nested_it, arg);
                }
        }

        if (traverse->visit_ops & VISIT_CALL_FIELD_EXIT) {
                traverse->info.type = ON_EXIT;
                traverse_impl_visit_field(traverse);
        }

        pop_context(traverse);
}

void traverser_run_from_prop(traverser *traverse, prop *p, void *arg)
{
        push_context(traverse, CNTX_PROP, p);
        traverse->impl.extra.arg = arg;

        traverse->info.type = ON_ENTER;
        path_policy_e expand = (traverse->visit_ops & VISIT_CALL_PROP_ENTER) ? traverse_impl_visit_prop(traverse) :
                               PATH_EXPAND;

        if (expand == PATH_EXPAND) {
                if (PROP_IS_ARRAY(p)) {
                        arr_it nested_it;
                        PROP_GET_ARRAY(&nested_it, p);
                        traverser_run_from_array(traverse, &nested_it, arg);
                } else if (PROP_IS_OBJECT(p)) {
                        obj_it nested_it;
                        PROP_GET_OBJECT(&nested_it, p);
                        traverser_run_from_object(traverse, &nested_it, arg);
                }
        }

        if (traverse->visit_ops & VISIT_CALL_PROP_EXIT) {
                traverse->info.type = ON_EXIT;
                traverse_impl_visit_prop(traverse);
        }

        pop_context(traverse);
}

void traverser_drop(traverser *traverse)
{
        traverse_impl_drop(traverse);
        vec_drop(&traverse->context);
}
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/carbon/dot-eval.h>
#include <karbonit/carbon/dot-eval.h>
#include <karbonit/carbon/update.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/revise.h>
#include <karbonit/utils/numbers.h>

#define TRY_ARRAY_UPDATE(type_match, in_place_update_fn, insert_fn)                                                    \
({                                                                                                                     \
        field_e type_is = 0;                                                                            \
        arr_it_field_type(&type_is, it);                                                                      \
        bool status = false;                                                                                           \
        switch (type_is) {                                                                                             \
                case type_match:                                                                                       \
                        status = in_place_update_fn(it, value);                                                        \
                break;                                                                                                 \
                default: {                                                                                             \
                        insert in;                                                                 \
                        internal_arr_it_remove(it);                                                                    \
                        arr_it_next(it);                                                                      \
                        arr_it_insert_begin(&in, it);                                                   \
                        status = insert_fn(&in, value);                                                          \
                        arr_it_insert_end(&in);                                                         \
                break;                                                                                                 \
                }                                                                                                      \
        }                                                                                                              \
        status;                                                                                                        \
})

#define DEFINE_ARRAY_UPDATE_FUNCTION(type_name, type_match, in_place_update_fn, insert_fn)                             \
static bool array_update_##type_name(arr_it *it, type_name value)                                       \
{                                                                                                                      \
        return TRY_ARRAY_UPDATE(type_match, in_place_update_fn, insert_fn);                                            \
}

DEFINE_ARRAY_UPDATE_FUNCTION(u8, FIELD_NUMBER_U8, internal_arr_it_update_u8, insert_u8)

DEFINE_ARRAY_UPDATE_FUNCTION(u16, FIELD_NUMBER_U16, internal_arr_it_update_u16,
                             insert_u16)

DEFINE_ARRAY_UPDATE_FUNCTION(u32, FIELD_NUMBER_U32, internal_arr_it_update_u32,
                             insert_u32)

DEFINE_ARRAY_UPDATE_FUNCTION(u64, FIELD_NUMBER_U64, internal_arr_it_update_u64,
                             insert_u64)

DEFINE_ARRAY_UPDATE_FUNCTION(i8, FIELD_NUMBER_I8, internal_arr_it_update_i8, insert_i8)

DEFINE_ARRAY_UPDATE_FUNCTION(i16, FIELD_NUMBER_I16, internal_arr_it_update_i16,
                             insert_i16)

DEFINE_ARRAY_UPDATE_FUNCTION(i32, FIELD_NUMBER_I32, internal_arr_it_update_i32,
                             insert_i32)

DEFINE_ARRAY_UPDATE_FUNCTION(i64, FIELD_NUMBER_I64, internal_arr_it_update_i64,
                             insert_i64)

DEFINE_ARRAY_UPDATE_FUNCTION(float, FIELD_NUMBER_FLOAT, internal_arr_it_update_float,
                             insert_float)

#define TRY_UPDATE_GENERIC(context, path, array_exec, column_exec)                                                     \
({                                                                                                                     \
        update updater;                                                                                   \
        if (create(&updater, context, path)) {                                                                         \
                if (resolve_path(&updater) && path_resolved(&updater)) {                                               \
                                                                                                                       \
                        switch (updater.eval.result.container) {                                        \
                        case ARRAY:                                                                              \
                                array_exec;                                                                            \
                                break;                                                                                 \
                        case COLUMN: {                                                                           \
                                u32 elem_pos;                                                                          \
                                col_it *it = column_iterator(&elem_pos, &updater);                     \
                                column_exec;                                                                           \
                        } break;                                                                                       \
                        default:                                                                                       \
                                return ERROR(ERR_INTERNALERR, "unknown container type for update operation");                                            \
                        }                                                                                              \
                }                                                                                                      \
        }                                                                                                              \
        true;                                                                                                        \
})

#define TRY_UPDATE_VALUE(context, path, value, array_update_fn, column_update_fn)                                      \
        TRY_UPDATE_GENERIC(context, path, (array_update_fn(arrayerator(&updater), value)),                          \
                           (column_update_fn(it, elem_pos, value)) )

#define TRY_UPDATE(context, path, array_update_fn, column_update_fn)                                                   \
        TRY_UPDATE_GENERIC(context, path, (array_update_fn(arrayerator(&updater))), (column_update_fn(it, elem_pos)))


static bool
create(update *updater, rev *context, const dot *path)
{
        updater->context = context;
        updater->path = path;

        return true;
}

static bool compile_path(dot *out, const char *in)
{
        return dot_from_string(out, in);
}

static bool resolve_path(update *updater)
{
        return dot_eval_begin_mutable(&updater->eval, updater->path, updater->context);
}

static bool path_resolved(update *updater)
{
        return DOT_EVAL_HAS_RESULT(&updater->eval);
}

static bool column_update_u8(col_it *it, u32 pos, u8 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_u16(col_it *it, u32 pos, u16 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_u32(col_it *it, u32 pos, u32 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_u64(col_it *it, u32 pos, u64 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_i8(col_it *it, u32 pos, i8 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_i16(col_it *it, u32 pos, i16 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_i32(col_it *it, u32 pos, i32 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_i64(col_it *it, u32 pos, i64 value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}

static bool column_update_float(col_it *it, u32 pos, float value)
{
        UNUSED(it);
        UNUSED(pos);
        UNUSED(value);
        ERROR(ERR_NOTIMPLEMENTED, NULL);    // TODO: Implement
        return false;
}


static inline arr_it *arrayerator(update *updater)
{
        return &updater->eval.result.containers.array;
}

static inline col_it *column_iterator(u32 *elem_pos, update *updater)
{
        *elem_pos = updater->eval.result.containers.column.elem_pos;
        return &updater->eval.result.containers.column.it;
}

#define compile_path_and_delegate(context, path, func)                                                                 \
({                                                                                                                     \
        bool status;                                                                                                               \
        dot compiled_path;                                                                           \
        if (compile_path(&compiled_path, path)) {                                                                      \
                status = func(context, &compiled_path);                                                                \
                dot_drop(&compiled_path);                                                                   \
        } else {                                                                                                       \
                return ERROR(ERR_DOT_PATH_PARSERR, "path string parsing failed");                             \
        }                                                                                                              \
        status;                                                                                                        \
})

#define compile_path_and_delegate_wargs(context, path, func, ...)                                                      \
({                                                                                                                     \
        dot compiled_path;                                                                           \
        bool status;                                                                                                   \
        if (compile_path(&compiled_path, path)) {                                                                      \
                status = func(context, &compiled_path, __VA_ARGS__);                                                   \
                dot_drop(&compiled_path);                                                                   \
        } else {                                                                                                       \
                return ERROR(ERR_DOT_PATH_PARSERR, "path string parsing failed");                             \
        }                                                                                                              \
        status;                                                                                                        \
})


bool update_set_null(rev *context, const char *path)
{
        return compile_path_and_delegate(context, path, update_set_null_compiled);
}

bool update_set_true(rev *context, const char *path)
{
        return compile_path_and_delegate(context, path, update_set_true_compiled);
}

bool update_set_false(rev *context, const char *path)
{
        return compile_path_and_delegate(context, path, update_set_false_compiled);
}

bool update_set_u8(rev *context, const char *path, u8 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_u8_compiled, value);
}

bool update_set_u16(rev *context, const char *path, u16 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_u16_compiled, value);
}

bool update_set_u32(rev *context, const char *path, u32 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_u32_compiled, value);
}

bool update_set_u64(rev *context, const char *path, u64 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_u64_compiled, value);
}

bool update_set_i8(rev *context, const char *path, i8 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_i8_compiled, value);
}

bool update_set_i16(rev *context, const char *path, i16 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_i16_compiled, value);
}

bool update_set_i32(rev *context, const char *path, i32 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_i32_compiled, value);
}

bool update_set_i64(rev *context, const char *path, i64 value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_i64_compiled, value);
}

bool update_set_float(rev *context, const char *path, float value)
{
        return compile_path_and_delegate_wargs(context, path, update_set_float_compiled, value);
}

bool update_set_unsigned(rev *context, const char *path, u64 value)
{
        switch (num_min_type_unsigned(value)) {
                case NUM_U8:
                        return update_set_u8(context, path, (u8) value);
                case NUM_U16:
                        return update_set_u16(context, path, (u16) value);
                case NUM_U32:
                        return update_set_u32(context, path, (u32) value);
                case NUM_U64:
                        return update_set_u64(context, path, (u64) value);
                default:
                        return ERROR(ERR_INTERNALERR, "update unsigned value failed: limit exeeded");
        }
}

bool update_set_signed(rev *context, const char *path, i64 value)
{
        switch (num_min_type_signed(value)) {
                case NUM_I8:
                        return update_set_i8(context, path, (i8) value);
                case NUM_I16:
                        return update_set_i16(context, path, (i16) value);
                case NUM_I32:
                        return update_set_i32(context, path, (i32) value);
                case NUM_I64:
                        return update_set_i64(context, path, (i64) value);
                default:
                        return ERROR(ERR_INTERNALERR, "update signed value failed: limit exeeded");
        }
}

bool update_set_string(rev *context, const char *path, const char *value)
{
        // TODO: Implement
        UNUSED(context);
        UNUSED(path);
        UNUSED(value);

        return ERROR(ERR_NOTIMPLEMENTED, "update_set_string");
}

bool update_set_binary(rev *context, const char *path, const void *value, size_t nbytes,
                              const char *file_ext, const char *user_type)
{
        // TODO: Implement
        UNUSED(context);
        UNUSED(value);
        UNUSED(nbytes);
        UNUSED(file_ext);
        UNUSED(user_type);
        UNUSED(path);
        return ERROR(ERR_NOTIMPLEMENTED, "update_set_binary");
}

insert *update_set_array_begin(rev *context, const char *path,
                                                        arr_state *state_out,
                                                        u64 array_capacity)
{
        // TODO: Implement
        UNUSED(context);
        UNUSED(state_out);
        UNUSED(array_capacity);
        UNUSED(path);
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool update_set_array_end(arr_state *state_in)
{
        // TODO: Implement
        UNUSED(state_in);
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

insert *update_set_column_begin(rev *context, const char *path,
                                                         col_state *state_out,
                                                         field_e type, u64 cap)
{
        // TODO: Implement
        UNUSED(state_out);
        UNUSED(context);
        UNUSED(type);
        UNUSED(cap);
        UNUSED(path);
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool update_set_column_end(col_state *state_in)
{
        // TODO: Implement
        UNUSED(state_in);
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

// ---------------------------------------------------------------------------------------------------------------------

bool update_set_null_compiled(rev *context, const dot *path)
{
        return TRY_UPDATE(context, path, internal_arr_it_update_null, col_it_set_null);
}

bool update_set_true_compiled(rev *context, const dot *path)
{
        return TRY_UPDATE(context, path, internal_arr_it_update_true, col_it_set_true);
}

bool update_set_false_compiled(rev *context, const dot *path)
{
        return TRY_UPDATE(context, path, internal_arr_it_update_false, col_it_set_false);
}

bool update_set_u8_compiled(rev *context, const dot *path,
                                   u8 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_u8, column_update_u8);
}

bool update_set_u16_compiled(rev *context, const dot *path,
                                    u16 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_u16, column_update_u16);
}

bool update_set_u32_compiled(rev *context, const dot *path,
                                    u32 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_u32, column_update_u32);
}

bool update_set_u64_compiled(rev *context, const dot *path,
                                    u64 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_u64, column_update_u64);
}

bool update_set_i8_compiled(rev *context, const dot *path,
                                   i8 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_i8, column_update_i8);
}

bool update_set_i16_compiled(rev *context, const dot *path,
                                    i16 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_i16, column_update_i16);
}

bool update_set_i32_compiled(rev *context, const dot *path,
                                    i32 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_i32, column_update_i32);
}

bool update_set_i64_compiled(rev *context, const dot *path,
                                    i64 value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_i64, column_update_i64);
}

bool update_set_float_compiled(rev *context, const dot *path,
                                      float value)
{
        return TRY_UPDATE_VALUE(context, path, value, array_update_float, column_update_float);
}

bool update_set_unsigned_compiled(rev *context, const dot *path,
                                         u64 value)
{
        switch (num_min_type_unsigned(value)) {
                case NUM_U8:
                        return update_set_u8_compiled(context, path, (u8) value);
                case NUM_U16:
                        return update_set_u16_compiled(context, path, (u16) value);
                case NUM_U32:
                        return update_set_u32_compiled(context, path, (u32) value);
                case NUM_U64:
                        return update_set_u64_compiled(context, path, (u64) value);
                default:
                        return ERROR(ERR_INTERNALERR, "unknown type for container update operation");
        }
}

bool update_set_signed_compiled(rev *context, const dot *path,
                                       i64 value)
{
        switch (num_min_type_signed(value)) {
                case NUM_I8:
                        return update_set_i8_compiled(context, path, (i8) value);
                case NUM_I16:
                        return update_set_i16_compiled(context, path, (i16) value);
                case NUM_I32:
                        return update_set_i32_compiled(context, path, (i32) value);
                case NUM_I64:
                        return update_set_i64_compiled(context, path, (i64) value);
                default:
                        return ERROR(ERR_INTERNALERR, "unknown type for container update operation");
        }
}

bool update_set_string_compiled(rev *context, const dot *path,
                                       const char *value)
{
        // TODO: Implement
        UNUSED(context);
        UNUSED(path);
        UNUSED(value);

        return ERROR(ERR_NOTIMPLEMENTED, "update_set_binary_compiled");
}

bool update_set_binary_compiled(rev *context, const dot *path,
                                       const void *value, size_t nbytes, const char *file_ext, const char *user_type)
{
        // TODO: Implement
        UNUSED(context);
        UNUSED(value);
        UNUSED(nbytes);
        UNUSED(file_ext);
        UNUSED(user_type);
        UNUSED(path);

        return ERROR(ERR_NOTIMPLEMENTED, "update_set_binary_compiled");
}

insert *update_set_array_begin_compiled(rev *context,
                                                                 const dot *path,
                                                                 arr_state *state_out,
                                                                 u64 array_capacity)
{
        // TODO: Implement
        UNUSED(context);
        UNUSED(state_out);
        UNUSED(array_capacity);
        UNUSED(path);
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool update_set_array_end_compiled(arr_state *state_in)
{
        // TODO: Implement
        UNUSED(state_in);
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

insert *update_set_column_begin_compiled(rev *context,
                                                                  const dot *path,
                                                                  col_state *state_out,
                                                                  field_e type,
                                                                  u64 cap)
{
        // TODO: Implement
        UNUSED(state_out);
        UNUSED(context);
        UNUSED(type);
        UNUSED(cap);
        UNUSED(path);
        ERROR(ERR_NOTIMPLEMENTED, NULL);
        return NULL;
}

bool update_set_column_end_compiled(col_state *state_in)
{
        // TODO: Implement
        UNUSED(state_in);
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

// ---------------------------------------------------------------------------------------------------------------------

#define revision_context_delegate_func(rev_doc, doc, func, ...)                                                        \
({                                                                                                                     \
        rev revise;                                                                                    \
        revise_begin(&revise, rev_doc, doc);                                                                     \
        bool status = func(&revise, __VA_ARGS__);                                                                      \
        revise_end(&revise);                                                                                     \
        status;                                                                                                        \
})

bool update_one_set_null(const char *dot, rec *rev_doc, rec *doc)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_null, dot);
}

bool update_one_set_true(const char *dot, rec *rev_doc, rec *doc)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_true, dot);
}

bool update_one_set_false(const char *dot, rec *rev_doc, rec *doc)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_false, dot);
}

bool update_one_set_u8(const char *dot, rec *rev_doc, rec *doc, u8 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u8, dot, value);
}

bool update_one_set_u16(const char *dot, rec *rev_doc, rec *doc, u16 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u16, dot, value);
}

bool update_one_set_u32(const char *dot, rec *rev_doc, rec *doc, u32 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u32, dot, value);
}

bool update_one_set_u64(const char *dot, rec *rev_doc, rec *doc, u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u64, dot, value);
}

bool update_one_set_i8(const char *dot, rec *rev_doc, rec *doc, i8 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i8, dot, value);
}

bool update_one_set_i16(const char *dot, rec *rev_doc, rec *doc, i16 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i16, dot, value);
}

bool update_one_set_i32(const char *dot, rec *rev_doc, rec *doc, i32 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i32, dot, value);
}

bool update_one_set_i64(const char *dot, rec *rev_doc, rec *doc, i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i64, dot, value);
}

bool update_one_set_float(const char *dot, rec *rev_doc, rec *doc,
                                 float value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_float, dot, value);
}

bool update_one_set_unsigned(const char *dot, rec *rev_doc, rec *doc,
                                    u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_unsigned, dot, value);
}

bool update_one_set_signed(const char *dot, rec *rev_doc, rec *doc, i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_signed, dot, value);
}

bool update_one_set_string(const char *dot, rec *rev_doc, rec *doc,
                                  const char *value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_string, dot, value);
}

bool update_one_set_binary(const char *dot, rec *rev_doc, rec *doc,
                                  const void *value, size_t nbytes, const char *file_ext, const char *user_type)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_binary, dot, value, nbytes,
                                              file_ext, user_type);
}

insert *update_one_set_array_begin(arr_state *state_out,
                                                            const char *dot, rec *rev_doc,
                                                            rec *doc, u64 array_capacity)
{
        rev revise;
        revise_begin(&revise, rev_doc, doc);
        insert *result = update_set_array_begin(&revise, dot, state_out, array_capacity);
        // ... TODO: add revision to context
        return result;
}

bool update_one_set_array_end(arr_state *state_in)
{
        bool status = update_set_array_end(state_in);
        // ... TODO: drop revision from context
        return status;
}

insert *update_one_set_column_begin(col_state *state_out,
                                                             const char *dot, rec *rev_doc,
                                                             rec *doc, field_e type,
                                                             u64 cap)
{
        rev revise;
        revise_begin(&revise, rev_doc, doc);
        insert *result = update_set_column_begin(&revise, dot, state_out, type,
                                                                          cap);
        // ... TODO: add revision to context
        return result;
}

bool update_one_set_column_end(col_state *state_in)
{
        bool status = update_set_column_end(state_in);
        // ... TODO: drop revision from context
        return status;
}

// ---------------------------------------------------------------------------------------------------------------------

bool update_one_set_null_compiled(const dot *path, rec *rev_doc,
                                         rec *doc)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_null_compiled, path);
}

bool update_one_set_true_compiled(const dot *path, rec *rev_doc,
                                         rec *doc)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_true_compiled, path);
}

bool update_one_set_false_compiled(const dot *path, rec *rev_doc,
                                          rec *doc)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_false_compiled, path);
}

bool update_one_set_u8_compiled(const dot *path, rec *rev_doc,
                                       rec *doc, u8 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u8_compiled, path, value);
}

bool update_one_set_u16_compiled(const dot *path, rec *rev_doc,
                                        rec *doc, u16 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u16_compiled, path, value);
}

bool update_one_set_u32_compiled(const dot *path, rec *rev_doc,
                                        rec *doc, u32 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u32_compiled, path, value);
}

bool update_one_set_u64_compiled(const dot *path, rec *rev_doc,
                                        rec *doc, u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_u64_compiled, path, value);
}

bool update_one_set_i8_compiled(const dot *path, rec *rev_doc,
                                       rec *doc, i8 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i8_compiled, path, value);
}

bool update_one_set_i16_compiled(const dot *path, rec *rev_doc,
                                        rec *doc, i16 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i16_compiled, path, value);
}

bool update_one_set_i32_compiled(const dot *path, rec *rev_doc,
                                        rec *doc, i32 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i32_compiled, path, value);
}

bool update_one_set_i64_compiled(const dot *path, rec *rev_doc,
                                        rec *doc, i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_i64_compiled, path, value);
}

bool update_one_set_float_compiled(const dot *path, rec *rev_doc,
                                          rec *doc, float value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_float_compiled, path, value);
}

bool update_one_set_unsigned_compiled(const dot *path, rec *rev_doc,
                                             rec *doc, u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_unsigned_compiled, path, value);
}

bool update_one_set_signed_compiled(const dot *path, rec *rev_doc,
                                           rec *doc, i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_signed_compiled, path, value);
}

bool update_one_set_string_compiled(const dot *path, rec *rev_doc,
                                           rec *doc, const char *value)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_string_compiled, path, value);
}

bool update_one_set_binary_compiled(const dot *path, rec *rev_doc,
                                           rec *doc, const void *value, size_t nbytes,
                                           const char *file_ext,
                                           const char *user_type)
{
        return revision_context_delegate_func(rev_doc, doc, update_set_binary_compiled, path, value, nbytes,
                                              file_ext, user_type);
}

insert *update_one_set_array_begin_compiled(arr_state *state_out,
                                                                     const dot *path,
                                                                     rec *rev_doc, rec *doc,
                                                                     u64 array_capacity)
{
        rev revise;
        revise_begin(&revise, rev_doc, doc);
        insert *result = update_set_array_begin_compiled(&revise, path, state_out,
                                                                                  array_capacity);
        // ... TODO: add revision to context
        return result;
}

bool update_one_set_array_end_compiled(arr_state *state_in)
{
        bool status = update_set_array_end_compiled(state_in);
        // ... TODO: drop revision from context
        return status;
}

insert *update_one_set_column_begin_compiled(
        col_state *state_out, const dot *path,
        rec *rev_doc,
        rec *doc, field_e type, u64 cap)
{
        rev revise;
        revise_begin(&revise, rev_doc, doc);
        insert *result = update_set_column_begin_compiled(&revise, path, state_out, type,
                                                                                   cap);
        // ... TODO: add revision to context
        return result;
}

bool update_one_set_column_end_compiled(col_state *state_in)
{
        bool status = update_set_column_end_compiled(state_in);
        // ... TODO: drop revision from context
        return status;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/error.h>

_Thread_local struct err_info g_err = {
        .line = 0,
        .file = NULL,
        .code = ERR_NOERR,
        .details = NULL,
        .noabort = false
};

void error_abort_enable()
{
        g_err.noabort = false;
}

void error_abort_disable()
{
        g_err.noabort = true;
}

void error_set(int code, const char *file, u32 line, const char *details)
{
        error_clear();
        g_err.code = code;
        g_err.file = file;
        g_err.line = line;
        g_err.details = details ? strdup(details) : NULL;
}

void error_clear()
{
        if (g_err.details) {
                free(g_err.details);
                g_err.details = NULL;
        }
        g_err.line = 0;
        g_err.code = ERR_NOERR;
        g_err.file = NULL;
}

const char *error_get_str()
{
        return global_err_str[g_err.code];
}

int error_get_code()
{
        return g_err.code;
}

const char *error_get_file(u32 *line)
{
        *line = g_err.line;
        return g_err.file;
}

const char *error_get_details()
{
        return g_err.details;
}

void error_print(FILE *file)
{
        fprintf(file, "** ERROR **  %s (%d)\n", error_get_str(), g_err.code);
        fprintf(file, "             in %s:%d\n", g_err.file, g_err.line);
        fprintf(file, "             %s\n", g_err.details ? g_err.details : "no details");
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <ctype.h>
#include <karbonit/hexdump.h>

bool hexdump(str_buf *dst, const void *base, u64 nbytes)
{
        char buffer[11];

        sprintf(buffer, "%08x  ", 0);
        str_buf_add(dst, buffer);

        for (u64 hex_block_id = 0; hex_block_id < nbytes;) {

                u8 step = JAK_MIN(16, nbytes - hex_block_id);

                for (u64 i = 0; i < step; i++) {
                        char c = *((const char *) (base + hex_block_id + i));
                        sprintf(buffer, "%02x ", (unsigned char) c);
                        str_buf_add(dst, buffer);
                        if (i == 7) {
                                str_buf_add_char(dst, ' ');
                        }
                }

                if (UNLIKELY(step == 7)) {
                        str_buf_add_char(dst, ' ');
                }

                if (UNLIKELY(step < 16)) {
                        for (u8 pad = 0; pad < 16 - step; pad++) {
                                sprintf(buffer, "   ");
                                str_buf_add(dst, buffer);
                        }
                }

                str_buf_add(dst, " | ");

                for (u64 i = 0; i < step; i++) {
                        char c = *((const char *) (base + hex_block_id + i));
                        if (isgraph(c)) {
                                sprintf(buffer, "%c", c);
                        } else {
                                sprintf(buffer, ".");
                        }

                        str_buf_add(dst, buffer);
                }

                if (UNLIKELY(step < 16)) {
                        for (u8 pad = 0; pad < 16 - step; pad++) {
                                sprintf(buffer, " ");
                                str_buf_add(dst, buffer);
                        }
                }

                str_buf_add_char(dst, '|');


                if (LIKELY(hex_block_id + step < nbytes)) {
                        str_buf_add(dst, "\n");
                        sprintf(buffer, "%08x  ", ((u32) hex_block_id + 16));
                        str_buf_add(dst, buffer);
                }


                hex_block_id += step;
        }

        str_buf_add(dst, "\n");

        return true;
}

bool hexdump_print(FILE *file, const void *base, u64 nbytes)
{
        bool status;
        str_buf sb;
        str_buf_create(&sb);
        if ((status = hexdump(&sb, base, nbytes))) {
                fprintf(file, "%s", str_buf_cstr(&sb));
        }
        str_buf_drop(&sb);
        return status;

}/*
 * json - Java Script Object Notation sub module
 *
 * Copyright 2019 Marcus Pinnecke
 */

#include <karbonit/json.h>
#include <karbonit/karbonit.h>


static const char *_json_from_binary(str_buf *dst, const binary_field *binary)
{
        binary_field_print(dst, binary);
        return str_buf_cstr(dst);
}

static const char *_json_from_string(str_buf *dst, const string_field *binary)
{
        str_buf_add_nquote(dst, binary->str, binary->len);
        return str_buf_cstr(dst);
}

static const char *_json_from_boolean(str_buf *dst, bool value)
{
        str_buf_add(dst, value ? "true" : "false");
        return str_buf_cstr(dst);
}

static const char *_json_from_unsigned(str_buf *dst, u64 value)
{
        str_buf_add_u64(dst, value);
        return str_buf_cstr(dst);
}

static const char *_json_from_signed(str_buf *dst, i64 value)
{
        str_buf_add_i64(dst, value);
        return str_buf_cstr(dst);
}

static const char *_json_from_float(str_buf *dst, float value)
{
        str_buf_add_float(dst, value);
        return str_buf_cstr(dst);
}

static const char *_json_from_null(str_buf *dst)
{
        str_buf_add(dst, "null");
        return str_buf_cstr(dst);
}

static const char *_json_from_undef(str_buf *dst)
{
        str_buf_add(dst, "undef");
        return str_buf_cstr(dst);
}

const char *_json_from_column(str_buf *dst, col_it *src)
{
        col_it_print(dst, src);
        return str_buf_cstr(dst);
}

static path_policy_e json_from_fn_record(const rec *record, const traverse_info *context, traverse_hidden *extra)
{
        str_buf *str = (str_buf *) extra->arg;
        if (context->type == ON_ENTER) {
                extra->json_printer.record_is_array = rec_is_array(record);
        }
        str_buf_add(str, extra->json_printer.record_is_array ?
                              (context->type == ON_ENTER ? "[" : "]") :
                              "");

        return PATH_EXPAND;
}

static path_policy_e json_from_fn_array(const arr_it *array, const traverse_info *context, traverse_hidden *extra)
{
        UNUSED(array)
        str_buf *str = (str_buf *) extra->arg;
        str_buf_add_char(str, context->type == ON_ENTER ? '[' : ']');
        return PATH_EXPAND;
}

static path_policy_e json_from_fn_object(const obj_it *object, const traverse_info *context, traverse_hidden *extra)
{
        UNUSED(object)
        str_buf *str = (str_buf *) extra->arg;
        str_buf_add_char(str, context->type == ON_ENTER ? '{' : '}');
        return PATH_EXPAND;
}

static void json_print_field(str_buf *str, const item *field, const traverse_info *context)
{
        if (context->type == ON_ENTER) {
                if (ITEM_IS_NULL(field)) {
                        _json_from_null(str);
                } else if (ITEM_IS_TRUE(field)) {
                        _json_from_boolean(str, true);
                } else if (ITEM_IS_FALSE(field)) {
                        _json_from_boolean(str, false);
                } else if (ITEM_IS_STRING(field)) {
                        string_field sf = ITEM_GET_STRING(field, NULL_STRING);
                        _json_from_string(str, &sf);
                } else if (ITEM_IS_SIGNED(field)) {
                        i64 value = ITEM_GET_SIGNED(field, NULL_INT64);
                        _json_from_signed(str, value);
                } else if (ITEM_IS_UNSIGNED(field)) {
                        u64 value = ITEM_GET_SIGNED(field, NULL_UINT64);
                        _json_from_unsigned(str, value);
                } else if (ITEM_IS_FLOAT(field)) {
                        float value = ITEM_GET_FLOAT(field, NULL_FLOAT);
                        _json_from_float(str, value);
                } else if (ITEM_IS_BINARY(field)) {
                        binary_field value = ITEM_GET_BINARY(field, NULL_BINARY);
                        _json_from_binary(str, &value);
                } else if (ITEM_IS_COLUMN(field)) {
                        col_it it;
                        ITEM_GET_COLUMN(&it, field);
                        _json_from_column(str, &it);
                }
        }
}

static path_policy_e json_from_fn_field(const item *item, const traverse_info *context, traverse_hidden *extra)
{
        str_buf *str = (str_buf *) extra->arg;
        str_buf_add(str, ITEM_GET_INDEX(item) > 0 && context->type == ON_ENTER ? ", " : "");
        json_print_field(str, item, context);
        return PATH_EXPAND;
}

static path_policy_e json_from_fn_prop(const prop *prop, const traverse_info *context, traverse_hidden *extra)
{
        str_buf *str = (str_buf *) extra->arg;
        if (context->type == ON_ENTER) {
                str_buf_add(str, PROP_GET_INDEX(prop) > 0 && context->type == ON_ENTER ? ", " : "");
                str_buf_add_nquote(str, prop->key.str, prop->key.len);
                str_buf_add_char(str, ':');
        }
        json_print_field(str, &prop->value, context);
        return PATH_EXPAND;
}

traverser_fn json_from_fn = {
        .create = NULL,
        .drop = NULL,
        .visit_record = json_from_fn_record,
        .visit_array = json_from_fn_array,
        .visit_object = json_from_fn_object,
        .visit_field = json_from_fn_field,
        .visit_prop = json_from_fn_prop
};

const char *json_from_record(str_buf *dst, rec *src)
{
        TRAVERSE(dst, &json_from_fn, VISIT_ALL, traverser_run_from_record, src);
        return str_buf_cstr(dst);
}

const char *json_from_array(str_buf *dst, arr_it *src)
{
        TRAVERSE(dst, &json_from_fn, VISIT_ALL, traverser_run_from_array, src);
        return str_buf_cstr(dst);
}

const char *json_from_object(str_buf *dst, obj_it *src)
{
        TRAVERSE(dst, &json_from_fn, VISIT_ALL, traverser_run_from_object, src);
        return str_buf_cstr(dst);
}

const char *json_from_item(str_buf *dst, item *src)
{
        traverse_info info = { .type = ON_ENTER };
        json_print_field(dst, src, &info);
        info.type = ON_EXIT;
        json_print_field(dst, src, &info);
        return str_buf_cstr(dst);
}

const char *json_from_column(str_buf *dst, col_it *src)
{
        str_buf_clear(dst);
        return _json_from_column(dst, src);
}

const char *json_from_binary(str_buf *dst, const binary_field *binary)
{
        str_buf_clear(dst);
        return _json_from_binary(dst, binary);
}

const char *json_from_string(str_buf *dst, const string_field *str)
{
        str_buf_clear(dst);
        return _json_from_string(dst, str);
}

const char *json_from_boolean(str_buf *dst, bool value)
{
        str_buf_clear(dst);
        return _json_from_boolean(dst, value);
}

const char *json_from_unsigned(str_buf *dst, u64 value)
{
        str_buf_clear(dst);
        return _json_from_unsigned(dst, value);
}

const char *json_from_signed(str_buf *dst, i64 value)
{
        str_buf_clear(dst);
        return _json_from_signed(dst, value);
}

const char *json_from_float(str_buf *dst, float value)
{
        str_buf_clear(dst);
        return _json_from_float(dst, value);
}

const char *json_from_null(str_buf *dst)
{
        str_buf_clear(dst);
        return _json_from_null(dst);
}

const char *json_from_undef(str_buf *dst)
{
        str_buf_clear(dst);
        return _json_from_undef(dst);
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <ctype.h>
#include <locale.h>
#include <karbonit/json/json-parser.h>
#include <karbonit/archive/doc.h>
#include <karbonit/utils/convert.h>
#include <karbonit/utils/numbers.h>
#include <karbonit/json/json-parser.h>

static struct {
        json_token_e token;
        const char *string;
} JSON_TOKEN_STRINGS[] = {{.token = OBJECT_OPEN, .string = "OBJECT_OPEN"},
                              {.token = OBJECT_CLOSE, .string = "OBJECT_CLOSE"},
                              {.token = LITERAL_STRING, .string = "JSON_TOKEN_STRING"},
                              {.token = LITERAL_INT, .string = "LITERAL_INT"},
                              {.token = LITERAL_FLOAT, .string = "LITERAL_FLOAT"},
                              {.token = LITERAL_TRUE, .string = "LITERAL_TRUE"},
                              {.token = LITERAL_FALSE, .string = "LITERAL_FALSE"},
                              {.token = LITERAL_NULL, .string = "LITERAL_NULL"},
                              {.token = COMMA, .string = "COMMA"},
                              {.token = ASSIGN, .string = "JSON_TOKEN_ASSIGMENT"},
                              {.token = ARRAY_OPEN, .string = "ARRAY_OPEN"},
                              {.token = ARRAY_CLOSE, .string = "ARRAY_CLOSE"},
                              {.token = JSON_UNKNOWN, .string = "JSON_UNKNOWN"}};

struct token_memory {
        json_token_e type;
        bool init;
};

static int process_token(json_err *error_desc, const json_token *token,
                         vec ofType(json_token_e) *brackets, struct token_memory *token_mem);

static int set_error(json_err *error_desc, const json_token *token, const char *msg);

bool json_tokenizer_init(json_tokenizer *tokenizer, const char *input)
{
        tokenizer->cursor = input;
        tokenizer->token =
                (json_token) {.type = JSON_UNKNOWN, .length = 0, .column = 0, .line = 1, .string = NULL};
        return true;
}

static void
parse_string_token(json_tokenizer *tokenizer, char c, char delimiter, char delimiter2, char delimiter3,
                   bool include_start, bool include_end)
{
        bool escapeQuote = false;
        tokenizer->token.type = LITERAL_STRING;
        if (!include_start) {
                tokenizer->token.string++;
        }
        tokenizer->token.column++;
        char last_1_c = '\0', last_2_c = '\0', last_3_c = '\0', last_4_c = '\0';
        c = *(++tokenizer->cursor);
        while ((escapeQuote || (c != delimiter && c != delimiter2 && c != delimiter3)) && c != '\r' && c != '\n') {
                next_char:
                tokenizer->token.length++;
                last_4_c = last_3_c;
                last_3_c = last_2_c;
                last_2_c = last_1_c;
                last_1_c = c;
                c = *(++tokenizer->cursor);
                if (UNLIKELY(c == '\\' && last_1_c == '\\')) {
                        goto next_char;
                }
                escapeQuote = c == '"' && last_1_c == '\\'
                              && ((last_2_c == '\\' && last_3_c == '\\' && last_4_c != '\\')
                                  || (last_2_c != '\\' && last_3_c == '\\')
                                  || (last_2_c != '\\' && last_3_c != '\\'));
        }

        if (include_end) {
                tokenizer->token.length++;
        } else {
                tokenizer->cursor++;
        }

        tokenizer->cursor += (c == '\r' || c == '\n') ? 1 : 0;
}

const json_token *json_tokenizer_next(json_tokenizer *tokenizer)
{
        if (LIKELY(*tokenizer->cursor != '\0')) {
                char c = *tokenizer->cursor;
                tokenizer->token.string = tokenizer->cursor;
                tokenizer->token.column += tokenizer->token.length;
                tokenizer->token.length = 0;
                if (c == '\n' || c == '\r') {
                        tokenizer->token.line += c == '\n' ? 1 : 0;
                        tokenizer->token.column = c == '\n' ? 0 : tokenizer->token.column;
                        tokenizer->cursor++;
                        return json_tokenizer_next(tokenizer);
                } else if (isspace(c)) {
                        do {
                                tokenizer->cursor++;
                                tokenizer->token.column++;
                        } while (isspace(c = *tokenizer->cursor) && c != '\n');
                        return json_tokenizer_next(tokenizer);
                } else if (c == '{' || c == '}' || c == '[' || c == ']' || c == ':' || c == ',') {
                        tokenizer->token.type =
                                c == '{' ? OBJECT_OPEN : c == '}' ? OBJECT_CLOSE : c == '[' ? ARRAY_OPEN : c == ']'
                                                                                                           ? ARRAY_CLOSE
                                                                                                           : c == ':'
                                                                                                             ? ASSIGN
                                                                                                             : COMMA;
                        tokenizer->token.column++;
                        tokenizer->token.length = 1;
                        tokenizer->cursor++;
                } else if (c != '"' && (isalpha(c) || c == '_') &&
                           (strlen(tokenizer->cursor) >= 4 && (strncmp(tokenizer->cursor, "null", 4) != 0 &&
                                                               strncmp(tokenizer->cursor, "true", 4) != 0)) &&
                           (strlen(tokenizer->cursor) >= 5 && strncmp(tokenizer->cursor, "false", 5) != 0)) {
                        parse_string_token(tokenizer, c, ' ', ':', ',', true, true);
                } else if (c == '"') {
                        parse_string_token(tokenizer, c, '"', '"', '"', false, false);
                } else if (c == 't' || c == 'f' || c == 'n') {
                        const unsigned lenTrueNull = 4;
                        const unsigned lenFalse = 5;
                        const unsigned cursorLen = strlen(tokenizer->cursor);
                        if (cursorLen >= lenTrueNull && strncmp(tokenizer->cursor, "true", lenTrueNull) == 0) {
                                tokenizer->token.type = LITERAL_TRUE;
                                tokenizer->token.length = lenTrueNull;
                        } else if (cursorLen >= lenFalse && strncmp(tokenizer->cursor, "false", lenFalse) == 0) {
                                tokenizer->token.type = LITERAL_FALSE;
                                tokenizer->token.length = lenFalse;
                        } else if (cursorLen >= lenTrueNull && strncmp(tokenizer->cursor, "null", lenTrueNull) == 0) {
                                tokenizer->token.type = LITERAL_NULL;
                                tokenizer->token.length = lenTrueNull;
                        } else {
                                goto caseTokenUnknown;
                        }
                        tokenizer->token.column++;
                        tokenizer->cursor += tokenizer->token.length;
                } else if (c == '-' || isdigit(c)) {
                        unsigned fracFound = 0, expFound = 0, plusMinusFound = 0;
                        bool plusMinusAllowed = false;
                        bool onlyDigitsAllowed = false;
                        do {
                                onlyDigitsAllowed |= plusMinusAllowed;
                                plusMinusAllowed = (expFound == 1);
                                c = *(++tokenizer->cursor);
                                fracFound += c == '.';
                                expFound += (c == 'e') || (c == 'E');
                                plusMinusFound += plusMinusAllowed && ((c == '+') || (c == '-')) ? 1 : 0;
                                tokenizer->token.length++;
                        } while ((((isdigit(c)) || (c == '.' && fracFound <= 1)
                                   || (plusMinusAllowed && (plusMinusFound <= 1) && ((c == '+') || (c == '-')))
                                   || ((c == 'e' || c == 'E') && expFound <= 1))) && c != '\n' && c != '\r');

                        if (!isdigit(*(tokenizer->cursor - 1))) {
                                tokenizer->token.column -= tokenizer->token.length;
                                goto caseTokenUnknown;
                        }
                        tokenizer->cursor += (c == '\r' || c == '\n') ? 1 : 0;
                        tokenizer->token.type = fracFound ? LITERAL_FLOAT : LITERAL_INT;
                } else {
                        caseTokenUnknown:
                        tokenizer->token.type = JSON_UNKNOWN;
                        tokenizer->token.column++;
                        tokenizer->token.length = strlen(tokenizer->cursor);
                        tokenizer->cursor += tokenizer->token.length;
                }
                return &tokenizer->token;
        } else {
                return NULL;
        }
}

void json_token_dup(json_token *dst, const json_token *src)
{
        assert(dst);
        assert(src);
        memcpy(dst, src, sizeof(json_token));
}

void json_token_print(FILE *file, const json_token *token)
{
        char *string = MALLOC(token->length + 1);
        strncpy(string, token->string, token->length);
        string[token->length] = '\0';
        fprintf(file,
                "{\"type\": \"%s\", \"line\": %d, \"column\": %d, \"length\": %d, \"text\": \"%s\"}",
                JSON_TOKEN_STRINGS[token->type].string,
                token->line,
                token->column,
                token->length,
                string);
        free(string);
}

static bool parse_object(json_object *object, vec ofType(json_token) *token_stream, size_t *token_idx);

static bool parse_array(json_array *array, vec ofType(json_token) *token_stream, size_t *token_idx);

static void parse_string(json_string *string, vec ofType(json_token) *token_stream,
                         size_t *token_idx);

static void parse_number(json_number *number, vec ofType(json_token) *token_stream,
                         size_t *token_idx);

static bool parse_element(json_element *element, vec ofType(json_token) *token_stream, size_t *token_idx);

static bool parse_elements(json_elements *elements, vec ofType(json_token) *token_stream, size_t *token_idx);

static bool parse_token_stream(json *json, vec ofType(json_token) *token_stream);

static json_token get_token(vec ofType(json_token) *token_stream, size_t token_idx);

static void connect_child_and_parents_member(json_prop *member);

static void connect_child_and_parents_object(json_object *object);

static void connect_child_and_parents_array(json_array *array);

static void connect_child_and_parents_value(json_node_value *value);

static void connect_child_and_parents_element(json_element *element);

static void connect_child_and_parents(json *json);

static bool json_ast_node_member_print(FILE *file, json_prop *member);

static bool json_ast_node_object_print(FILE *file, json_object *object);

static bool json_ast_node_array_print(FILE *file, json_array *array);

static void json_ast_node_string_print(FILE *file, json_string *string);

static bool json_ast_node_number_print(FILE *file, json_number *number);

static bool json_ast_node_value_print(FILE *file, json_node_value *value);

static bool json_ast_node_element_print(FILE *file, json_element *element);

#define NEXT_TOKEN(x) { *x = *x + 1; }
#define PREV_TOKEN(x) { *x = *x - 1; }

bool
json_parse(json *json, json_err *error_desc, json_parser *parser, const char *input)
{
        str_buf str;
        str_buf_create(&str);
        str_buf_add(&str, input);
        str_buf_trim(&str);
        if (str_buf_is_empty(&str)) {
                set_error(error_desc, NULL, "input str_buf is empty");
                str_buf_drop(&str);
                return false;
        }
        str_buf_drop(&str);


        vec ofType(json_token_e) brackets;
        vec ofType(json_token) token_stream;

        struct json retval;
        ZERO_MEMORY(&retval, sizeof(json))
        retval.element = MALLOC(sizeof(json_element));
        const json_token *token;
        int status;

        json_tokenizer_init(&parser->tokenizer, input);
        vec_create(&brackets, sizeof(json_token_e), 15);
        vec_create(&token_stream, sizeof(json_token), 200);

        struct token_memory token_mem = {.init = true, .type = JSON_UNKNOWN};

        while ((token = json_tokenizer_next(&parser->tokenizer))) {
                if (LIKELY(
                        (status = process_token(error_desc, token, &brackets, &token_mem)) == true)) {
                        json_token *newToken = VEC_NEW_AND_GET(&token_stream, json_token);
                        json_token_dup(newToken, token);
                } else {
                        goto cleanup;
                }
        }
        if (!vec_is_empty(&brackets)) {
                json_token_e type = *VEC_PEEK(&brackets, json_token_e);
                char buffer[1024];
                sprintf(&buffer[0],
                        "Unexpected end of file: missing '%s' to match unclosed '%s' (if any)",
                        type == OBJECT_OPEN ? "}" : "]",
                        type == OBJECT_OPEN ? "{" : "[");
                status = set_error(error_desc, token, &buffer[0]);
                goto cleanup;
        }

        if (!parse_token_stream(&retval, &token_stream)) {
                status = false;
                goto cleanup;
        }

        OPTIONAL_SET_OR_ELSE(json, retval, json_drop(json));
        status = true;

        cleanup:
        vec_drop(&brackets);
        vec_drop(&token_stream);
        return status;
}

bool test_condition_value(json_node_value *value)
{
        switch (value->value_type) {
                case JSON_VALUE_OBJECT:
                        for (size_t i = 0; i < value->value.object->value->members.num_elems; i++) {
                                json_prop *member = VEC_GET(&value->value.object->value->members, i,
                                                                       json_prop);
                                if (!test_condition_value(&member->value.value)) {
                                        return false;
                                }
                        }
                        break;
                case JSON_VALUE_ARRAY: {
                        json_elements *elements = &value->value.array->elements;
                        json_value_type_e value_type = JSON_VALUE_NULL;

                        for (size_t i = 0; i < elements->elements.num_elems; i++) {
                                json_element *element = VEC_GET(&elements->elements, i,
                                                                           json_element);
                                value_type =
                                        ((i == 0 || value_type == JSON_VALUE_NULL) ? element->value.value_type
                                                                                   : value_type);

                                /** Test "All elements in array of same type" condition */
                                if ((element->value.value_type != JSON_VALUE_NULL) && (value_type == JSON_VALUE_TRUE
                                                                                       && (element->value.value_type !=
                                                                                           JSON_VALUE_TRUE
                                                                                           ||
                                                                                           element->value.value_type !=
                                                                                           JSON_VALUE_FALSE))
                                    && (value_type == JSON_VALUE_FALSE && (element->value.value_type != JSON_VALUE_TRUE
                                                                           || element->value.value_type !=
                                                                              JSON_VALUE_FALSE))
                                    && ((value_type != JSON_VALUE_TRUE && value_type != JSON_VALUE_FALSE)
                                        && value_type != element->value.value_type)) {
                                        char message[] = "JSON file constraint broken: arrays of mixed types detected";
                                        char *result = MALLOC(strlen(message) + 1);
                                        strcpy(result, &message[0]);
                                        ERROR(ERR_ARRAYOFMIXEDTYPES, result);
                                        free(result);
                                        return false;
                                }

                                switch (element->value.value_type) {
                                        case JSON_VALUE_OBJECT: {
                                                json_object *object = element->value.value.object;
                                                for (size_t i = 0; i < object->value->members.num_elems; i++) {
                                                        json_prop
                                                                *member = VEC_GET(&object->value->members, i,
                                                                                  json_prop);
                                                        if (!test_condition_value(&member->value.value)) {
                                                                return false;
                                                        }
                                                }
                                        }
                                                break;
                                        case JSON_VALUE_ARRAY: {/** Test "No Array of Arrays" condition */
                                                char message[] = "JSON file constraint broken: arrays of arrays detected";
                                                char *result = MALLOC(strlen(message) + 1);
                                                strcpy(result, &message[0]);
                                                ERROR(ERR_ARRAYOFARRAYS, result);
                                                free(result);
                                                return false;
                                        }
                                        default:
                                                break;
                                }
                        }
                }
                        break;
                default:
                        break;
        }
        return true;
}

bool json_test(json *json)
{
        return (test_condition_value(&json->element->value));
}

static json_token get_token(vec ofType(json_token) *token_stream, size_t token_idx)
{
        return *(json_token *) vec_at(token_stream, token_idx);
}

static bool has_next_token(size_t token_idx, vec ofType(json_token) *token_stream)
{
        return token_idx < token_stream->num_elems;
}

bool parse_members(json_members *members,
                   vec ofType(json_token) *token_stream,
                   size_t *token_idx)
{
        vec_create(&members->members, sizeof(json_prop), 20);
        json_token delimiter_token;

        do {
                json_prop *member = VEC_NEW_AND_GET(&members->members, json_prop);
                json_token keyNameToken = get_token(token_stream, *token_idx);

                member->key.value = MALLOC(keyNameToken.length + 1);
                strncpy(member->key.value, keyNameToken.string, keyNameToken.length);
                member->key.value[keyNameToken.length] = '\0';

                /** assignment token */
                NEXT_TOKEN(token_idx);
                if (!has_next_token(*token_idx, token_stream)) {
                        return false;
                }
                json_token assignment_token = get_token(token_stream, *token_idx);
                if (assignment_token.type != ASSIGN) {
                        return false;
                }

                /** value assignment token */
                NEXT_TOKEN(token_idx);
                if (!has_next_token(*token_idx, token_stream)) {
                        return false;
                }

                json_token valueToken = get_token(token_stream, *token_idx);

                switch (valueToken.type) {
                        case OBJECT_OPEN:
                                member->value.value.value_type = JSON_VALUE_OBJECT;
                                member->value.value.value.object = MALLOC(sizeof(json_object));
                                if (!parse_object(member->value.value.value.object, token_stream, token_idx)) {
                                        return false;
                                }
                                break;
                        case ARRAY_OPEN:
                                member->value.value.value_type = JSON_VALUE_ARRAY;
                                member->value.value.value.array = MALLOC(sizeof(json_array));
                                if (!parse_array(member->value.value.value.array, token_stream, token_idx)) {
                                        return false;
                                }
                                break;
                        case LITERAL_STRING:
                                member->value.value.value_type = JSON_VALUE_STRING;
                                member->value.value.value.string = MALLOC(sizeof(json_string));
                                parse_string(member->value.value.value.string, token_stream, token_idx);
                                break;
                        case LITERAL_INT:
                        case LITERAL_FLOAT:
                                member->value.value.value_type = JSON_VALUE_NUMBER;
                                member->value.value.value.number = MALLOC(sizeof(json_number));
                                parse_number(member->value.value.value.number, token_stream, token_idx);
                                break;
                        case LITERAL_TRUE:
                                member->value.value.value_type = JSON_VALUE_TRUE;
                                NEXT_TOKEN(token_idx);
                                break;
                        case LITERAL_FALSE:
                                member->value.value.value_type = JSON_VALUE_FALSE;
                                NEXT_TOKEN(token_idx);
                                break;
                        case LITERAL_NULL:
                                member->value.value.value_type = JSON_VALUE_NULL;
                                NEXT_TOKEN(token_idx);
                                break;
                        default:
                                return ERROR(ERR_PARSETYPE, NULL);
                }

                delimiter_token = get_token(token_stream, *token_idx);
                NEXT_TOKEN(token_idx);
        } while (delimiter_token.type == COMMA);
        PREV_TOKEN(token_idx);
        return true;
}

static bool parse_object(json_object *object, vec ofType(json_token) *token_stream, size_t *token_idx)
{
        assert(get_token(token_stream, *token_idx).type == OBJECT_OPEN);
        NEXT_TOKEN(token_idx);  /** Skip '{' */
        object->value = MALLOC(sizeof(json_members));

        /** test whether this is an empty object */
        json_token token = get_token(token_stream, *token_idx);

        if (token.type != OBJECT_CLOSE) {
                if (!parse_members(object->value, token_stream, token_idx)) {
                        return false;
                }
        } else {
                vec_create(&object->value->members, sizeof(json_prop), 20);
        }

        NEXT_TOKEN(token_idx);  /** Skip '}' */
        return true;
}

static bool parse_array(json_array *array, vec ofType(json_token) *token_stream, size_t *token_idx)
{
        json_token token = get_token(token_stream, *token_idx);
        UNUSED(token);
        assert(token.type == ARRAY_OPEN);
        NEXT_TOKEN(token_idx); /** Skip '[' */

        vec_create(&array->elements.elements, sizeof(json_element), 250);
        if (!parse_elements(&array->elements, token_stream, token_idx)) {
                return false;
        }

        NEXT_TOKEN(token_idx); /** Skip ']' */
        return true;
}

static void parse_string(json_string *string, vec ofType(json_token) *token_stream,
                         size_t *token_idx)
{
        json_token token = get_token(token_stream, *token_idx);
        assert(token.type == LITERAL_STRING);

        string->value = MALLOC(token.length + 1);
        if (LIKELY(token.length > 0)) {
                strncpy(string->value, token.string, token.length);
        }
        string->value[token.length] = '\0';
        NEXT_TOKEN(token_idx);
}

static void parse_number(json_number *number, vec ofType(json_token) *token_stream,
                         size_t *token_idx)
{
        json_token token = get_token(token_stream, *token_idx);
        assert(token.type == LITERAL_FLOAT || token.type == LITERAL_INT);

        char *value = MALLOC(token.length + 1);
        strncpy(value, token.string, token.length);
        value[token.length] = '\0';

        if (token.type == LITERAL_INT) {
                i64 assumeSigned = convert_atoi64(value);
                if (value[0] == '-') {
                        number->value_type = JSON_NUMBER_SIGNED;
                        number->value.signed_integer = assumeSigned;
                } else {
                        u64 assumeUnsigned = convert_atoiu64(value);
                        if (assumeUnsigned >= (u64) assumeSigned) {
                                number->value_type = JSON_NUMBER_UNSIGNED;
                                number->value.unsigned_integer = assumeUnsigned;
                        } else {
                                number->value_type = JSON_NUMBER_SIGNED;
                                number->value.signed_integer = assumeSigned;
                        }
                }
        } else {
                number->value_type = JSON_NUMBER_FLOAT;
                setlocale(LC_ALL | ~LC_NUMERIC, "");
                number->value.float_number = strtof(value, NULL);
        }

        free(value);
        NEXT_TOKEN(token_idx);
}

static bool parse_element(json_element *element, vec ofType(json_token) *token_stream, size_t *token_idx)
{
        if (!has_next_token(*token_idx, token_stream)) {
                return false;
        }
        json_token token = get_token(token_stream, *token_idx);

        if (token.type == OBJECT_OPEN) { /** Parse object */
                element->value.value_type = JSON_VALUE_OBJECT;
                element->value.value.object = MALLOC(sizeof(json_object));
                if (!parse_object(element->value.value.object, token_stream, token_idx)) {
                        return false;
                }
        } else if (token.type == ARRAY_OPEN) { /** Parse array */
                element->value.value_type = JSON_VALUE_ARRAY;
                element->value.value.array = MALLOC(sizeof(json_array));
                if (!parse_array(element->value.value.array, token_stream, token_idx)) {
                        return false;
                }
        } else if (token.type == LITERAL_STRING) { /** Parse string */
                element->value.value_type = JSON_VALUE_STRING;
                element->value.value.string = MALLOC(sizeof(json_string));
                parse_string(element->value.value.string, token_stream, token_idx);
        } else if (token.type == LITERAL_FLOAT || token.type == LITERAL_INT) { /** Parse number */
                element->value.value_type = JSON_VALUE_NUMBER;
                element->value.value.number = MALLOC(sizeof(json_number));
                parse_number(element->value.value.number, token_stream, token_idx);
        } else if (token.type == LITERAL_TRUE) {
                element->value.value_type = JSON_VALUE_TRUE;
                NEXT_TOKEN(token_idx);
        } else if (token.type == LITERAL_FALSE) {
                element->value.value_type = JSON_VALUE_FALSE;
                NEXT_TOKEN(token_idx);
        } else if (token.type == LITERAL_NULL) {
                element->value.value_type = JSON_VALUE_NULL;
                NEXT_TOKEN(token_idx);
        } else {
                element->value.value_type = JSON_VALUE_NULL;
        }
        return true;
}

static bool parse_elements(json_elements *elements, vec ofType(json_token) *token_stream, size_t *token_idx)
{
        json_token delimiter;
        do {
                json_token current = get_token(token_stream, *token_idx);
                if (current.type != ARRAY_CLOSE && current.type != OBJECT_CLOSE) {
                        if (!parse_element(VEC_NEW_AND_GET(&elements->elements, json_element),
                                           token_stream,
                                           token_idx)) {
                                return false;
                        }
                }
                delimiter = get_token(token_stream, *token_idx);
                NEXT_TOKEN(token_idx);
        } while (delimiter.type == COMMA);
        PREV_TOKEN(token_idx);
        return true;
}

static bool parse_token_stream(json *json, vec ofType(json_token) *token_stream)
{
        size_t token_idx = 0;
        if (!parse_element(json->element, token_stream, &token_idx)) {
                return false;
        }
        connect_child_and_parents(json);
        return true;
}

static void connect_child_and_parents_member(json_prop *member)
{
        connect_child_and_parents_element(&member->value);
}

static void connect_child_and_parents_object(json_object *object)
{
        object->value->parent = object;
        for (size_t i = 0; i < object->value->members.num_elems; i++) {
                json_prop *member = VEC_GET(&object->value->members, i, json_prop);
                member->parent = object->value;

                member->key.parent = member;

                member->value.parent_type = JSON_PARENT_MEMBER;
                member->value.parent.member = member;

                connect_child_and_parents_member(member);
        }
}

static void connect_child_and_parents_array(json_array *array)
{
        array->elements.parent = array;
        for (size_t i = 0; i < array->elements.elements.num_elems; i++) {
                json_element *element = VEC_GET(&array->elements.elements, i, json_element);
                element->parent_type = JSON_PARENT_ELEMENTS;
                element->parent.elements = &array->elements;
                connect_child_and_parents_element(element);
        }
}

static void connect_child_and_parents_value(json_node_value *value)
{
        switch (value->value_type) {
                case JSON_VALUE_OBJECT:
                        connect_child_and_parents_object(value->value.object);
                        break;
                case JSON_VALUE_ARRAY:
                        connect_child_and_parents_array(value->value.array);
                        break;
                default:
                        break;
        }
}

static void connect_child_and_parents_element(json_element *element)
{
        element->value.parent = element;
        connect_child_and_parents_value(&element->value);
}

static void connect_child_and_parents(json *json)
{
        json->element->parent_type = JSON_PARENT_OBJECT;
        json->element->parent.json = json;
        connect_child_and_parents_element(json->element);
}

static bool isValue(json_token_e token)
{
        return (token == LITERAL_STRING || token == LITERAL_FLOAT || token == LITERAL_INT || token == LITERAL_TRUE
                || token == LITERAL_FALSE || token == LITERAL_NULL);
}

static int process_token(json_err *error_desc, const json_token *token,
                         vec ofType(json_token_e) *brackets, struct token_memory *token_mem)
{
        switch (token->type) {
                case OBJECT_OPEN:
                case ARRAY_OPEN:
                        vec_push(brackets, &token->type, 1);
                        break;
                case OBJECT_CLOSE:
                case ARRAY_CLOSE: {
                        if (!vec_is_empty(brackets)) {
                                json_token_e bracket = *VEC_PEEK(brackets, json_token_e);
                                if ((token->type == ARRAY_CLOSE && bracket == ARRAY_OPEN)
                                    || (token->type == OBJECT_CLOSE && bracket == OBJECT_OPEN)) {
                                        vec_pop(brackets);
                                } else {
                                        goto pushEntry;
                                }
                        } else {
                                pushEntry:
                                vec_push(brackets, &token->type, 1);
                        }
                }
                        break;
                default:
                        break;
        }

        switch (token_mem->type) {
                case OBJECT_OPEN:
                        switch (token->type) {
                                case LITERAL_STRING:
                                case OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token, "Expected key name or '}'");
                        }
                        break;
                case LITERAL_STRING:
                        switch (token->type) {
                                case ASSIGN:
                                case COMMA:
                                case ARRAY_CLOSE:
                                case OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "Expected key name (missing ':'), enumeration (','), "
                                                         "end of enumeration (']'), or end of object ('}')");
                        }
                        break;
                case OBJECT_CLOSE:
                case LITERAL_INT:
                case LITERAL_FLOAT:
                case LITERAL_TRUE:
                case LITERAL_FALSE:
                case LITERAL_NULL:
                        switch (token->type) {
                                case COMMA:
                                case ARRAY_CLOSE:
                                case OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "Expected enumeration (','), end of enumeration (']'), "
                                                         "or end of object ('})");
                        }
                        break;
                case ASSIGN:
                case COMMA:
                        switch (token->type) {
                                case LITERAL_STRING:
                                case LITERAL_FLOAT:
                                case LITERAL_INT:
                                case OBJECT_OPEN:
                                case ARRAY_OPEN:
                                case LITERAL_TRUE:
                                case LITERAL_FALSE:
                                case LITERAL_NULL:
                                        break;
                                default:
                                        return set_error(error_desc,
                                                         token,
                                                         "Expected key name, or value (str_buf, number, object, enumeration, true, "
                                                         "false, or null).");
                        }
                        break;
                case ARRAY_OPEN:
                        switch (token->type) {
                                case ARRAY_CLOSE:
                                case LITERAL_STRING:
                                case LITERAL_FLOAT:
                                case LITERAL_INT:
                                case OBJECT_OPEN:
                                case ARRAY_OPEN:
                                case LITERAL_TRUE:
                                case LITERAL_FALSE:
                                case LITERAL_NULL:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "End of enumeration (']'), enumeration (','), or "
                                                         "end of enumeration (']')");
                        }
                        break;
                case ARRAY_CLOSE:
                        switch (token->type) {
                                case COMMA:
                                case ARRAY_CLOSE:
                                case OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "End of enumeration (']'), enumeration (','), or "
                                                         "end of object ('}')");
                        }
                        break;
                case JSON_UNKNOWN:
                        if (token_mem->init) {
                                if (token->type != OBJECT_OPEN && token->type != ARRAY_OPEN && !isValue(token->type)) {
                                        return set_error(error_desc, token,
                                                         "Expected JSON document: missing '{' or '['");
                                }
                                token_mem->init = false;
                        } else {
                                return set_error(error_desc, token, "Unexpected token");
                        }
                        break;
                default:
                        return ERROR(ERR_NOJSONTOKEN, NULL);
        }

        token_mem->type = token->type;
        return true;
}

static int set_error(json_err *error_desc, const json_token *token, const char *msg)
{
        if (error_desc) {
                error_desc->token = token;
                error_desc->token_type_str = token ? JSON_TOKEN_STRINGS[token->type].string : "(no token)";
                error_desc->msg = msg;
        }
        return false;
}

static bool json_ast_node_member_print(FILE *file, json_prop *member)
{
        fprintf(file, "\"%s\": ", member->key.value);
        return json_ast_node_value_print(file, &member->value.value);
}

static bool json_ast_node_object_print(FILE *file, json_object *object)
{
        fprintf(file, "{");
        for (size_t i = 0; i < object->value->members.num_elems; i++) {
                json_prop *member = VEC_GET(&object->value->members, i, json_prop);
                if (!json_ast_node_member_print(file, member)) {
                        return false;
                }
                fprintf(file, "%s", i + 1 < object->value->members.num_elems ? ", " : "");
        }
        fprintf(file, "}");
        return true;
}

static bool json_ast_node_array_print(FILE *file, json_array *array)
{
        fprintf(file, "[");
        for (size_t i = 0; i < array->elements.elements.num_elems; i++) {
                json_element *element = VEC_GET(&array->elements.elements, i, json_element);
                if (!json_ast_node_element_print(file, element)) {
                        return false;
                }
                fprintf(file, "%s", i + 1 < array->elements.elements.num_elems ? ", " : "");
        }
        fprintf(file, "]");
        return true;
}

static void json_ast_node_string_print(FILE *file, json_string *string)
{
        fprintf(file, "\"%s\"", string->value);
}

static bool json_ast_node_number_print(FILE *file, json_number *number)
{
        switch (number->value_type) {
                case JSON_NUMBER_FLOAT:
                        fprintf(file, "%f", number->value.float_number);
                        break;
                case JSON_NUMBER_UNSIGNED:
                        fprintf(file, "%" PRIu64, number->value.unsigned_integer);
                        break;
                case JSON_NUMBER_SIGNED:
                        fprintf(file, "%" PRIi64, number->value.signed_integer);
                        break;
                default: ERROR(ERR_NOJSONNUMBERT, NULL);
                        return false;
        }
        return true;
}

static bool json_ast_node_value_print(FILE *file, json_node_value *value)
{
        switch (value->value_type) {
                case JSON_VALUE_OBJECT:
                        if (!json_ast_node_object_print(file, value->value.object)) {
                                return false;
                        }
                        break;
                case JSON_VALUE_ARRAY:
                        if (!json_ast_node_array_print(file, value->value.array)) {
                                return false;
                        }
                        break;
                case JSON_VALUE_STRING:
                        json_ast_node_string_print(file, value->value.string);
                        break;
                case JSON_VALUE_NUMBER:
                        if (!json_ast_node_number_print(file, value->value.number)) {
                                return false;
                        }
                        break;
                case JSON_VALUE_TRUE:
                        fprintf(file, "true");
                        break;
                case JSON_VALUE_FALSE:
                        fprintf(file, "false");
                        break;
                case JSON_VALUE_NULL:
                        fprintf(file, "null");
                        break;
                default: ERROR(ERR_NOTYPE, NULL);
                        return false;
        }
        return true;
}

static bool json_ast_node_element_print(FILE *file, json_element *element)
{
        return json_ast_node_value_print(file, &element->value);
}

static bool json_ast_node_value_drop(json_node_value *value);

static bool json_ast_node_element_drop(json_element *element)
{
        return json_ast_node_value_drop(&element->value);
}

static bool json_ast_node_member_drop(json_prop *member)
{
        free(member->key.value);
        return json_ast_node_element_drop(&member->value);
}

static bool json_ast_node_members_drop(json_members *members)
{
        for (size_t i = 0; i < members->members.num_elems; i++) {
                json_prop *member = VEC_GET(&members->members, i, json_prop);
                if (!json_ast_node_member_drop(member)) {
                        return false;
                }
        }
        vec_drop(&members->members);
        return true;
}

static bool json_ast_node_elements_drop(json_elements *elements)
{
        for (size_t i = 0; i < elements->elements.num_elems; i++) {
                json_element *element = VEC_GET(&elements->elements, i, json_element);
                if (!json_ast_node_element_drop(element)) {
                        return false;
                }
        }
        vec_drop(&elements->elements);
        return true;
}

static bool json_ast_node_object_drop(json_object *object)
{
        if (!json_ast_node_members_drop(object->value)) {
                return false;
        } else {
                free(object->value);
                return true;
        }
}

static bool json_ast_node_array_drop(json_array *array)
{
        return json_ast_node_elements_drop(&array->elements);
}

static void json_ast_node_string_drop(json_string *string)
{
        free(string->value);
}

static void json_ast_node_number_drop(json_number *number)
{
        UNUSED(number);
}

static bool json_ast_node_value_drop(json_node_value *value)
{
        switch (value->value_type) {
                case JSON_VALUE_OBJECT:
                        if (!json_ast_node_object_drop(value->value.object)) {
                                return false;
                        } else {
                                free(value->value.object);
                        }
                        break;
                case JSON_VALUE_ARRAY:
                        if (!json_ast_node_array_drop(value->value.array)) {
                                return false;
                        } else {
                                free(value->value.array);
                        }
                        break;
                case JSON_VALUE_STRING:
                        json_ast_node_string_drop(value->value.string);
                        free(value->value.string);
                        break;
                case JSON_VALUE_NUMBER:
                        json_ast_node_number_drop(value->value.number);
                        free(value->value.number);
                        break;
                case JSON_VALUE_TRUE:
                case JSON_VALUE_FALSE:
                case JSON_VALUE_NULL:
                        break;
                default:
                        return ERROR(ERR_NOTYPE, NULL);

        }
        return true;
}

bool json_drop(json *json)
{
        json_element *element = json->element;
        if (!json_ast_node_value_drop(&element->value)) {
                return false;
        } else {
                free(json->element);
                return true;
        }
}

bool json_print(FILE *file, json *json)
{
        return json_ast_node_element_print(file, json->element);
}

bool json_list_is_empty(const json_elements *elements)
{
        return elements->elements.num_elems == 0;
}

bool json_list_length(u32 *len, const json_elements *elements)
{
        *len = elements->elements.num_elems;
        return true;
}

json_list_type_e json_fitting_type(json_list_type_e current, json_list_type_e to_add)
{
        if (current == JSON_LIST_VARIABLE_OR_NESTED || to_add == JSON_LIST_VARIABLE_OR_NESTED) {
                return JSON_LIST_VARIABLE_OR_NESTED;
        }
        if (current == JSON_LIST_EMPTY || current == JSON_LIST_FIXED_BOOLEAN ||
            to_add == JSON_LIST_EMPTY || to_add == JSON_LIST_FIXED_BOOLEAN) {
                if (current == to_add) {
                        return current;
                } else {
                        if ((to_add == JSON_LIST_FIXED_BOOLEAN && current == JSON_LIST_FIXED_NULL) ||
                            (to_add == JSON_LIST_FIXED_NULL && current == JSON_LIST_FIXED_BOOLEAN)) {
                                return JSON_LIST_FIXED_BOOLEAN;
                        } else {
                                if (to_add == JSON_LIST_EMPTY) {
                                        return current;
                                } else if (current == JSON_LIST_EMPTY) {
                                        return to_add;
                                } else {

                                        return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        }
                }
        } else {
                switch (current) {
                        case JSON_LIST_FIXED_NULL:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                        case JSON_LIST_FIXED_FLOAT:
                                        case JSON_LIST_FIXED_BOOLEAN:
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                        case JSON_LIST_FIXED_U32:
                                        case JSON_LIST_FIXED_U64:
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                        case JSON_LIST_FIXED_I32:
                                        case JSON_LIST_FIXED_I64:
                                                return to_add;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_FLOAT:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                        case JSON_LIST_FIXED_FLOAT:
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                        case JSON_LIST_FIXED_U32:
                                        case JSON_LIST_FIXED_U64:
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                        case JSON_LIST_FIXED_I32:
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_FIXED_FLOAT;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_U8:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_U8;
                                        case JSON_LIST_FIXED_U8:
                                                return JSON_LIST_FIXED_U8;
                                        case JSON_LIST_FIXED_U16:
                                                return JSON_LIST_FIXED_U16;
                                        case JSON_LIST_FIXED_U32:
                                                return JSON_LIST_FIXED_U32;
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_FIXED_U64;
                                        case JSON_LIST_FIXED_I8:
                                                return JSON_LIST_FIXED_I16;
                                        case JSON_LIST_FIXED_I16:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_I32:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_U16:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_U16;
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                                return JSON_LIST_FIXED_U16;
                                        case JSON_LIST_FIXED_U32:
                                                return JSON_LIST_FIXED_U32;
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_FIXED_U64;
                                        case JSON_LIST_FIXED_I8:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_I16:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_I32:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_U32:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_U32;
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                        case JSON_LIST_FIXED_U32:
                                                return JSON_LIST_FIXED_U32;
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_FIXED_U64;
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                        case JSON_LIST_FIXED_I32:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_U64:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_U64;
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                        case JSON_LIST_FIXED_U32:
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_FIXED_U64;
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                        case JSON_LIST_FIXED_I32:
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_I8:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_I8;
                                        case JSON_LIST_FIXED_U8:
                                                return JSON_LIST_FIXED_I16;
                                        case JSON_LIST_FIXED_U16:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_U32:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        case JSON_LIST_FIXED_I8:
                                                return JSON_LIST_FIXED_I8;
                                        case JSON_LIST_FIXED_I16:
                                                return JSON_LIST_FIXED_I16;
                                        case JSON_LIST_FIXED_I32:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_FIXED_I64;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_I16:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_I16;
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_U32:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                                return JSON_LIST_FIXED_I16;
                                        case JSON_LIST_FIXED_I32:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_FIXED_I64;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_I32:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                        case JSON_LIST_FIXED_U32:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                        case JSON_LIST_FIXED_I32:
                                                return JSON_LIST_FIXED_I32;
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_FIXED_I64;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JSON_LIST_FIXED_I64:
                                switch (to_add) {
                                        case JSON_LIST_FIXED_NULL:
                                                return JSON_LIST_FIXED_I64;
                                        case JSON_LIST_FIXED_U8:
                                        case JSON_LIST_FIXED_U16:
                                        case JSON_LIST_FIXED_U32:
                                        case JSON_LIST_FIXED_U64:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                        case JSON_LIST_FIXED_I8:
                                        case JSON_LIST_FIXED_I16:
                                        case JSON_LIST_FIXED_I32:
                                        case JSON_LIST_FIXED_I64:
                                                return JSON_LIST_FIXED_I64;
                                        default:
                                                return JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        default:
                                return JSON_LIST_VARIABLE_OR_NESTED;
                }
        }
}

static json_list_type_e number_type_to_list_type(num_type_e type)
{
        switch (type) {
                case NUM_U8:
                        return JSON_LIST_FIXED_U8;
                case NUM_U16:
                        return JSON_LIST_FIXED_U16;
                case NUM_U32:
                        return JSON_LIST_FIXED_U32;
                case NUM_U64:
                        return JSON_LIST_FIXED_U64;
                case NUM_I8:
                        return JSON_LIST_FIXED_I8;
                case NUM_I16:
                        return JSON_LIST_FIXED_I16;
                case NUM_I32:
                        return JSON_LIST_FIXED_I32;
                case NUM_I64:
                        return JSON_LIST_FIXED_I64;
                default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                        return JSON_LIST_EMPTY;

        }
}

bool json_array_get_type(json_list_type_e *type, const json_array *array)
{
        json_list_type_e list_type = JSON_LIST_EMPTY;
        for (u32 i = 0; i < array->elements.elements.num_elems; i++) {
                const json_element *elem = VEC_GET(&array->elements.elements, i, json_element);
                switch (elem->value.value_type) {
                        case JSON_VALUE_OBJECT:
                        case JSON_VALUE_ARRAY:
                        case JSON_VALUE_STRING:
                                list_type = JSON_LIST_VARIABLE_OR_NESTED;
                                goto return_result;
                        case JSON_VALUE_NUMBER: {
                                json_list_type_e elem_type;
                                switch (elem->value.value.number->value_type) {
                                        case JSON_NUMBER_FLOAT:
                                                elem_type = JSON_LIST_FIXED_FLOAT;
                                                break;
                                        case JSON_NUMBER_UNSIGNED:
                                                elem_type = number_type_to_list_type(num_min_type_unsigned(
                                                        elem->value.value.number->value.unsigned_integer));
                                                break;
                                        case JSON_NUMBER_SIGNED:
                                                elem_type = number_type_to_list_type(num_min_type_signed(
                                                        elem->value.value.number->value.signed_integer));
                                                break;
                                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                                continue;
                                }

                                list_type = json_fitting_type(list_type, elem_type);
                                if (list_type == JSON_LIST_VARIABLE_OR_NESTED) {
                                        goto return_result;
                                }
                                break;
                        }
                        case JSON_VALUE_TRUE:
                        case JSON_VALUE_FALSE:
                                list_type = json_fitting_type(list_type, JSON_LIST_FIXED_BOOLEAN);
                                if (list_type == JSON_LIST_VARIABLE_OR_NESTED) {
                                        goto return_result;
                                }
                                break;
                        case JSON_VALUE_NULL:
                                list_type = json_fitting_type(list_type, JSON_LIST_FIXED_NULL);
                                if (list_type == JSON_LIST_VARIABLE_OR_NESTED) {
                                        goto return_result;
                                }
                                break;
                        default: ERROR(ERR_UNSUPPORTEDTYPE, NULL);
                                break;
                }
        }
        return_result:
        *type = list_type;
        return true;

}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements the document format itself
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <inttypes.h>

#include <karbonit/forwdecl.h>
#include <karbonit/std/uintvar/stream.h>
#include <karbonit/rec.h>
#include <karbonit/carbon/arr-it.h>
#include <karbonit/carbon/col-it.h>
#include <karbonit/carbon/obj-it.h>
#include <karbonit/carbon/internal.h>
#include <karbonit/carbon/dot.h>
#include <karbonit/carbon/find.h>
#include <karbonit/carbon/insert.h>
#include <karbonit/carbon/revise.h>
#include <karbonit/carbon/string-field.h>
#include <karbonit/carbon/key.h>
#include <karbonit/carbon/commit.h>
#include <karbonit/carbon/patch.h>
#include <karbonit/json.h>

#define MIN_DOC_CAPACITY 17 /** minimum number of bytes required to store header and empty document array */

static bool internal_drop(rec *doc);

static void carbon_header_init(rec *doc, key_e rec_key_type);

// ---------------------------------------------------------------------------------------------------------------------

insert * rec_create_begin(rec_new *context, rec *doc,
                                           key_e type, int options)
{
        return rec_create_begin_ex(context, doc, type, options, 1024);
}

insert *rec_create_begin_ex(rec_new *context, rec *doc, key_e type, int options, u64 doc_capacity_nbyte)
{
        if (context && doc) {
                context->array = MALLOC(sizeof(arr_it));
                context->in = MALLOC(sizeof(insert));
                context->mode = options;

                /** get the annotation type for that records outer-most array from options*/
                list_type_e derivation;

                if (context->mode & SORTED_MULTISET) {
                        derivation = LIST_SORTED_MULTISET;
                } else if (context->mode & UNSORTED_SET) {
                        derivation = LIST_UNSORTED_SET;
                } else if (context->mode & SORTED_SET) {
                        derivation = LIST_SORTED_SET;
                } else { /** UNSORTED_MULTISET is default */
                        derivation = LIST_UNSORTED_MULTISET;
                }

                rec_create_empty(&context->original, derivation, type, doc_capacity_nbyte);
                revise_begin(&context->context, doc, &context->original);
                if (!revise_iterator_open(context->array, &context->context)) {
                        ERROR(ERR_OPPFAILED, "cannot open revision iterator");
                        return NULL;
                }
                arr_it_insert_begin(context->in, context->array);
                return context->in;
        } else {
                return NULL;
        }
}

void rec_create_end(rec_new *context)
{
        arr_it_insert_end(context->in);
        if (context->mode & COMPACT) {
                revise_pack(&context->context);
        }
        if (context->mode & SHRINK) {
                revise_shrink(&context->context);
        }
        revise_end(&context->context);
        free(context->array);
        free(context->in);
        rec_drop(&context->original);
}

void rec_create_empty(rec *doc, list_type_e derivation, key_e type, u64 doc_capacity_nbyte)
{
        rec_create_empty_ex(doc, derivation, type, doc_capacity_nbyte, 1);
}

void rec_create_empty_ex(rec *doc, list_type_e derivation, key_e type,
                                u64 doc_cap, u64 array_cap)
{
        doc_cap = JAK_MAX(MIN_DOC_CAPACITY, doc_cap);

        MEMBLOCK_CREATE(&doc->block, doc_cap);
        MEMBLOCK_ZERO_OUT(doc->block);
        MEMFILE_OPEN(&doc->file, doc->block, READ_WRITE);

        carbon_header_init(doc, type);
        doc->data_off = MEMFILE_TELL(&doc->file);
        internal_insert_array(&doc->file, derivation, array_cap);
}

bool rec_from_json(rec *doc, const char *json, key_e type,
                      const void *key, int mode)
{
        struct json data;
        json_err status;
        json_parser parser;

        if (!(json_parse(&data, &status, &parser, json))) {
                ERROR(ERR_JSONPARSEERR, "parsing JSON file failed");
                return false;
        } else {
                /* Note that the plain-text JSON size is upper bound for document size.
                 * Approx the maximum doc size leads to less reallocations. */
                internal_from_json(doc, &data, type, key, mode, strlen(json));
                json_drop(&data);
                return true;
        }
}

bool rec_from_raw_data(rec *doc, const void *data, u64 len)
{
        MEMBLOCK_FROM_RAW_DATA(&doc->block, data, len);
        MEMFILE_OPEN(&doc->file, doc->block, READ_WRITE);

        return true;
}

bool rec_drop(rec *doc)
{
        return internal_drop(doc);
}

const void *rec_raw_data(u64 *len, rec *doc)
{
        if (len && doc) {
                MEMBLOCK_SIZE(len, doc->file.memblock);
                return MEMBLOCK_RAW_DATA(doc->file.memblock);
        } else {
                return NULL;
        }
}

bool rec_key_type(key_e *out, rec *doc)
{
        MEMFILE_SAVE_POSITION(&doc->file);
        key_skip(out, &doc->file);
        MEMFILE_RESTORE_POSITION(&doc->file);
        return true;
}

const void *rec_key_raw_value(u64 *len, key_e *type, rec *doc)
{
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);
        const void *result = key_read(len, type, &doc->file);
        MEMFILE_RESTORE_POSITION(&doc->file);
        return result;
}

bool rec_key_signed_value(i64 *key, rec *doc)
{
        key_e type;
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);
        const void *result = key_read(NULL, &type, &doc->file);
        MEMFILE_RESTORE_POSITION(&doc->file);
        if (LIKELY(rec_key_is_signed(type))) {
                *key = *((const i64 *) result);
                return true;
        } else {
                ERROR(ERR_TYPEMISMATCH, NULL);
                return false;
        }
}

bool rec_key_unsigned_value(u64 *key, rec *doc)
{
        key_e type;
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);
        const void *result = key_read(NULL, &type, &doc->file);
        MEMFILE_RESTORE_POSITION(&doc->file);
        if (LIKELY(rec_key_is_unsigned(type))) {
                *key = *((const u64 *) result);
                return true;
        } else {
                ERROR(ERR_TYPEMISMATCH, NULL);
                return false;
        }
}

const char *key_string_value(u64 *len, rec *doc)
{
        key_e type;
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);
        const void *result = key_read(len, &type, &doc->file);
        MEMFILE_RESTORE_POSITION(&doc->file);
        if (LIKELY(rec_key_is_string(type))) {
                return result;
        } else {
                ERROR(ERR_TYPEMISMATCH, NULL);
                return false;
        }
}

bool rec_key_is_unsigned(key_e type)
{
        return type == KEY_UKEY || type == KEY_AUTOKEY;
}

bool rec_key_is_signed(key_e type)
{
        return type == KEY_IKEY;
}

bool rec_key_is_string(key_e type)
{
        return type == KEY_SKEY;
}

bool rec_has_key(key_e type)
{
        return type != KEY_NOKEY;
}

void rec_clone(rec *clone, rec *doc)
{
        MEMBLOCK_CPY(&clone->block, doc->block);
        MEMFILE_OPEN(&clone->file, clone->block, READ_WRITE);
        clone->data_off = doc->data_off;
}

bool rec_commit_hash(u64 *hash, rec *doc)
{
        *hash = internal_header_get_commit_hash(doc);
        return true;
}

void internal_rec_get_first(memfile *file, rec *doc)
{
        MEMFILE_OPEN(file, doc->file.memblock, READ_WRITE);
        MEMFILE_SEEK__UNSAFE(file, INTERNAL_PAYLOAD_AFTER_HEADER(doc));
}

bool rec_is_multiset(rec *doc)
{
        arr_it it;
        rec_read(&it, doc);
        bool ret = arr_it_is_multiset(&it);
        return ret;
}

bool rec_is_sorted(rec *doc)
{
        arr_it it;
        rec_read(&it, doc);
        bool ret = arr_it_is_sorted(&it);
        return ret;
}

void rec_update_list_type(rec *revised, rec *doc, list_type_e derivation)
{
        rev context;
        revise_begin(&context, revised, doc);
        revise_set_list_type(&context, derivation);
        revise_end(&context);
}

const char *rec_to_json(str_buf *dst, rec *doc)
{
        return json_from_record(dst, doc);
}

inline void rec_read(arr_it *it, rec *doc)
{
        patch(it, doc);
        INTERNAL_ARR_IT_SET_MODE(it, READ_ONLY);
}

bool rec_is_array(const rec *doc)
{
        arr_it it;
        rec_read(&it, (rec *) doc);
        bool ret = !arr_it_is_unit(&it);
        return ret;
}

bool rec_hexdump_print(FILE *file, rec *doc)
{
        MEMFILE_SAVE_POSITION(&doc->file);
        MEMFILE_SEEK(&doc->file, 0);
        bool status = hexdump_print(file, MEMFILE_PEEK(&doc->file, 1), MEMFILE_SIZE(&doc->file));
        MEMFILE_RESTORE_POSITION(&doc->file);
        return status;
}

// ---------------------------------------------------------------------------------------------------------------------

static bool internal_drop(rec *doc)
{
        assert(doc);
        MEMBLOCK_DROP(doc->block);
        return true;
}

static void carbon_header_init(rec *doc, key_e rec_key_type)
{
        assert(doc);

        MEMFILE_SEEK(&doc->file, 0);
        key_create(&doc->file, rec_key_type);

        if (rec_key_type != KEY_NOKEY) {
                commit_create(&doc->file);
        }
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/std/async.h>

void *async_for_proxy_function(void *args)
{
        CAST(async_func_proxy *, proxy_arg, args);
        proxy_arg->function(proxy_arg->start, proxy_arg->width, proxy_arg->len, proxy_arg->args, proxy_arg->tid);
        return NULL;
}

#define PARALLEL_ERROR(msg, retval)                                                                             \
{                                                                                                                      \
    perror(msg);                                                                                                       \
    return retval;                                                                                                     \
}

#define ASYNC_MATCH(forSingle, forMulti)                                                                            \
{                                                                                                                      \
    if (LIKELY(hint == THREADING_HINT_MULTI)) {                                             \
        return (forMulti);                                                                                             \
    } else if (hint == THREADING_HINT_SINGLE) {                                                           \
        return (forSingle);                                                                                            \
    } else PARALLEL_ERROR(ASYNC_MSG_UNKNOWN_HINT, false);                                                    \
}

bool foreach(const void *base, size_t width, size_t len, for_body_func_t f, void *args,
             threading_hint hint, uint_fast16_t num_threads);

bool map(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
             map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);

bool gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len,
                threading_hint hint, uint_fast16_t num_threads);

bool gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num,
                    threading_hint hint, uint_fast16_t num_threads);

bool scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                 threading_hint hint, uint_fast16_t num_threads);

bool shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                 const size_t *src_idx, size_t idxLen, threading_hint hint);

bool filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len,
                      pred_func_t pred, void *args, threading_hint hint,
                      uint_fast16_t num_threads);

bool filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                     pred_func_t pred, void *args, threading_hint hint, size_t num_threads);

bool sync_for(const void *base, size_t width, size_t len, for_body_func_t f,
                  void *args);

bool async_for(const void *base, size_t width, size_t len, for_body_func_t f,
                   void *args, uint_fast16_t num_threads);

bool async_map_exec(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
                        map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);

bool sync_gather(void *dst, const void *src, size_t width, const size_t *idx,
                     size_t dst_src_len);

bool async_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len,
                      uint_fast16_t num_threads);

bool sync_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx,
                         size_t num);

bool int_async_gather_adr_func(void *dst, const void *src, size_t src_width, const size_t *idx,
                                   size_t num, uint_fast16_t num_threads);

bool sync_scatter(void *dst, const void *src, size_t width, const size_t *idx,
                      size_t num);

bool sync_scatter_func(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                           uint_fast16_t num_threads);

bool sync_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                      const size_t *src_idx, size_t idx_len);

bool async_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                       const size_t *src_idx, size_t idx_len);

bool async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                            size_t len, pred_func_t pred, void *args);

bool int_async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                                size_t len, pred_func_t pred, void *args, uint_fast16_t num_threads);

bool int_sync_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width,
                              size_t len, pred_func_t pred, void *args);

bool async_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                           pred_func_t pred, void *args, size_t num_threads);

bool foreach(const void *base, size_t width, size_t len, for_body_func_t f, void *args,
             threading_hint hint, uint_fast16_t num_threads)
{
        ASYNC_MATCH(sync_for(base, width, len, f, args),
                        async_for(base, width, len, f, args, num_threads))
}

bool map(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
             map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads)
{
        return async_map_exec(dst, src, src_width, len, dst_width, f, args, hint, num_threads);
}

bool gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len,
                threading_hint hint, uint_fast16_t num_threads)
{
        ASYNC_MATCH(sync_gather(dst, src, width, idx, dst_src_len),
                        async_gather(dst, src, width, idx, dst_src_len, num_threads))
}

bool gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num,
                    threading_hint hint, uint_fast16_t num_threads)
{
        ASYNC_MATCH(sync_gather_adr(dst, src, src_width, idx, num),
                        int_async_gather_adr_func(dst, src, src_width, idx, num, num_threads))
}

bool scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                 threading_hint hint, uint_fast16_t num_threads)
{
        ASYNC_MATCH(sync_scatter(dst, src, width, idx, num),
                        sync_scatter_func(dst, src, width, idx, num, num_threads))
}

bool shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                 const size_t *src_idx, size_t idx_len, threading_hint hint)
{
        ASYNC_MATCH(sync_shuffle(dst, src, width, dst_idx, src_idx, idx_len),
                        async_shuffle(dst, src, width, dst_idx, src_idx, idx_len))
}

bool filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len,
                      pred_func_t pred, void *args, threading_hint hint,
                      uint_fast16_t num_threads)
{
        ASYNC_MATCH(async_filter_early(result, result_size, src, width, len, pred, args),
                        int_async_filter_early(result, result_size, src, width, len, pred, args, num_threads))
}

bool filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                     pred_func_t pred, void *args, threading_hint hint, size_t num_threads)
{
        ASYNC_MATCH(int_sync_filter_late(pos, num_pos, src, width, len, pred, args),
                        async_filter_late(pos, num_pos, src, width, len, pred, args, num_threads))
}

bool sync_for(const void *base, size_t width, size_t len, for_body_func_t f,
                  void *args)
{
        f(base, width, len, args, 0);
        return true;
}

bool async_for(const void *base, size_t width, size_t len, for_body_func_t f,
                   void *args, uint_fast16_t num_threads)
{
        if (len > 0) {
                uint_fast16_t num_thread = num_threads + 1; /** +1 since one is this thread */
                pthread_t threads[num_threads];
                async_func_proxy proxyArgs[num_thread];
                size_t chunk_len = len / num_thread;
                size_t chunk_len_remain = len % num_thread;
                const void *main_thread_base = base + num_threads * chunk_len * width;

                PREFETCH_READ(f);
                PREFETCH_READ(args);

                /** run f on NTHREADS_FOR additional threads */
                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        async_func_proxy *proxy_arg = proxyArgs + tid;
                        proxy_arg->start = base + tid * chunk_len * width;
                        proxy_arg->len = chunk_len;
                        proxy_arg->tid = (tid + 1);
                        proxy_arg->width = width;
                        proxy_arg->args = args;
                        proxy_arg->function = f;

                        PREFETCH_READ(proxy_arg->start);
                        pthread_create(threads + tid, NULL, async_for_proxy_function, proxyArgs + tid);
                }
                /** run f on this thread */
                PREFETCH_READ(main_thread_base);
                f(main_thread_base, width, chunk_len + chunk_len_remain, args, 0);

                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        pthread_join(threads[tid], NULL);
                }
        }
        return true;
}

void map_proxy(const void *src, size_t src_width, size_t len, void *args, thread_id_t tid)
{
        UNUSED(tid);
        CAST(map_args *, mapArgs, args);
        size_t globalStart = (src - mapArgs->src) / src_width;

        PREFETCH_READ(mapArgs->src);
        PREFETCH_READ(mapArgs->args);
        PREFETCH_WRITE(mapArgs->dst);
        mapArgs->map_func(mapArgs->dst + globalStart * mapArgs->dst_width,
                          src,
                          src_width,
                          mapArgs->dst_width,
                          len,
                          mapArgs->args);
}

bool async_map_exec(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
                        map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads)
{
        PREFETCH_READ(f);
        PREFETCH_WRITE(dst);

        map_args mapArgs = {.args = args, .map_func = f, .dst = dst, .dst_width = dst_width, .src = src};

        return foreach((void *) src, src_width, len, &map_proxy, &mapArgs, hint, num_threads);
}

void int_async_gather(const void *start, size_t width, size_t len, void *args, thread_id_t tid)
{
        UNUSED(tid);
        CAST(gather_scatter_args *, gather_args, args);
        size_t global_index_start = (start - gather_args->dst) / width;

        PREFETCH_WRITE(gather_args->dst);
        PREFETCH_WRITE(gather_args->idx);
        PREFETCH_READ((len > 0) ? gather_args->src + gather_args->idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < len; next_i = ++i + 1) {
                size_t global_index_cur = global_index_start + i;
                size_t global_index_next = global_index_start + next_i;
                memcpy(gather_args->dst + global_index_cur * width,
                       gather_args->src + gather_args->idx[global_index_cur] * width,
                       width);

                bool has_next = (next_i < len);
                PREFETCH_READ(has_next ? gather_args->idx + global_index_next : NULL);
                PREFETCH_READ(has_next ? gather_args->src + gather_args->idx[global_index_next] * width : NULL);
                PREFETCH_WRITE(has_next ? gather_args->dst + global_index_next * width : NULL);
        }
}

bool sync_gather(void *dst, const void *src, size_t width, const size_t *idx,
                     size_t dst_src_len)
{
        PREFETCH_READ(src);
        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);

        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);
        PREFETCH_READ((dst_src_len > 0) ? src + idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < dst_src_len; next_i = ++i + 1) {
                memcpy(dst + i * width, src + idx[i] * width, width);

                bool has_next = (next_i < dst_src_len);
                PREFETCH_READ(has_next ? idx + next_i : NULL);
                PREFETCH_READ(has_next ? src + idx[next_i] * width : NULL);
                PREFETCH_WRITE(has_next ? dst + next_i * width : NULL);
        }

        return true;
}

bool async_gather(void *dst, const void *src, size_t width, const size_t *idx,
                      size_t dst_src_len, uint_fast16_t num_threads)
{
        PREFETCH_READ(src);
        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);

        gather_scatter_args args = {.idx           = idx, .src           = src, .dst           = dst,};
        return async_for(dst, width, dst_src_len, int_async_gather, &args, num_threads);
}

bool sync_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx,
                         size_t num)
{
        PREFETCH_READ(src);
        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);

        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);
        PREFETCH_READ(num > 0 ? src + idx[0] * src_width : NULL);

        for (register size_t i = 0, next_i = 1; i < num; next_i = ++i + 1) {
                const void *ptr = src + idx[i] * src_width;
                size_t adr = (size_t) ptr;
                memcpy(dst + i * sizeof(void *), &adr, sizeof(size_t));

                bool has_next = (next_i < num);
                PREFETCH_READ(has_next ? idx + next_i : NULL);
                PREFETCH_READ(has_next ? src + idx[next_i] * src_width : NULL);
                PREFETCH_WRITE(has_next ? dst + next_i * sizeof(void *) : NULL);
        }
        return true;
}

void async_gather_adr_func(const void *start, size_t width, size_t len, void *args, thread_id_t tid)
{
        UNUSED(tid);
        CAST(gather_scatter_args *, gather_args, args);

        PREFETCH_READ(gather_args->idx);
        PREFETCH_WRITE(gather_args->dst);
        PREFETCH_READ((len > 0) ? gather_args->src + gather_args->idx[0] * width : NULL);

        size_t global_index_start = (start - gather_args->dst) / width;
        for (register size_t i = 0, next_i = 1; i < len; next_i = ++i + 1) {
                size_t global_index_cur = global_index_start + i;
                size_t global_index_next = global_index_start + next_i;
                const void *ptr = gather_args->src + gather_args->idx[global_index_cur] * width;
                size_t adr = (size_t) ptr;
                memcpy(gather_args->dst + global_index_cur * sizeof(void *), &adr, sizeof(size_t));

                bool has_next = (next_i < len);
                PREFETCH_READ(has_next ? gather_args->idx + global_index_next : NULL);
                PREFETCH_READ(has_next ? gather_args->src + gather_args->idx[global_index_next] * width : NULL);
                PREFETCH_WRITE(has_next ? gather_args->dst + global_index_next * sizeof(void *) : NULL);
        }
}

bool int_async_gather_adr_func(void *dst, const void *src, size_t src_width, const size_t *idx,
                                   size_t num, uint_fast16_t num_threads)
{
        PREFETCH_READ(src);
        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);

        gather_scatter_args args = {.idx = idx, .src = src, .dst = dst};
        return async_for(dst, src_width, num, async_gather_adr_func, &args, num_threads);
}

void async_scatter(const void *start, size_t width, size_t len, void *args, thread_id_t tid)
{
        UNUSED(tid);
        CAST(gather_scatter_args *, scatter_args, args);

        PREFETCH_READ(scatter_args->idx);
        PREFETCH_READ(scatter_args->src);
        PREFETCH_WRITE((len > 0) ? scatter_args->dst + scatter_args->idx[0] * width : NULL);

        size_t global_index_start = (start - scatter_args->dst) / width;
        for (register size_t i = 0, next_i = 1; i < len; next_i = ++i + 1) {
                size_t global_index_cur = global_index_start + i;
                size_t global_index_next = global_index_start + next_i;

                memcpy(scatter_args->dst + scatter_args->idx[global_index_cur] * width,
                       scatter_args->src + global_index_cur * width,
                       width);

                bool has_next = (next_i < len);
                PREFETCH_READ(has_next ? scatter_args->idx + global_index_next : NULL);
                PREFETCH_READ(has_next ? scatter_args->src + global_index_next * width : NULL);
                PREFETCH_WRITE(has_next ? scatter_args->dst + scatter_args->idx[global_index_next] * width : NULL);
        }
}

bool sync_scatter(void *dst, const void *src, size_t width, const size_t *idx,
                      size_t num)
{
        PREFETCH_READ(idx);
        PREFETCH_READ(src);
        PREFETCH_WRITE((num > 0) ? dst + idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < num; next_i = ++i + 1) {
                memcpy(dst + idx[i] * width, src + i * width, width);

                bool has_next = (next_i < num);
                PREFETCH_READ(has_next ? idx + next_i : NULL);
                PREFETCH_READ(has_next ? src + next_i * width : NULL);
                PREFETCH_WRITE(has_next ? dst + idx[next_i] * width : NULL);
        }
        return true;
}

bool sync_scatter_func(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                           uint_fast16_t num_threads)
{
        PREFETCH_READ(src);
        PREFETCH_READ(idx);
        PREFETCH_WRITE(dst);

        gather_scatter_args args = {.idx = idx, .src = src, .dst = dst};
        return async_for(dst, width, num, async_scatter, &args, num_threads);
}

bool sync_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                      const size_t *src_idx, size_t idx_len)
{
        bool has_first = (idx_len > 0);
        PREFETCH_READ(src_idx);
        PREFETCH_READ(dst_idx);
        PREFETCH_READ(has_first ? src + src_idx[0] * width : NULL);
        PREFETCH_WRITE(has_first ? dst + dst_idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < idx_len; next_i = ++i + 1) {
                memcpy(dst + dst_idx[i] * width, src + src_idx[i] * width, width);

                bool has_next = (next_i < idx_len);
                PREFETCH_READ(has_next ? src_idx + next_i : NULL);
                PREFETCH_READ(has_next ? dst_idx + next_i : NULL);
                PREFETCH_READ(has_next ? src + src_idx[next_i] * width : NULL);
                PREFETCH_WRITE(has_next ? dst + dst_idx[next_i] * width : NULL);
        }

        return true;
}

bool async_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                       const size_t *src_idx, size_t idx_len)
{
        UNUSED(dst);
        UNUSED(src);
        UNUSED(width);
        UNUSED(dst_idx);
        UNUSED(src_idx);
        UNUSED(idx_len);
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

bool int_sync_filter_late(size_t *positions, size_t *num_positions, const void *source,
                              size_t width, size_t length, pred_func_t predicate,
                              void *arguments)
{
        predicate(positions, num_positions, source, width, length, arguments, 0);

        return true;
}

void *int_sync_filter_procy_func(void *args)
{
        CAST(filter_arg  *, proxy_arg, args);
        proxy_arg->pred(proxy_arg->src_positions,
                        &proxy_arg->num_positions,
                        proxy_arg->start,
                        proxy_arg->width,
                        proxy_arg->len,
                        proxy_arg->args,
                        proxy_arg->position_offset_to_add);
        return NULL;
}

bool async_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                           pred_func_t pred, void *args, size_t num_threads)
{
        if (UNLIKELY(len == 0)) {
                *num_pos = 0;
                return true;
        }

        uint_fast16_t num_thread = num_threads + 1; /** +1 since one is this thread */

        pthread_t threads[num_threads];
        filter_arg thread_args[num_thread];

        register size_t chunk_len = len / num_thread;
        size_t chunk_len_remain = len % num_thread;
        size_t main_position_offset_to_add = num_threads * chunk_len;
        const void *main_thread_base = src + main_position_offset_to_add * width;

        PREFETCH_READ(pred);
        PREFETCH_READ(args);

        /** run f on NTHREADS_FOR additional threads */
        if (LIKELY(chunk_len > 0)) {
                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        filter_arg *arg = thread_args + tid;
                        arg->num_positions = 0;
                        arg->src_positions = MALLOC(chunk_len * sizeof(size_t));
                        arg->position_offset_to_add = tid * chunk_len;
                        arg->start = src + arg->position_offset_to_add * width;
                        arg->len = chunk_len;
                        arg->width = width;
                        arg->args = args;
                        arg->pred = pred;

                        PREFETCH_READ(arg->start);
                        pthread_create(threads + tid, NULL, int_sync_filter_procy_func, arg);
                }
        }
        /** run f on this thread */
        PREFETCH_READ(main_thread_base);
        size_t main_chunk_len = chunk_len + chunk_len_remain;
        size_t *main_src_positions = MALLOC(main_chunk_len * sizeof(size_t));
        size_t main_num_positions = 0;

        pred(main_src_positions,
             &main_num_positions,
             main_thread_base,
             width,
             main_chunk_len,
             args,
             main_position_offset_to_add);

        size_t total_num_matching_positions = 0;

        if (LIKELY(chunk_len > 0)) {
                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        pthread_join(threads[tid], NULL);
                        const filter_arg *thread_arg = (thread_args + tid);
                        if (thread_arg->num_positions > 0) {
                                memcpy(pos + total_num_matching_positions,
                                       thread_arg->src_positions,
                                       thread_arg->num_positions * sizeof(size_t));
                                total_num_matching_positions += thread_arg->num_positions;
                        }
                        free(thread_args[tid].src_positions);
                }
        }

        if (LIKELY(main_num_positions > 0)) {
                memcpy(pos + total_num_matching_positions, main_src_positions, main_num_positions * sizeof(size_t));
                total_num_matching_positions += main_num_positions;
        }
        free(main_src_positions);

        *num_pos = total_num_matching_positions;

        return true;
}

bool async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                            size_t len, pred_func_t pred, void *args)
{
        size_t num_matching_positions;
        size_t *matching_positions = MALLOC(len * sizeof(size_t));

        pred(matching_positions, &num_matching_positions, src, width, len, args, 0);

        gather(result, src, width, matching_positions, num_matching_positions, THREADING_HINT_SINGLE, 0);
        *result_size = num_matching_positions;

        free(matching_positions);

        return true;
}

bool int_async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                                size_t len, pred_func_t pred, void *args, uint_fast16_t num_threads)
{
        uint_fast16_t num_thread = num_threads + 1; /** +1 since one is this thread */

        pthread_t threads[num_threads];
        filter_arg thread_args[num_thread];

        register size_t chunk_len = len / num_thread;
        size_t chunk_len_remain = len % num_thread;
        size_t main_position_offset_to_add = num_threads * chunk_len;
        const void *main_thread_base = src + main_position_offset_to_add * width;

        PREFETCH_READ(pred);
        PREFETCH_READ(args);

        /** run f on NTHREADS_FOR additional threads */
        for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                filter_arg *arg = thread_args + tid;
                arg->num_positions = 0;
                arg->src_positions = MALLOC(chunk_len * sizeof(size_t));
                arg->position_offset_to_add = tid * chunk_len;
                arg->start = src + arg->position_offset_to_add * width;
                arg->len = chunk_len;
                arg->width = width;
                arg->args = args;
                arg->pred = pred;

                PREFETCH_READ(arg->start);
                pthread_create(threads + tid, NULL, int_sync_filter_procy_func, arg);
        }
        /** run f on this thread */
        PREFETCH_READ(main_thread_base);
        size_t main_chunk_len = chunk_len + chunk_len_remain;
        size_t *main_src_positions = MALLOC(main_chunk_len * sizeof(size_t));
        size_t main_num_positions = 0;

        pred(main_src_positions,
             &main_num_positions,
             main_thread_base,
             width,
             main_chunk_len,
             args,
             main_position_offset_to_add);

        size_t total_num_matching_positions = main_num_positions;
        size_t partial_num_matching_positions = 0;

        for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                pthread_join(threads[tid], NULL);
                const filter_arg *thread_arg = (thread_args + tid);
                total_num_matching_positions += thread_arg->num_positions;
                PREFETCH_READ(thread_arg->src_positions);
        }

        for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                const filter_arg *thread_arg = (thread_args + tid);

                if (LIKELY(thread_arg->num_positions > 0)) {
                        gather(result + partial_num_matching_positions * width,
                                   src,
                                   width,
                                   thread_arg->src_positions,
                                   thread_arg->num_positions,
                                   THREADING_HINT_MULTI,
                                   num_threads);
                }

                partial_num_matching_positions += thread_arg->num_positions;
                free(thread_arg->src_positions);
        }

        if (LIKELY(main_num_positions > 0)) {
                gather(result + partial_num_matching_positions * width,
                           src,
                           width,
                           main_src_positions,
                           main_num_positions,
                           THREADING_HINT_MULTI,
                           num_threads);
        }
        free(main_src_positions);

        *result_size = total_num_matching_positions;

        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/std/bitmap.h>

bool bitmap_create(bitmap *bitmap, u16 num_bits)
{
        vec_create(&bitmap->data, sizeof(u32), ceil(num_bits / (double) BIT_NUM_OF(u32)));
        size_t cap = vec_capacity(&bitmap->data);
        u32 zero = 0;
        vec_repeated_push(&bitmap->data, &zero, cap);
        bitmap->num_bits = num_bits;

        return true;
}

bool bitmap_cpy(bitmap *dst, const bitmap *src)
{
        dst->num_bits = src->num_bits;
        return vec_cpy(&dst->data, &src->data);
}

bool bitmap_drop(bitmap *bitset)
{
        return vec_drop(&bitset->data);
}

size_t bitmap_nbits(const bitmap *bitset)
{
        return bitset->num_bits;
}

bool bitmap_clear(bitmap *bitset)
{
        void *data = (void *) vec_data(&bitset->data);
        memset(data, 0, sizeof(u32) * vec_capacity(&bitset->data));
        return true;
}

bool bitmap_set(bitmap *bitset, u16 bit_position, bool on)
{
        size_t block_pos = floor(bit_position / (double) BIT_NUM_OF(u32));
        size_t block_bit = bit_position % BIT_NUM_OF(u32);
        u32 block = *VEC_GET(&bitset->data, block_pos, u32);
        u32 mask = SET_BIT(block_bit);
        if (on) {
                SET_BITS(block, mask);
        } else {
                UNSET_BITS(block, mask);
        }
        vec_set(&bitset->data, block_pos, &block);
        return true;
}

bool bitmap_get(bitmap *bitset, u16 bit_position)
{
        size_t block_pos = floor(bit_position / (double) BIT_NUM_OF(u32));
        size_t block_bit = bit_position % BIT_NUM_OF(u32);
        u32 block = *VEC_GET(&bitset->data, block_pos, u32);
        u32 mask = SET_BIT(block_bit);
        return ((mask & block) >> bit_position) == true;
}

bool bitmap_lshift(bitmap *map)
{
        for (int i = map->num_bits - 1; i >= 0; i--) {
                bool f = i > 0 ? bitmap_get(map, i - 1) : false;
                bitmap_set(map, i, f);
        }
        return true;
}

void bitmap_print_bits(FILE *file, u32 n)
{
        for (int i = 31; i >= 0; i--) {
                u32 mask = 1 << i;
                u32 k = n & mask;
                fprintf(file, "%s", k == 0 ? "0" : "1");
        }
}

void bitmap_print_bits_in_char(FILE *file, char n)
{
        fprintf(file, "0b");
        for (int i = 7; i >= 0; i--) {
                char mask = 1 << i;
                char k = n & mask;
                fprintf(file, "%s", k == 0 ? "0" : "1");
        }
}

bool bitmap_blocks(u32 **blocks, u32 *num_blocks, const bitmap *map)
{
        u32 *result = MALLOC(map->data.num_elems * sizeof(u32));
        i32 k = 0;
        for (i32 i = map->data.num_elems - 1; i >= 0; i--) {
                result[k++] = *VEC_GET(&map->data, i, u32);
        }
        *blocks = result;
        *num_blocks = map->data.num_elems;

        return true;
}

bool bitmap_print(FILE *file, const bitmap *map)
{
        u32 *blocks, num_blocks;

        bitmap_blocks(&blocks, &num_blocks, map);

        for (u32 i = 0; i < num_blocks; i++) {
                fprintf(file, " %"PRIu32 " |", blocks[i]);
        }

        free(blocks);

        for (i32 i = map->data.num_elems - 1; i >= 0; i--) {
                u32 block = *VEC_GET(&map->data, i, u32);
                bitmap_print_bits(stdout, block);
                fprintf(file, " |");
        }

        fprintf(file, "\n");
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <karbonit/std/bloom.h>

bool bloom_create(bitmap *filter, size_t size)
{
        return bitmap_create(filter, size);
}

bool bloom_drop(bitmap *filter)
{
        return bitmap_drop(filter);
}

bool bloom_clear(bitmap *filter)
{
        return bitmap_clear(filter);
}

size_t bloom_nbits(bitmap *filter)
{
        return bitmap_nbits(filter);
}

unsigned bloom_nhashs()
{
        return 4;
}



/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/hash.h>
#include <karbonit/std/hash/set.h>

#define _HASH_SET_HASHCODE_OF(size, x) HASH_BERNSTEIN(size, x)
#define FIX_MAP_AUTO_REHASH_LOADFACTOR 0.9f

bool hashset_create(hashset *map, size_t key_size, size_t capacity)
{
        int err_code = ERR_INITFAILED;

        map->size = 0;

        SUCCESS_OR_JUMP(vec_create(&map->key_data, key_size, capacity), error_handling);
        SUCCESS_OR_JUMP(vec_create(&map->table, sizeof(hashset_bucket), capacity),
                            cleanup_key_data_and_error);
        SUCCESS_OR_JUMP(vec_enlarge_size_to_capacity(&map->table), cleanup_key_value_table_and_error);
        SUCCESS_OR_JUMP(vec_zero_memory(&map->table), cleanup_key_value_table_and_error);
        SUCCESS_OR_JUMP(spinlock_init(&map->lock), cleanup_key_value_table_and_error);

        return true;

        cleanup_key_value_table_and_error:
        if (!vec_drop(&map->table)) {
                err_code = ERR_DROPFAILED;
        }
        cleanup_key_data_and_error:
        if (!vec_drop(&map->key_data)) {
                err_code = ERR_DROPFAILED;
        }
        error_handling:
        ERROR(err_code, NULL);
        return false;
}

bool hashset_drop(hashset *map)
{
        bool status = true;

        status &= vec_drop(&map->table);
        status &= vec_drop(&map->key_data);

        if (!status) {
                ERROR(ERR_DROPFAILED, NULL);
        }

        return status;
}

vec *hashset_keys(hashset *map)
{
        if (map) {
                vec *result = MALLOC(sizeof(vec));
                vec_create(result, map->key_data.elem_size, map->key_data.num_elems);
                for (u32 i = 0; i < map->table.num_elems; i++) {
                        hashset_bucket *bucket = VEC_GET(&map->table, i, hashset_bucket);
                        if (bucket->in_use_flag) {
                                const void *data = vec_at(&map->key_data, bucket->key_idx);
                                vec_push(result, data, 1);
                        }
                }
                return result;
        } else {
                return NULL;
        }
}

hashset *hashset_cpy(hashset *src)
{
        if (src) {
                hashset *cpy = MALLOC(sizeof(hashset));

                hashset_lock(src);

                hashset_create(cpy, src->key_data.elem_size, src->table.cap_elems);

                assert(src->key_data.cap_elems == src->table.cap_elems);
                assert(src->key_data.num_elems <= src->table.num_elems);

                vec_cpy_to(&cpy->key_data, &src->key_data);
                vec_cpy_to(&cpy->table, &src->table);
                cpy->size = src->size;

                assert(cpy->key_data.cap_elems == cpy->table.cap_elems);
                assert(cpy->key_data.num_elems <= cpy->table.num_elems);

                hashset_unlock(src);
                return cpy;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool hashset_clear(hashset *map)
{
        assert(map->key_data.cap_elems == map->table.cap_elems);
        assert(map->key_data.num_elems <= map->table.num_elems);

        hashset_lock(map);

        bool status = vec_clear(&map->key_data) && vec_zero_memory(&map->table);

        map->size = 0;

        assert(map->key_data.cap_elems == map->table.cap_elems);
        assert(map->key_data.num_elems <= map->table.num_elems);

        if (!status) {
                ERROR(ERR_OPPFAILED, NULL);
        }

        hashset_unlock(map);

        return status;
}

bool hashset_avg_displace(float *displace, const hashset *map)
{
        size_t sum_dis = 0;
        for (size_t i = 0; i < map->table.num_elems; i++) {
                hashset_bucket *bucket = VEC_GET(&map->table, i, hashset_bucket);
                sum_dis += abs(bucket->displacement);
        }
        *displace = (sum_dis / (float) map->table.num_elems);

        return true;
}

bool hashset_lock(hashset *map)
{
        spinlock_acquire(&map->lock);
        return true;
}

bool hashset_unlock(hashset *map)
{
        spinlock_release(&map->lock);
        return true;
}

static inline const void *_hash_set_get_bucket_key(const hashset_bucket *bucket, const hashset *map)
{
        return map->key_data.base + bucket->key_idx * map->key_data.elem_size;
}

static void _hash_set_insert(hashset_bucket *bucket, hashset *map, const void *key, i32 displacement)
{
        u64 idx = map->key_data.num_elems;
        void *key_datum = VEC_NEW_AND_GET(&map->key_data, void *);
        memcpy(key_datum, key, map->key_data.elem_size);
        bucket->key_idx = idx;
        bucket->in_use_flag = true;
        bucket->displacement = displacement;
        map->size++;
}

static inline uint_fast32_t _hash_set_insert_or_update(hashset *map, const u32 *bucket_idxs, const void *keys,
                                             uint_fast32_t num_pairs)
{
        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                u32 intended_bucket_idx = bucket_idxs[i];

                u32 bucket_idx = intended_bucket_idx;

                hashset_bucket *bucket = VEC_GET(&map->table, bucket_idx, hashset_bucket);
                if (bucket->in_use_flag && memcmp(_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) != 0) {
                        bool fitting_bucket_found = false;
                        u32 displace_idx;
                        for (displace_idx = bucket_idx + 1; displace_idx < map->table.num_elems; displace_idx++) {
                                hashset_bucket
                                        *bucket = VEC_GET(&map->table, displace_idx, hashset_bucket);
                                fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                &&
                                                                                memcmp(_hash_set_get_bucket_key(bucket, map), key,
                                                                                       map->key_data.elem_size) == 0);
                                if (fitting_bucket_found) {
                                        break;
                                } else {
                                        i32 displacement = displace_idx - bucket_idx;
                                        const void *swap_key = _hash_set_get_bucket_key(bucket, map);

                                        if (bucket->displacement < displacement) {
                                                _hash_set_insert(bucket, map, key, displacement);
                                                _hash_set_insert_or_update(map, &displace_idx, swap_key, 1);
                                                goto next_round;
                                        }
                                }
                        }
                        if (!fitting_bucket_found) {
                                for (displace_idx = 0; displace_idx < bucket_idx - 1; displace_idx++) {
                                        const hashset_bucket
                                                *bucket = VEC_GET(&map->table, displace_idx, hashset_bucket);
                                        fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                        && memcmp(_hash_set_get_bucket_key(bucket,
                                                                                                                 map),
                                                                                                  key,
                                                                                                  map->key_data.elem_size)
                                                                                           == 0);
                                        if (fitting_bucket_found) {
                                                break;
                                        }
                                }
                        }

                        assert(fitting_bucket_found == true);
                        bucket_idx = displace_idx;
                        bucket = VEC_GET(&map->table, bucket_idx, hashset_bucket);
                }

                bool is_update =
                        bucket->in_use_flag && memcmp(_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                if (!is_update) {
                        i32 displacement = intended_bucket_idx - bucket_idx;
                        _hash_set_insert(bucket, map, key, displacement);
                }

                next_round:
                if (map->size >= FIX_MAP_AUTO_REHASH_LOADFACTOR * map->table.cap_elems) {
                        return i + 1; /** tell the caller that pair i was inserted, but it successors not */
                }

        }
        return 0;
}

bool hashset_insert_or_update(hashset *map, const void *keys, uint_fast32_t num_pairs)
{
        assert(map->key_data.cap_elems == map->table.cap_elems);
        assert(map->key_data.num_elems <= map->table.num_elems);

        hashset_lock(map);

        u32 *bucket_idxs = MALLOC(num_pairs * sizeof(u32));
        if (!bucket_idxs) {
                ERROR(ERR_MALLOCERR, NULL);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                hash32_t hash = _HASH_SET_HASHCODE_OF(map->key_data.elem_size, key);
                bucket_idxs[i] = hash % map->table.num_elems;
        }

        uint_fast32_t cont_idx = 0;
        do {
                cont_idx = _hash_set_insert_or_update(map,
                                            bucket_idxs + cont_idx,
                                            keys + cont_idx * map->key_data.elem_size,
                                            num_pairs - cont_idx);
                if (cont_idx != 0) {
                        /** rehashing is required, and [status, num_pairs) are left to be inserted */
                        if (!hashset_rehash(map)) {
                                hashset_unlock(map);
                                return false;
                        }
                }
        } while (cont_idx != 0);

        free(bucket_idxs);
        hashset_unlock(map);

        return true;
}

bool hashset_remove_if_contained(hashset *map, const void *keys, size_t num_pairs)
{
        hashset_lock(map);

        u32 *bucket_idxs = MALLOC(num_pairs * sizeof(u32));
        if (!bucket_idxs) {
                ERROR(ERR_MALLOCERR, NULL);
                hashset_unlock(map);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                bucket_idxs[i] = _HASH_SET_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                u32 bucket_idx = bucket_idxs[i];
                u32 actual_idx = bucket_idx;
                bool bucket_found = false;

                for (u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                        const hashset_bucket *bucket = VEC_GET(&map->table, k, hashset_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }
                for (u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                        const hashset_bucket *bucket = VEC_GET(&map->table, k, hashset_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }

                if (bucket_found) {
                        hashset_bucket *bucket = VEC_GET(&map->table, actual_idx, hashset_bucket);
                        bucket->in_use_flag = false;
                        bucket->key_idx = 0;
                }
        }

        free(bucket_idxs);

        hashset_unlock(map);

        return true;
}

bool hashset_contains_key(hashset *map, const void *key)
{
        bool result = false;

        hashset_lock(map);

        u32 bucket_idx = _HASH_SET_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        bool bucket_found = false;

        for (u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                const hashset_bucket *bucket = VEC_GET(&map->table, k, hashset_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
        }
        for (u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                const hashset_bucket *bucket = VEC_GET(&map->table, k, hashset_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
        }

        result = bucket_found;
        hashset_unlock(map);

        return result;
}

bool hashset_get_load_factor(float *factor, hashset *map)
{
        hashset_lock(map);

        *factor = map->size / (float) map->table.num_elems;

        hashset_unlock(map);

        return true;
}

bool hashset_rehash(hashset *map)
{
        hashset_lock(map);

        hashset *cpy = hashset_cpy(map);
        hashset_clear(map);

        size_t new_cap = (cpy->key_data.cap_elems + 1) * 1.7f;

        vec_grow_to(&map->key_data, new_cap);
        vec_grow_to(&map->table, new_cap);
        vec_enlarge_size_to_capacity(&map->table);
        vec_zero_memory(&map->table);

        assert(map->key_data.cap_elems == map->table.cap_elems);
        assert(map->key_data.num_elems <= map->table.num_elems);

        for (size_t i = 0; i < cpy->table.num_elems; i++) {
                hashset_bucket *bucket = VEC_GET(&cpy->table, i, hashset_bucket);
                if (bucket->in_use_flag) {
                        const void *old_key = _hash_set_get_bucket_key(bucket, cpy);
                        if (!hashset_insert_or_update(map, old_key, 1)) {
                                hashset_unlock(map);
                                return ERROR(ERR_REHASH_NOROLLBACK, NULL);
                        }
                }
        }

        hashset_unlock(map);
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/hash.h>
#include <karbonit/std/hash/table.h>
#include <err.h>

#define _HASH_TABLE_HASHCODE_OF(size, x) HASH_BERNSTEIN(size, x)
#define FIX_MAP_AUTO_REHASH_LOADFACTOR 0.9f

bool hashtable_create(hashtable *map, size_t key_size, size_t value_size,
                      size_t capacity)
{
        int err_code = ERR_INITFAILED;

        map->size = 0;

        SUCCESS_OR_JUMP(vec_create(&map->key_data, key_size, capacity), error_handling);
        SUCCESS_OR_JUMP(vec_create(&map->value_data, value_size, capacity), cleanup_key_data_and_error);
        SUCCESS_OR_JUMP(vec_create(&map->table, sizeof(hashtable_bucket), capacity),
                            cleanup_value_key_data_and_error);
        SUCCESS_OR_JUMP(vec_enlarge_size_to_capacity(&map->table), cleanup_key_value_table_and_error);
        SUCCESS_OR_JUMP(vec_zero_memory(&map->table), cleanup_key_value_table_and_error);
        SUCCESS_OR_JUMP(spinlock_init(&map->lock), cleanup_key_value_table_and_error);

        return true;

        cleanup_key_value_table_and_error:
        if (!vec_drop(&map->table)) {
                err_code = ERR_DROPFAILED;
        }
        cleanup_value_key_data_and_error:
        if (!vec_drop(&map->value_data)) {
                err_code = ERR_DROPFAILED;
        }
        cleanup_key_data_and_error:
        if (!vec_drop(&map->key_data)) {
                err_code = ERR_DROPFAILED;
        }
        error_handling:
        ERROR(err_code, NULL);
        return false;
}

bool hashtable_drop(hashtable *map)
{
        bool status = true;

        status &= vec_drop(&map->table);
        status &= vec_drop(&map->value_data);
        status &= vec_drop(&map->key_data);

        if (!status) {
                ERROR(ERR_DROPFAILED, NULL);
        }

        return status;
}

hashtable *hashtable_cpy(hashtable *src)
{
        if (src) {
                hashtable *cpy = MALLOC(sizeof(hashtable));

                hashtable_create(cpy,
                                 src->key_data.elem_size,
                                 src->value_data.elem_size,
                                 src->table.cap_elems);

                assert(src->key_data.cap_elems == src->value_data.cap_elems
                           && src->value_data.cap_elems == src->table.cap_elems);
                assert((src->key_data.num_elems == src->value_data.num_elems)
                           && src->value_data.num_elems <= src->table.num_elems);

                vec_cpy_to(&cpy->key_data, &src->key_data);
                vec_cpy_to(&cpy->value_data, &src->value_data);
                vec_cpy_to(&cpy->table, &src->table);
                cpy->size = src->size;

                assert(cpy->key_data.cap_elems == src->value_data.cap_elems
                           && src->value_data.cap_elems == cpy->table.cap_elems);
                assert((cpy->key_data.num_elems == src->value_data.num_elems)
                           && src->value_data.num_elems <= cpy->table.num_elems);

                return cpy;
        } else {
                ERROR(ERR_NULLPTR, NULL);
                return NULL;
        }
}

bool hashtable_clear(hashtable *map)
{
        assert(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        assert((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        bool status = vec_clear(&map->key_data) && vec_clear(&map->value_data) && vec_zero_memory(&map->table);

        map->size = 0;

        assert(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        assert((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        if (!status) {
                ERROR(ERR_OPPFAILED, NULL);
        }

        return status;
}

bool hashtable_avg_displace(float *displace, const hashtable *map)
{
        size_t sum_dis = 0;
        for (size_t i = 0; i < map->table.num_elems; i++) {
                hashtable_bucket *bucket = VEC_GET(&map->table, i, hashtable_bucket);
                sum_dis += abs(bucket->displacement);
        }
        *displace = (sum_dis / (float) map->table.num_elems);

        return true;
}

static inline const void *_hash_table_get_bucket_key(const hashtable_bucket *bucket, const hashtable *map)
{
        return map->key_data.base + bucket->data_idx * map->key_data.elem_size;
}

static inline const void *get_bucket_value(const hashtable_bucket *bucket, const hashtable *map)
{
        return map->value_data.base + bucket->data_idx * map->value_data.elem_size;
}

static void _hash_table_insert(hashtable_bucket *bucket, hashtable *map, const void *key, const void *value,
                   i32 displacement)
{
        assert(map->key_data.num_elems == map->value_data.num_elems);
        u64 idx = map->key_data.num_elems;
        void *key_datum = VEC_NEW_AND_GET(&map->key_data, void *);
        void *value_datum = VEC_NEW_AND_GET(&map->value_data, void *);
        memcpy(key_datum, key, map->key_data.elem_size);
        memcpy(value_datum, value, map->value_data.elem_size);
        bucket->data_idx = idx;
        bucket->in_use_flag = true;
        bucket->displacement = displacement;
        map->size++;
}

static inline uint_fast32_t _hash_table_insert_or_update(hashtable *map, const u32 *bucket_idxs, const void *keys,
                                             const void *values, uint_fast32_t num_pairs)
{
        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                const void *value = values + i * map->key_data.elem_size;
                u32 intended_bucket_idx = bucket_idxs[i];

                u32 bucket_idx = intended_bucket_idx;

                hashtable_bucket *bucket = VEC_GET(&map->table, bucket_idx, hashtable_bucket);
                if (bucket->in_use_flag && memcmp(_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) != 0) {
                        bool fitting_bucket_found = false;
                        u32 displace_idx;
                        for (displace_idx = bucket_idx + 1; displace_idx < map->table.num_elems; displace_idx++) {
                                hashtable_bucket
                                        *bucket = VEC_GET(&map->table, displace_idx, hashtable_bucket);
                                fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                &&
                                                                                memcmp(_hash_table_get_bucket_key(bucket, map), key,
                                                                                       map->key_data.elem_size) == 0);
                                if (fitting_bucket_found) {
                                        break;
                                } else {
                                        i32 displacement = displace_idx - bucket_idx;
                                        const void *swap_key = _hash_table_get_bucket_key(bucket, map);
                                        const void *swap_value = get_bucket_value(bucket, map);

                                        if (bucket->displacement < displacement) {
                                                _hash_table_insert(bucket, map, key, value, displacement);
                                                _hash_table_insert_or_update(map, &displace_idx, swap_key, swap_value, 1);
                                                goto next_round;
                                        }
                                }
                        }
                        if (!fitting_bucket_found) {
                                for (displace_idx = 0; displace_idx < bucket_idx - 1; displace_idx++) {
                                        const hashtable_bucket
                                                *bucket = VEC_GET(&map->table, displace_idx, hashtable_bucket);
                                        fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                        && memcmp(_hash_table_get_bucket_key(bucket,
                                                                                                                 map),
                                                                                                  key,
                                                                                                  map->key_data.elem_size)
                                                                                           == 0);
                                        if (fitting_bucket_found) {
                                                break;
                                        }
                                }
                        }

                        assert(fitting_bucket_found == true);
                        bucket_idx = displace_idx;
                        bucket = VEC_GET(&map->table, bucket_idx, hashtable_bucket);
                }

                bool is_update =
                        bucket->in_use_flag && memcmp(_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                if (is_update) {
                        void *bucket_value = (void *) get_bucket_value(bucket, map);
                        memcpy(bucket_value, value, map->value_data.elem_size);
                } else {
                        i32 displacement = intended_bucket_idx - bucket_idx;
                        _hash_table_insert(bucket, map, key, value, displacement);
                }

                next_round:
                if (map->size >= FIX_MAP_AUTO_REHASH_LOADFACTOR * map->table.cap_elems) {
                        return i + 1; /** tell the caller that pair i was inserted, but it successors not */
                }

        }
        return 0;
}

bool hashtable_insert_or_update(hashtable *map, const void *keys, const void *values,
                                uint_fast32_t num_pairs)
{
        assert(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        assert((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        u32 *bucket_idxs = MALLOC(num_pairs * sizeof(u32));
        if (!bucket_idxs) {
                ERROR(ERR_MALLOCERR, NULL);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                hash32_t hash = _HASH_TABLE_HASHCODE_OF(map->key_data.elem_size, key);
                bucket_idxs[i] = hash % map->table.num_elems;
        }

        uint_fast32_t cont_idx = 0;
        do {
                cont_idx = _hash_table_insert_or_update(map,
                                            bucket_idxs + cont_idx,
                                            keys + cont_idx * map->key_data.elem_size,
                                            values + cont_idx * map->value_data.elem_size,
                                            num_pairs - cont_idx);
                if (cont_idx != 0) {
                        /** rehashing is required, and [status, num_pairs) are left to be inserted */
                        if (!hashtable_rehash(map)) {
                                return false;
                        }
                }
        } while (cont_idx != 0);

        free(bucket_idxs);

        return true;
}

typedef struct hashtable_header {
        char marker;
        offset_t key_data_off;
        offset_t value_data_off;
        offset_t table_off;
        u32 size;
} hashtable_header;

bool hashtable_serialize(FILE *file, hashtable *table)
{
        offset_t header_pos = ftell(file);
        fseek(file, sizeof(hashtable_header), SEEK_CUR);

        offset_t key_data_off = ftell(file);
        if (!vec_to_file(file, &table->key_data)) {
                goto error_handling;
        }

        offset_t value_data_off = ftell(file);
        if (!vec_to_file(file, &table->value_data)) {
                goto error_handling;
        }

        offset_t table_off = ftell(file);
        if (!vec_to_file(file, &table->table)) {
                goto error_handling;
        }

        offset_t end = ftell(file);

        fseek(file, header_pos, SEEK_SET);
        hashtable_header header = {.marker = MARKER_SYMBOL_HASHTABLE_HEADER, .size = table
                ->size, .key_data_off = key_data_off, .value_data_off = value_data_off, .table_off = table_off};
        int nwrite = fwrite(&header, sizeof(hashtable_header), 1, file);
        ERROR_IF_AND_RETURN(nwrite != 1, ERR_FWRITE_FAILED, NULL);
        fseek(file, end, SEEK_SET);
        return true;

        error_handling:
        fseek(file, header_pos, SEEK_SET);
        return false;
}

bool hashtable_deserialize(hashtable *table, FILE *file)
{
        int err_code = ERR_NOERR;

        hashtable_header header;
        offset_t start = ftell(file);
        int nread = fread(&header, sizeof(hashtable_header), 1, file);
        if (nread != 1) {
                err_code = ERR_FREAD_FAILED;
                goto error_handling;
        }
        if (header.marker != MARKER_SYMBOL_HASHTABLE_HEADER) {
                err_code = ERR_CORRUPTED;
                goto error_handling;
        }

        fseek(file, header.key_data_off, SEEK_SET);
        if (!vec_from_file(&table->key_data, file)) {
                err_code = g_err.code;
                goto error_handling;
        }

        fseek(file, header.value_data_off, SEEK_SET);
        if (!vec_from_file(&table->value_data, file)) {
                err_code = g_err.code;
                goto error_handling;
        }

        fseek(file, header.table_off, SEEK_SET);
        if (!vec_from_file(&table->table, file)) {
                err_code = g_err.code;
                goto error_handling;
        }

        spinlock_init(&table->lock);
        return true;

        error_handling:
        fseek(file, start, SEEK_SET);
        ERROR(err_code, NULL);
        return false;
}

bool hashtable_remove_if_contained(hashtable *map, const void *keys, size_t num_pairs)
{
        u32 *bucket_idxs = MALLOC(num_pairs * sizeof(u32));
        if (!bucket_idxs) {
                ERROR(ERR_MALLOCERR, NULL);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                bucket_idxs[i] = _HASH_TABLE_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                u32 bucket_idx = bucket_idxs[i];
                u32 actual_idx = bucket_idx;
                bool bucket_found = false;

                for (u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                        const hashtable_bucket *bucket = VEC_GET(&map->table, k, hashtable_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }
                for (u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                        const hashtable_bucket *bucket = VEC_GET(&map->table, k, hashtable_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }

                if (bucket_found) {
                        hashtable_bucket *bucket = VEC_GET(&map->table, actual_idx, hashtable_bucket);
                        bucket->in_use_flag = false;
                        bucket->data_idx = 0;
                        bucket->num_probs = 0;
                }
        }

        free(bucket_idxs);
        return true;
}

const void *hashtable_get_value(hashtable *map, const void *key)
{
        const void *result = NULL;

        u32 bucket_idx = _HASH_TABLE_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        u32 actual_idx = bucket_idx;
        bool bucket_found = false;

        for (u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                const hashtable_bucket *bucket = VEC_GET(&map->table, k, hashtable_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                actual_idx = k;
        }
        for (u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                const hashtable_bucket *bucket = VEC_GET(&map->table, k, hashtable_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                actual_idx = k;
        }

        if (bucket_found) {
                hashtable_bucket *bucket = VEC_GET(&map->table, actual_idx, hashtable_bucket);
                result = get_bucket_value(bucket, map);
        }

        return result;
}

bool hashtable_get_load_factor(float *factor, hashtable *map)
{
        *factor = map->size / (float) map->table.num_elems;

        return true;
}

bool hashtable_rehash(hashtable *map)
{
        hashtable *cpy = hashtable_cpy(map);
        hashtable_clear(map);

        size_t new_cap = (cpy->key_data.cap_elems + 1) * 1.7f;

        vec_grow_to(&map->key_data, new_cap);
        vec_grow_to(&map->value_data, new_cap);
        vec_grow_to(&map->table, new_cap);
        vec_enlarge_size_to_capacity(&map->table);
        vec_zero_memory(&map->table);

        assert(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        assert((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        for (size_t i = 0; i < cpy->table.num_elems; i++) {
                hashtable_bucket *bucket = VEC_GET(&cpy->table, i, hashtable_bucket);
                if (bucket->in_use_flag) {
                        const void *old_key = _hash_table_get_bucket_key(bucket, cpy);
                        const void *old_value = get_bucket_value(bucket, cpy);
                        if (!hashtable_insert_or_update(map, old_key, old_value, 1)) {
                                return ERROR(ERR_REHASH_NOROLLBACK, NULL);
                        }
                }
        }

        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/opt.h>

static command_opt *option_by_name(command_opt_mgr *manager, const char *name);

bool opt_manager_create(command_opt_mgr *manager, char *module_name, char *module_desc, module_arg_policy policy,
                    bool (*fallback)(int argc, char **argv, FILE *file, command_opt_mgr *manager))
{
        manager->module_name = strdup(module_name);
        manager->module_desc = module_desc ? strdup(module_desc) : NULL;
        manager->policy = policy;
        manager->fallback = fallback;
        CHECK_SUCCESS(vec_create(&manager->groups, sizeof(command_opt_group), 5));
        return true;
}

bool opt_manager_drop(command_opt_mgr *manager)
{
        for (size_t i = 0; i < manager->groups.num_elems; i++) {
                command_opt_group *cmdGroup = VEC_GET(&manager->groups, i, command_opt_group);
                for (size_t j = 0; j < cmdGroup->cmd_options.num_elems; j++) {
                        command_opt *option = VEC_GET(&cmdGroup->cmd_options, j, command_opt);
                        free(option->opt_name);
                        free(option->opt_desc);
                        free(option->opt_manfile);
                }
                CHECK_SUCCESS(vec_drop(&cmdGroup->cmd_options));
                free(cmdGroup->desc);
        }

        CHECK_SUCCESS(vec_drop(&manager->groups));
        free(manager->module_name);
        if (manager->module_desc) {
                free(manager->module_desc);
        }
        return true;
}

bool opt_manager_process(command_opt_mgr *manager, int argc, char **argv, FILE *file)
{
        if (argc == 0) {
                if (manager->policy == MOD_ARG_REQUIRED) {
                        opt_manager_show_help(file, manager);
                } else {
                        return manager->fallback(argc, argv, file, manager);
                }
        } else {
                const char *arg = argv[0];
                command_opt *option = option_by_name(manager, arg);
                if (option) {
                        return option->callback(argc - 1, argv + 1, file);
                } else {
                        return manager->fallback(argc, argv, file, manager);
                }
        }

        return true;
}

bool opt_manager_create_group(command_opt_group **group, const char *desc, command_opt_mgr *manager)
{
        command_opt_group *cmdGroup = VEC_NEW_AND_GET(&manager->groups, command_opt_group);
        cmdGroup->desc = strdup(desc);
        CHECK_SUCCESS(vec_create(&cmdGroup->cmd_options, sizeof(command_opt), 10));
        *group = cmdGroup;
        return true;
}

bool opt_group_add_cmd(command_opt_group *group, const char *opt_name, char *opt_desc, char *opt_manfile,
                       int (*callback)(int argc, char **argv, FILE *file))
{
        command_opt *command = VEC_NEW_AND_GET(&group->cmd_options, command_opt);
        command->opt_desc = strdup(opt_desc);
        command->opt_manfile = strdup(opt_manfile);
        command->opt_name = strdup(opt_name);
        command->callback = callback;

        return true;
}

bool opt_manager_show_help(FILE *file, command_opt_mgr *manager)
{
        if (manager->groups.num_elems > 0) {
                fprintf(file,
                        "usage: %s <command> %s\n\n",
                        manager->module_name,
                        (manager->policy == MOD_ARG_REQUIRED ? "<args>" : manager->policy
                                                                              == MOD_ARG_MAYBE_REQUIRED
                                                                              ? "[<args>]" : ""));

                if (manager->module_desc) {
                        fprintf(file, "%s\n\n", manager->module_desc);
                }
                fprintf(file, "These are common commands used in various situations:\n\n");
                for (size_t i = 0; i < manager->groups.num_elems; i++) {
                        command_opt_group *cmdGroup = VEC_GET(&manager->groups, i, command_opt_group);
                        fprintf(file, "%s\n", cmdGroup->desc);
                        for (size_t j = 0; j < cmdGroup->cmd_options.num_elems; j++) {
                                command_opt *option = VEC_GET(&cmdGroup->cmd_options, j, command_opt);
                                fprintf(file, "   %-15s%s\n", option->opt_name, option->opt_desc);
                        }
                        fprintf(file, "\n");
                }
                fprintf(file,
                        "\n'%s help' show this help, and '%s help <command>' to open \nmanpage of specific command.\n",
                        manager->module_name,
                        manager->module_name);
        } else {
                fprintf(file,
                        "usage: %s %s\n\n",
                        manager->module_name,
                        (manager->policy == MOD_ARG_REQUIRED ? "<args>" : manager->policy
                                                                              == MOD_ARG_MAYBE_REQUIRED
                                                                              ? "[<args>]" : ""));

                fprintf(file, "%s\n\n", manager->module_desc);
        }

        return true;
}

static command_opt *option_by_name(command_opt_mgr *manager, const char *name)
{
        for (size_t i = 0; i < manager->groups.num_elems; i++) {
                command_opt_group *cmdGroup = VEC_GET(&manager->groups, i, command_opt_group);
                for (size_t j = 0; j < cmdGroup->cmd_options.num_elems; j++) {
                        command_opt *option = VEC_GET(&cmdGroup->cmd_options, j, command_opt);
                        if (strcmp(option->opt_name, name) == 0) {
                                return option;
                        }
                }
        }
        return NULL;
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/spinlock.h>
#include <karbonit/utils/time.h>

#define SPINLOCK_TAG "spinlock"

bool spinlock_init(spinlock *spinlock)
{
        atomic_flag_clear(&spinlock->lock);
        memset(&spinlock->owner, 0, sizeof(pthread_t));
        return true;
}

bool spinlock_acquire(spinlock *spinlock)
{
        timestamp begin = wallclock();
        if (!pthread_equal(spinlock->owner, pthread_self())) {
                while (atomic_flag_test_and_set(&spinlock->lock)) {}
                /** remeber the thread that aquires this lock */
                spinlock->owner = pthread_self();
        }
        timestamp end = wallclock();
        float duration = (end - begin) / 1000.0f;
        if (duration > 0.01f) {
                WARN(SPINLOCK_TAG, "spin lock acquisition took exceptionally long: %f seconds", duration);
        }

        return true;
}

bool spinlock_release(spinlock *spinlock)
{
        atomic_flag_clear(&spinlock->lock);
        memset(&spinlock->owner, 0, sizeof(pthread_t));
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/str_hash/mem.h>
#include <karbonit/std/spinlock.h>
#include <karbonit/utils/sort.h>
#include <karbonit/utils/time.h>
#include <karbonit/std/bloom.h>
#include <karbonit/stdx/slicelist.h>
#include <karbonit/std/hash.h>

#define STR_HASH_MEM_HASHCODE_OF(key)      HASH_BERNSTEIN(strlen(key), key)

#define SMART_MAP_TAG "strhash-mem"

struct bucket {
        slice_list_t slice_list;
};

struct mem_extra {
        vec ofType(bucket) buckets;
};

static int _str_hash_mem_drop(str_hash *self);

static int this_put_safe_bulk(str_hash *self, char *const *keys, const archive_field_sid_t *values,
                              size_t num_pairs);

static int this_put_fast_bulk(str_hash *self, char *const *keys, const archive_field_sid_t *values,
                              size_t num_pairs);

static int this_put_safe_exact(str_hash *self, const char *key, archive_field_sid_t value);

static int this_put_fast_exact(str_hash *self, const char *key, archive_field_sid_t value);

static int
this_get_safe(str_hash *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
              char *const *keys, size_t num_keys);

static int
this_get_safe_exact(str_hash *self, archive_field_sid_t *out, bool *found_mask, const char *key);

static int this_get_fast(str_hash *self, archive_field_sid_t **out, char *const *keys, size_t num_keys);

static int this_update_key_fast(str_hash *self, const archive_field_sid_t *values, char *const *keys,
                                size_t num_keys);

static int _str_hash_mem_remove(str_hash *self, char *const *keys, size_t num_keys);

static int _str_hash_mem_free(str_hash *self, void *ptr);

static int this_insert_bulk(vec ofType(bucket) *buckets, char *const *restrict keys,
                            const archive_field_sid_t *restrict values, size_t *restrict bucket_idxs,
                            size_t num_pairs,
                            str_hash_counters *counter);

static int
this_insert_exact(vec ofType(bucket) *buckets, const char *restrict key, archive_field_sid_t value,
                  size_t bucket_idx, str_hash_counters *counter);

static int
this_fetch_bulk(vec ofType(bucket) *buckets, archive_field_sid_t *values_out, bool *key_found_mask,
                size_t *num_keys_not_found, size_t *bucket_idxs, char *const *keys, size_t num_keys,
                str_hash_counters *counter);

static int
this_fetch_single(vec ofType(bucket) *buckets, archive_field_sid_t *value_out, bool *key_found,
                  const size_t bucket_idx, const char *key, str_hash_counters *counter);

static int _str_hash_mem_create_extra(str_hash *self, size_t num_buckets, size_t cap_buckets);

static struct mem_extra *this_get_exta(str_hash *self);

static int bucket_create(struct bucket *buckets, size_t num_buckets, size_t bucket_cap);

static int bucket_drop(struct bucket *buckets, size_t num_buckets);

static int bucket_insert(struct bucket *bucket, const char *restrict key, archive_field_sid_t value,
                         str_hash_counters *counter);

bool
str_hash_create_inmemory(str_hash *str_hash, size_t num_buckets, size_t cap_buckets)
{
        num_buckets = num_buckets < 1 ? 1 : num_buckets;
        cap_buckets = cap_buckets < 1 ? 1 : cap_buckets;

        str_hash->tag = MEMORY_RESIDENT;
        str_hash->drop = _str_hash_mem_drop;
        str_hash->put_bulk_safe = this_put_safe_bulk;
        str_hash->put_bulk_fast = this_put_fast_bulk;
        str_hash->put_exact_safe = this_put_safe_exact;
        str_hash->put_exact_fast = this_put_fast_exact;
        str_hash->get_bulk_safe = this_get_safe;
        str_hash->get_fast = this_get_fast;
        str_hash->update_key_fast = this_update_key_fast;
        str_hash->remove = _str_hash_mem_remove;
        str_hash->free = _str_hash_mem_free;
        str_hash->get_exact_safe = this_get_safe_exact;

        str_hash_reset_counters(str_hash);
        CHECK_SUCCESS(_str_hash_mem_create_extra(str_hash, num_buckets, cap_buckets));
        return true;
}

static int _str_hash_mem_drop(str_hash *self)
{
        assert(self->tag == MEMORY_RESIDENT);
        struct mem_extra *extra = this_get_exta(self);
        struct bucket *data = (struct bucket *) vec_data(&extra->buckets);
        CHECK_SUCCESS(bucket_drop(data, extra->buckets.cap_elems));
        vec_drop(&extra->buckets);
        free(self->extra);
        return true;
}

static int this_put_safe_bulk(str_hash *self, char *const *keys, const archive_field_sid_t *values,
                              size_t num_pairs)
{
        assert(self->tag == MEMORY_RESIDENT);
        struct mem_extra *extra = this_get_exta(self);
        size_t *bucket_idxs = MALLOC(num_pairs * sizeof(size_t));

        PREFETCH_WRITE(bucket_idxs);

        for (size_t i = 0; i < num_pairs; i++) {
                const char *key = keys[i];
                hash32_t hash = STR_HASH_MEM_HASHCODE_OF(key);
                bucket_idxs[i] = hash % extra->buckets.cap_elems;
        }

        PREFETCH_READ(bucket_idxs);
        PREFETCH_READ(keys);
        PREFETCH_READ(values);

        CHECK_SUCCESS(this_insert_bulk(&extra->buckets,
                                           keys,
                                           values,
                                           bucket_idxs,
                                           num_pairs,
                                           &self->counters));
        free(bucket_idxs);
        return true;
}

static int this_put_safe_exact(str_hash *self, const char *key, archive_field_sid_t value)
{
        assert(self->tag == MEMORY_RESIDENT);
        struct mem_extra *extra = this_get_exta(self);

        hash32_t hash = strcmp("", key) != 0 ? STR_HASH_MEM_HASHCODE_OF(key) : 0;
        size_t bucket_idx = hash % extra->buckets.cap_elems;

        PREFETCH_READ(key);

        CHECK_SUCCESS(this_insert_exact(&extra->buckets,
                                            key,
                                            value,
                                            bucket_idx,
                                            &self->counters));

        return true;
}

static int this_put_fast_exact(str_hash *self, const char *key, archive_field_sid_t value)
{
        return this_put_safe_exact(self, key, value);
}

static int this_put_fast_bulk(str_hash *self, char *const *keys, const archive_field_sid_t *values,
                              size_t num_pairs)
{
        return this_put_safe_bulk(self, keys, values, num_pairs);
}

static int
this_fetch_bulk(vec ofType(bucket) *buckets, archive_field_sid_t *values_out, bool *key_found_mask,
                size_t *num_keys_not_found, size_t *bucket_idxs, char *const *keys, size_t num_keys,
                str_hash_counters *counter)
{
        UNUSED(counter)

        slice_handle result_handle;
        size_t num_not_found = 0;
        struct bucket *data = (struct bucket *) vec_data(buckets);

        PREFETCH_WRITE(values_out);

        for (size_t i = 0; i < num_keys; i++) {
                struct bucket *bucket = data + bucket_idxs[i];
                const char *key = keys[i];
                if (LIKELY(key != NULL)) {
                        slice_list_lookup(&result_handle, &bucket->slice_list, key);
                } else {
                        result_handle.is_contained = true;
                        result_handle.value = NULL_ENCODED_STRING;
                }

                num_not_found += result_handle.is_contained ? 0 : 1;
                key_found_mask[i] = result_handle.is_contained;
                values_out[i] = result_handle.is_contained ? result_handle.value : ((archive_field_sid_t) -1);
        }

        *num_keys_not_found = num_not_found;
        return true;
}

static int
this_fetch_single(vec ofType(bucket) *buckets, archive_field_sid_t *value_out, bool *key_found,
                  const size_t bucket_idx, const char *key, str_hash_counters *counter)
{
        UNUSED(counter);

        slice_handle handle;
        struct bucket *data = (struct bucket *) vec_data(buckets);

        PREFETCH_WRITE(value_out);
        PREFETCH_WRITE(key_found);

        struct bucket *bucket = data + bucket_idx;

        /** Optimization 1/5: EMPTY GUARD (but before "find" call); if this bucket has no occupied slots, do not perform any lookup and comparison */
        slice_list_lookup(&handle, &bucket->slice_list, key);
        *key_found = !slice_list_is_empty(&bucket->slice_list) && handle.is_contained;
        *value_out = (*key_found) ? handle.value : ((archive_field_sid_t) -1);

        return true;
}

static int
this_get_safe(str_hash *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
              char *const *keys, size_t num_keys)
{
        assert(self->tag == MEMORY_RESIDENT);

        timestamp begin = wallclock();
        TRACE(SMART_MAP_TAG, "'get_safe' function invoked for %zu strings", num_keys)

        struct mem_extra *extra = this_get_exta(self);
        size_t *bucket_idxs = MALLOC(num_keys * sizeof(size_t));
        archive_field_sid_t *values_out = MALLOC(num_keys * sizeof(archive_field_sid_t));
        bool *found_mask_out = MALLOC(num_keys * sizeof(bool));

        assert(bucket_idxs != NULL);
        assert(values_out != NULL);
        assert(found_mask_out != NULL);

        for (register size_t i = 0; i < num_keys; i++) {
                const char *key = keys[i];
                hash32_t hash = key && strcmp("", key) != 0 ? STR_HASH_MEM_HASHCODE_OF(key) : 0;
                bucket_idxs[i] = hash % extra->buckets.cap_elems;
                PREFETCH_READ((struct bucket *) vec_data(&extra->buckets) + bucket_idxs[i]);
        }

        TRACE(SMART_MAP_TAG, "'get_safe' function invoke fetch...for %zu strings", num_keys)
        CHECK_SUCCESS(this_fetch_bulk(&extra->buckets,
                                          values_out,
                                          found_mask_out,
                                          num_not_found,
                                          bucket_idxs,
                                          keys,
                                          num_keys,
                                          &self->counters));
        free(bucket_idxs);
        TRACE(SMART_MAP_TAG, "'get_safe' function invok fetch: done for %zu strings", num_keys)

        assert(values_out != NULL);
        assert(found_mask_out != NULL);

        *out = values_out;
        *found_mask = found_mask_out;

        timestamp end = wallclock();
        UNUSED(begin);
        UNUSED(end);
        TRACE(SMART_MAP_TAG, "'get_safe' function done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static int
this_get_safe_exact(str_hash *self, archive_field_sid_t *out, bool *found_mask, const char *key)
{
        assert(self->tag == MEMORY_RESIDENT);

        struct mem_extra *extra = this_get_exta(self);

        hash32_t hash = strcmp("", key) != 0 ? STR_HASH_MEM_HASHCODE_OF(key) : 0;
        size_t bucket_idx = hash % extra->buckets.cap_elems;
        PREFETCH_READ((struct bucket *) vec_data(&extra->buckets) + bucket_idx);

        CHECK_SUCCESS(this_fetch_single(&extra->buckets, out, found_mask, bucket_idx, key, &self->counters));

        return true;
}

static int this_get_fast(str_hash *self, archive_field_sid_t **out, char *const *keys, size_t num_keys)
{
        bool *found_mask;
        size_t num_not_found;
        int status = this_get_safe(self, out, &found_mask, &num_not_found, keys, num_keys);
        _str_hash_mem_free(self, found_mask);
        return status;
}

static int this_update_key_fast(str_hash *self, const archive_field_sid_t *values, char *const *keys,
                                size_t num_keys)
{
        UNUSED(self);
        UNUSED(values);
        UNUSED(keys);
        UNUSED(num_keys);
        ERROR(ERR_NOTIMPL, NULL);
        return false;
}

static int simple_map_remove(struct mem_extra *extra, size_t *bucket_idxs, char *const *keys, size_t num_keys,
                             str_hash_counters *counter)
{
        UNUSED(counter)

        slice_handle handle;
        struct bucket *data = (struct bucket *) vec_data(&extra->buckets);

        for (register size_t i = 0; i < num_keys; i++) {
                struct bucket *bucket = data + bucket_idxs[i];
                const char *key = keys[i];

                /** Optimization 1/5: EMPTY GUARD (but before "find" call); if this bucket has no occupied slots, do not perform any lookup and comparison */
                slice_list_lookup(&handle, &bucket->slice_list, key);
                if (LIKELY(handle.is_contained)) {
                        slice_list_remove(&bucket->slice_list, &handle);
                }
        }
        return true;
}

static int _str_hash_mem_remove(str_hash *self, char *const *keys, size_t num_keys)
{
        assert(self->tag == MEMORY_RESIDENT);

        struct mem_extra *extra = this_get_exta(self);
        size_t *bucket_idxs = MALLOC(num_keys * sizeof(size_t));
        for (register size_t i = 0; i < num_keys; i++) {
                const char *key = keys[i];
                hash32_t hash = STR_HASH_MEM_HASHCODE_OF(key);
                bucket_idxs[i] = hash % extra->buckets.cap_elems;
        }

        CHECK_SUCCESS(simple_map_remove(extra, bucket_idxs, keys, num_keys, &self->counters));
        free(bucket_idxs);
        return true;
}

static int _str_hash_mem_free(str_hash *self, void *ptr)
{
        UNUSED(self)
        assert(self->tag == MEMORY_RESIDENT);
        free(ptr);
        return true;
}

MAYBE_UNUSED
static int _str_hash_mem_create_extra(str_hash *self, size_t num_buckets, size_t cap_buckets)
{
        if ((self->extra = MALLOC(sizeof(struct mem_extra))) != NULL) {
                struct mem_extra *extra = this_get_exta(self);
                vec_create(&extra->buckets, sizeof(struct bucket), num_buckets);

                /** Optimization: notify the kernel that the list of buckets are accessed randomly (since hash based access)*/
                vec_madvise(&extra->buckets, MADV_RANDOM | MADV_WILLNEED);

                struct bucket *data = (struct bucket *) vec_data(&extra->buckets);
                CHECK_SUCCESS(bucket_create(data, num_buckets, cap_buckets));
                return true;
        } else {
                ERROR(ERR_MALLOCERR, NULL);
                return false;
        }
}

MAYBE_UNUSED
static struct mem_extra *this_get_exta(str_hash *self)
{
        assert (self->tag == MEMORY_RESIDENT);
        return (struct mem_extra *) (self->extra);
}

MAYBE_UNUSED
static int bucket_create(struct bucket *buckets, size_t num_buckets, size_t bucket_cap)
{
        // TODO: parallize this!
        while (num_buckets--) {
                struct bucket *bucket = buckets++;
                slice_list_create(&bucket->slice_list, bucket_cap);
        }

        return true;
}

static int bucket_drop(struct bucket *buckets, size_t num_buckets)
{
        while (num_buckets--) {
                struct bucket *bucket = buckets++;
                slice_list_drop(&bucket->slice_list);
        }

        return true;
}

static int bucket_insert(struct bucket *bucket, const char *restrict key, archive_field_sid_t value,
                         str_hash_counters *counter)
{
        UNUSED(counter);

        slice_handle handle;

        /** Optimization 1/5: EMPTY GUARD (but before "find" call); if this bucket has no occupied slots, do not perform any lookup and comparison */
        slice_list_lookup(&handle, &bucket->slice_list, key);

        if (handle.is_contained) {
                /** entry found by keys */
                assert(value == handle.value);
                //debug(SMART_MAP_TAG, "debug(SMART_MAP_TAG, \"*** put *** '%s' into bucket [new]\", keys);*** put *** '%s' into bucket [already contained]", keys);
        } else {
                /** no entry found */
                //debug(SMART_MAP_TAG, "*** put *** '%s' into bucket [new]", keys);
                slice_list_insert(&bucket->slice_list, (char **) &key, &value, 1);
        }

        return true;
}

static int this_insert_bulk(vec ofType(bucket) *buckets, char *const *restrict keys,
                            const archive_field_sid_t *restrict values, size_t *restrict bucket_idxs,
                            size_t num_pairs, str_hash_counters *counter)
{
        struct bucket *buckets_data = (struct bucket *) vec_data(buckets);
        int status = true;
        for (register size_t i = 0; status == true && i < num_pairs; i++) {
                size_t bucket_idx = bucket_idxs[i];
                const char *key = keys[i];
                archive_field_sid_t value = values[i];

                struct bucket *bucket = buckets_data + bucket_idx;
                status = bucket_insert(bucket, key, value, counter);
        }

        return status;
}

static int
this_insert_exact(vec ofType(bucket) *buckets, const char *restrict key, archive_field_sid_t value,
                  size_t bucket_idx, str_hash_counters *counter)
{
        struct bucket *buckets_data = (struct bucket *) vec_data(buckets);
        struct bucket *bucket = buckets_data + bucket_idx;
        return bucket_insert(bucket, key, value, counter);
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <karbonit/std/string.h>
#include <ctype.h>

bool str_buf_create(str_buf *buffer)
{
        return str_buf_create_ex(buffer, 1024);
}

bool str_buf_create_ex(str_buf *buffer, size_t capacity)
{
        buffer->cap = capacity;
        buffer->end = 0;
        buffer->data = MALLOC(capacity);
        ERROR_IF_AND_RETURN(!buffer->data, ERR_MALLOCERR, false);
        ZERO_MEMORY(buffer->data, buffer->cap);
        return true;
}

bool str_buf_add(str_buf *buffer, const char *str)
{
        u64 len = strlen(str);
        return str_buf_add_nchar(buffer, str, len);
}

bool str_buf_add_nchar(str_buf *buffer, const char *str, u64 strlen)
{
        /** resize if needed */
        if (strlen > 0) {
                if (UNLIKELY(buffer->end + strlen >= buffer->cap)) {
                        size_t new_cap = (buffer->end + strlen) * 1.7f;
                        buffer->data = realloc(buffer->data, new_cap);
                        ERROR_IF_AND_RETURN(!buffer->data, ERR_REALLOCERR, false);
                        ZERO_MEMORY(buffer->data + buffer->cap, (new_cap - buffer->cap));
                        buffer->cap = new_cap;
                }

                /** append str_buf */
                memcpy(buffer->data + buffer->end, str, strlen);
                buffer->end += strlen;
        }
        return true;
}

void str_buf_add_nquote(str_buf *buffer, const char *str, u64 strlen)
{
        str_buf_add_char(buffer, '"');
        str_buf_add_nchar(buffer, str, strlen);
        str_buf_add_char(buffer, '"');
}

bool str_buf_add_char(str_buf *buffer, char c)
{
        char buff[2];
        sprintf(buff, "%c", c);
        return str_buf_add(buffer, buff);
        return true;
}

bool str_buf_add_u8(str_buf *buffer, u8 value)
{
        char buff[21];
        ZERO_MEMORY(buff, ARRAY_LENGTH(buff));
        sprintf(buff, "%u", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_u16(str_buf *buffer, u16 value)
{
        char buff[21];
        sprintf(buff, "%u", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_u32(str_buf *buffer, u32 value)
{
        char buff[21];
        sprintf(buff, "%u", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_u64(str_buf *buffer, u64 value)
{
        char buff[21];
        sprintf(buff, "%" PRIu64, value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_i8(str_buf *buffer, i8 value)
{
        char buff[21];
        sprintf(buff, "%d", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_i16(str_buf *buffer, i16 value)
{
        char buff[21];
        sprintf(buff, "%d", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_i32(str_buf *buffer, i32 value)
{
        char buff[21];
        sprintf(buff, "%d", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_i64(str_buf *buffer, i64 value)
{
        char buff[21];
        sprintf(buff, "%" PRIi64, value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_u64_as_hex(str_buf *buffer, u64 value)
{
        char buff[17];
        sprintf(buff, "%016"PRIx64, value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_u64_as_hex_0x_prefix_compact(str_buf *buffer, u64 value)
{
        char buff[17];
        sprintf(buff, "0x%"PRIx64, value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_float(str_buf *buffer, float value)
{
        char buff[2046];
        sprintf(buff, "%0.2f", value);
        return str_buf_add(buffer, buff);
}

bool str_buf_add_bool(str_buf *buffer, bool value)
{
        char buff[6];
        sprintf(buff, "%s", value ? "true" : "false");
        return str_buf_add(buffer, buff);
}

bool str_buf_add_boolean(str_buf *buffer, boolean value)
{
        char buff[6];
        if (IS_NULL_BOOLEAN(value)) {
                sprintf(buff, "null");
        } else {
                sprintf(buff, "%s", value ? "true" : "false");
        }

        return str_buf_add(buffer, buff);
}

bool str_buf_clear(str_buf *buffer)
{
        ZERO_MEMORY(buffer->data, buffer->cap);
        buffer->end = 0;
        return true;
}

bool str_buf_ensure_capacity(str_buf *buffer, u64 cap)
{
        /** resize if needed */
        if (UNLIKELY(cap > buffer->cap)) {
                size_t new_cap = cap * 1.7f;
                buffer->data = realloc(buffer->data, new_cap);
                ERROR_IF_AND_RETURN(!buffer->data, ERR_REALLOCERR, false);
                ZERO_MEMORY(buffer->data + buffer->cap, (new_cap - buffer->cap));
                buffer->cap = new_cap;
        }
        return true;
}

size_t string_len(str_buf *buffer)
{
        return buffer->end;
}

bool str_buf_trim(str_buf *buffer)
{
        if (buffer->end > 0) {
                char *string = buffer->data;
                int len = strlen(string);

                while (isspace(string[len - 1])) {
                        string[--len] = '\0';
                }
                while (*string && isspace(*string)) {
                        ++string;
                        --len;
                }

                buffer->end = len + 1;
                memmove(buffer->data, string, buffer->end);
        }
        return true;
}

bool str_buf_is_empty(str_buf *buffer)
{
        return buffer ? (buffer->end == 0 || (buffer->end == 1 && buffer->data[0] == '\0')) : true;
}

bool str_buf_drop(str_buf *buffer)
{
        free(buffer->data);
        return true;
}

bool str_buf_print(str_buf *buffer)
{
        return str_buf_fprint(stdout, buffer);
}

bool str_buf_fprint(FILE *file, str_buf *buffer)
{
        fprintf(file, "%s\n", str_buf_cstr(buffer));
        return true;
}

const char *str_buf_cstr(str_buf *buffer)
{
        return buffer->data;
}/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdlib.h>
#include <karbonit/std/string.h>
#include <stdio.h>
#include <signal.h>

#include <karbonit/std/thread_pool.h>

static inline void __execute_task();

thread_pool *thread_pool_create(size_t num_threads, int enable_monitoring)
{
        thread_pool *pool = MALLOC(sizeof(thread_pool));

        pool->name = NULL;
        pool->size = num_threads;
        pool->capacity = num_threads * 2;
        priority_queue_init(&pool->waiting_tasks);

        pool->thread_tasks = calloc(num_threads, sizeof(thread_task *));
        pool->thread_infos = calloc(sizeof(thread_info *) * pool->capacity, 1);
        pool->task_state_capacity = THREAD_POOL_MAX_TASKS;
        pool->task_group_states = calloc(pool->task_state_capacity, sizeof(task_state));
        pool->enable_monitoring = enable_monitoring;

        pthread_t *threads = MALLOC(sizeof(pthread_t) * pool->capacity);
        pool->pool = threads;

        if (enable_monitoring) {
                pool->statistics = calloc(1, sizeof(thread_pool_stats));
        }

        for (size_t i = 0; i < pool->capacity; i++) {
                // one block per thread to reduce risk of two threads sharing the same cache line
                thread_info *thread_info = malloc(sizeof(struct thread_info));
                pool->thread_infos[i] = thread_info;
                thread_info->pool = pool;
                thread_info->id = i;
                thread_info->status = THREAD_STATUS_EMPTY;
                sprintf(thread_info->name, "worker-%zu", i); // "worker%I64d" lead to segfault on linux

                if (enable_monitoring) {
                        thread_info->statistics = calloc(1, sizeof(thread_stats));
                }

        }
        for (size_t i = 0; i < num_threads; ++i) {
                __create_thread(pool->thread_infos[i], &pool->pool[i]);
        }

        return pool;
}

thread_pool *thread_pool_create_named(size_t num_threads, const char *name, int enable_monitoring)
{
        thread_pool *pool = thread_pool_create(num_threads, enable_monitoring);

        if (name) {
                thread_pool_set_name(pool, name);
        }

        return pool;
}

void thread_pool_free(thread_pool *pool)
{
        // Update all status
        for (size_t i = 0; i < pool->size; ++i) {
                pool->thread_infos[i]->status = THREAD_STATUS_WILL_TERMINATE;
        }
        // wait for threads to finish
        for (size_t i = 0; i < pool->size; ++i) {
                pthread_join(pool->pool[i], NULL);
                if (pool->enable_monitoring) {
                        free(pool->thread_infos[i]->statistics);
                }

                free(pool->thread_infos[i]);
        }
        for (size_t i = pool->size; i < pool->capacity; ++i) {
                if (pool->enable_monitoring) {
                        free(pool->thread_infos[i]->statistics);
                }

                free(pool->thread_infos[i]);
        }

        priority_queue_free(&pool->waiting_tasks);
        free(pool->pool);
        free(pool->thread_tasks);
        free(pool->thread_infos);
        free(pool->task_group_states);
        if (pool->name) {
                free(pool->name);
        }
        if (pool->enable_monitoring) {
                free(pool->statistics);
        }
        free(pool);
}

void thread_pool_set_name(thread_pool *pool, const char *name)
{
        if (pool->name) {
                free(pool->name);
        }

        size_t s = strlen(name);
        char *str = MALLOC(s + 1);
        strcpy(str, name);
        pool->name = str;
}

bool thread_pool_resize(thread_pool *pool, size_t num_threads)
{
        if (num_threads > pool->size) {
                if (num_threads > pool->capacity) {
                        return false;
                }

                for (size_t i = pool->size; i < num_threads; ++i) {
                        //try to revive thread
                        int will_terminate = THREAD_STATUS_WILL_TERMINATE;
                        if (atomic_compare_exchange_strong(&pool->thread_infos[i]->status,
                                                           &will_terminate,
                                                           THREAD_STATUS_IDLE)) {}
                        else {
                                // create a new
                                if (pool->enable_monitoring && !pool->thread_infos[i]->statistics) {
                                        pool->thread_infos[i]->statistics = calloc(1, sizeof(thread_stats));
                                }
                                __create_thread(pool->thread_infos[i], &pool->pool[i]);
                        }
                }
        } else if (num_threads < pool->size) {
                for (size_t i = num_threads; i < pool->size; ++i) {
                        // mark threads for termination
                        pool->thread_infos[i]->status = THREAD_STATUS_WILL_TERMINATE;
                }
        }

        pool->size = num_threads;

        return true;
}

bool thread_pool_enqueue_tasks(thread_task *tasks, thread_pool *pool, size_t num_tasks,
                               task_handle *hndl)
{
        // find UNUSED slot
        size_t ind = 0;

        for (; pool->task_group_states[ind].task_count; ind = (ind + 8) % THREAD_POOL_MAX_TASKS) {}

        // increment generation first to always be identifiable as finished
        ++pool->task_group_states[ind].generation;
        pool->task_group_states[ind].task_count = num_tasks;

        for (size_t i = 0; i < num_tasks; i++) {

                if (pool->enable_monitoring) {
                        //tasks[i].statistics = calloc(1, sizeof(task_stats));
                        clock_gettime(CLOCK_MONOTONIC, &tasks[i].statistics.enqueue_time);
                        pool->statistics->task_enqueued_count++;
                }

                tasks[i].group_id = ind;
                priority_queue_push(&pool->waiting_tasks, &tasks[i], tasks[i].priority);
        }

        if (hndl) {
                hndl->index = ind;
                hndl->generation = pool->task_group_states[ind].generation;
        }

        return true;
}

bool thread_pool_enqueue_task(thread_task *task, thread_pool *pool, task_handle *hndl)
{
        return thread_pool_enqueue_tasks(task, pool, 1, hndl);
}

bool thread_pool_enqueue_tasks_wait(thread_task *tasks, thread_pool *pool, size_t num_tasks)
{
        // Pass all tasks except the last one to the queue
        task_handle hndl;
        thread_pool_enqueue_tasks(tasks, pool, num_tasks - 1, &hndl);

        // Execute the last tasks in the calling thread
        thread_task *main_task = &tasks[num_tasks - 1];

        if (pool->enable_monitoring) {
                pool->statistics->task_enqueued_count++;
                //main_task->statistics = calloc(1, sizeof(task_stats));

                // No waiting if the calling thread executes the task
                clock_gettime(CLOCK_MONOTONIC, &main_task->statistics.enqueue_time);
                main_task->statistics.execution_time = main_task->statistics.enqueue_time;

                (*main_task->routine)(main_task->args);
                clock_gettime(CLOCK_MONOTONIC, &main_task->statistics.complete_time);
                pool->statistics->task_complete_count++;
        } else {
                (*main_task->routine)(main_task->args);
        }

        return thread_pool_wait_for_task(pool, &hndl);
}

bool thread_pool_wait_for_task(thread_pool *pool, task_handle *hndl)
{
        volatile unsigned *gen = &pool->task_group_states[hndl->index].generation;
        while (*gen == hndl->generation && pool->task_group_states[hndl->index].task_count) {}
        return true;
}

bool thread_pool_wait_for_all(thread_pool *pool)
{
        thread_task *next_task;
        while ((next_task = __get_next_task(pool))) {

                if (pool->enable_monitoring) {
                        clock_gettime(CLOCK_MONOTONIC, &next_task->statistics.execution_time);
                        __execute_task(pool, next_task);
                        clock_gettime(CLOCK_MONOTONIC, &next_task->statistics.complete_time);
                        pool->statistics->task_complete_count++;

                        // Just add the time, calculate the average at evaluation time
                        pool->statistics->wait_time += __get_time_diff(&next_task->statistics.enqueue_time,
                                                                       &next_task->statistics.execution_time);
                        pool->statistics->complete_time += __get_time_diff(&next_task->statistics.execution_time,
                                                                           &next_task->statistics.complete_time);
                } else {
                        __execute_task(pool, next_task);
                }

        }
        for (;;) {
                size_t sum = 0;
                for (size_t i = 0; i < pool->task_state_capacity; ++i) {
                        sum += pool->task_group_states[i].task_count;
                }
                if (!sum) { return true; }
        }
        return false;
}

void *__thread_main(void *args)
{
        thread_info *thread_info = (struct thread_info *) args;

        // Fill statistics if available
        struct timespec begin;
        if (thread_info->pool->enable_monitoring) {
                clock_gettime(CLOCK_MONOTONIC, &thread_info->statistics->creation_time);
                begin = thread_info->statistics->creation_time;
        }

        while (1) {
                thread_task *next_task = __get_next_task(thread_info->pool);
                // the task has to be executed since it has been taken out of the queue
                if (next_task) {

                        // Fill statistics if available
                        if (thread_info->pool->enable_monitoring) {
                                // measure time outside to prevent incorrect times while in execution
                                struct timespec end;
                                clock_gettime(CLOCK_MONOTONIC, &end);
                                next_task->statistics.execution_time = end;
                                thread_info->statistics->idle_time += __get_time_diff(&begin, &end);

                                __execute_task(thread_info->pool, next_task);
                                clock_gettime(CLOCK_MONOTONIC, &begin);
                                next_task->statistics.complete_time = begin;
                                thread_info->statistics->task_count++;
                                thread_info->pool->statistics->task_complete_count++;

                                // Just add the time, calculate the average at evaluation time
                                thread_info->pool->statistics->wait_time +=
                                        __get_time_diff(&next_task->statistics.enqueue_time,
                                                        &next_task->statistics.execution_time);
                                thread_info->pool->statistics->complete_time +=
                                        __get_time_diff(&next_task->statistics.execution_time,
                                                        &next_task->statistics.complete_time);

                        } else {
                                __execute_task(thread_info->pool, next_task);
                        }

                }

                // Check if this thread has to terminate, set the status and leave the loop
                int will_terminate = THREAD_STATUS_WILL_TERMINATE;
                if (atomic_compare_exchange_strong(&thread_info->status, &will_terminate, THREAD_STATUS_KILLED)) {
                        break;
                }


//    if(!next_task)
//      nanosleep(&waiting_time_start, &waiting_time_end);
        }

        thread_info->status = THREAD_STATUS_FINISHED;

        // Be sure to free the passed thread_information since no other reference exists
        // free(thread_info);

        return (void *) 0;
}

thread_task *__get_next_task(thread_pool *pool)
{
        thread_task *next_task = priority_queue_pop(&pool->waiting_tasks);
        return next_task;
}

bool __create_thread(thread_info *thread_info, pthread_t *pp)
{
        thread_info->status = THREAD_STATUS_CREATED;
        pthread_create(pp, NULL, &__thread_main, thread_info);

        return true;
}

void *faulty;

size_t num;

void __execute_task(thread_pool *pool, thread_task *task)
{
        faulty = task->routine;
        num++;
        (*task->routine)(task->args);
        --pool->task_group_states[task->group_id].task_count;
}

void __sig_seg(int sig)
{
        if (sig != SIGSEGV) {
                return;
        } else {
                printf("%p \n", faulty);
                printf("occured after: %li", num);
                exit(1);
        }
}/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>

#include <karbonit/stdinc.h>
#include <karbonit/std/thread_pool.h>

thread_pool_stats thread_pool_get_stats(thread_pool *pool)
{
        // In case no tasks care completed, no averages can be calculated
        if (pool->statistics->task_complete_count) {
                pool->statistics->avg_complete_time =
                        pool->statistics->complete_time / pool->statistics->task_complete_count;
                pool->statistics->avg_wait_time = pool->statistics->wait_time / pool->statistics->task_complete_count;
        }
        return *pool->statistics;
}

thread_stats thread_pool_get_thread_stats(thread_pool *pool, size_t id)
{
        thread_stats *thread_stats = pool->thread_infos[id]->statistics;

        // busy_time = running_time - idle_time
        struct timespec current;
        clock_gettime(CLOCK_MONOTONIC, &current);
        thread_stats->busy_time = __get_time_diff(&thread_stats->creation_time, &current) - thread_stats->idle_time;
        return *thread_stats;
}

double thread_pool_get_time_working(thread_pool *pool)
{
        struct timespec end;

        clock_gettime(CLOCK_MONOTONIC, &end);
        double avg = 0.f;
        for (size_t i = 0; i < pool->size; ++i) {
                struct timespec begin = pool->thread_infos[i]->statistics->creation_time;
                double t = __get_time_diff(&begin, &end);
                avg += t / (t + pool->thread_infos[i]->statistics->idle_time);
        }
        return avg / pool->size;
}/**
 * A variable-length unsigned integer type that encodes the number of used bytes by a preceding marker byte
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/uintvar/marker.h>

bool uintvar_marker_write(uintvar_marker_t dst, u64 value);

u64 uintvar_marker_read(u8 *nbytes_read, uintvar_marker_t src);

uintvar_marker_e uintvar_marker_type_for(u64 value);

bool uintvar_marker_type(const void *data);

size_t uintvar_marker_sizeof(uintvar_marker_t value);

size_t uintvar_marker_required_size(u64 value);/**
 * A variable-length unsigned integer type (varuint)
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/std/uintvar/stream.h>

#define extract_data(x, byte_shift)     (MASK_BLOCK_DATA & (MASK_LAST_BYTE & (x >> byte_shift)))

u8 uintvar_stream_write(uintvar_stream_t dst, u64 value)
{
        if (LIKELY(dst != NULL)) {
                u8 num_bytes = 0;
                for (i8 i = 9; i > 0; i--) {
                        char block_data = extract_data(value, i * 7);
                        if (block_data || num_bytes) {
                                *(char *) dst = MASK_FORWARD_BIT | block_data;
                                num_bytes = num_bytes ? num_bytes : i + 1;
                                dst++;
                        }
                }
                *(char *) dst = extract_data(value, 0);
                return num_bytes ? num_bytes : 1;
        } else {
                return 0;
        }
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <sys/mman.h>

#include <karbonit/mem/memfile.h>
#include <karbonit/std/vec.h>

#define DEFINE_PRINTER_FUNCTION_WCAST(type, castType, format_string)                                                   \
void vec_##type##_printer_func(memfile *dst, void ofType(T) *values, size_t num_elems)                      \
{                                                                                                                      \
    char *data;                                                                                                        \
    type *typedValues = (type *) values;                                                                               \
                                                                                                                       \
    data = MEMFILE_CURRENT_POS(dst, sizeof(char));                                                              \
    int nchars = sprintf(data, "[");                                                                                   \
    MEMFILE_SKIP(dst, nchars);                                                                                  \
    for (size_t i = 0; i < num_elems; i++) {                                                                           \
        data = MEMFILE_CURRENT_POS(dst, sizeof(type));                                                          \
        nchars = sprintf(data, format_string"%s", (castType) typedValues[i], i + 1 < num_elems ? ", " : "");           \
        MEMFILE_SKIP(dst, nchars);                                                                              \
    }                                                                                                                  \
    data = MEMFILE_CURRENT_POS(dst, sizeof(char));                                                              \
    nchars = sprintf(data, "]");                                                                                       \
    MEMFILE_SKIP(dst, nchars);                                                                                  \
}

#define DEFINE_PRINTER_FUNCTION(type, format_string)                                                                   \
    DEFINE_PRINTER_FUNCTION_WCAST(type, type, format_string)

DEFINE_PRINTER_FUNCTION_WCAST(u_char, i8, "%d")

DEFINE_PRINTER_FUNCTION(i8, "%d")

DEFINE_PRINTER_FUNCTION(i16, "%d")

DEFINE_PRINTER_FUNCTION(i32, "%d")

DEFINE_PRINTER_FUNCTION(i64, "%"
        PRIi64)

DEFINE_PRINTER_FUNCTION(u8, "%d")

DEFINE_PRINTER_FUNCTION(u16, "%d")

DEFINE_PRINTER_FUNCTION(u32, "%d")

DEFINE_PRINTER_FUNCTION(u64, "%"
        PRIu64)

DEFINE_PRINTER_FUNCTION(size_t, "%zu")

bool vec_create(vec *out, size_t elem_size, size_t cap_elems)
{
        out->base = MALLOC(cap_elems * elem_size);
        out->num_elems = 0;
        out->cap_elems = cap_elems;
        out->elem_size = elem_size;
        out->grow_factor = 1.7f;
        return true;
}

typedef struct vec_serialize_header {
        char marker;
        u32 elem_size;
        u32 num_elems;
        u32 cap_elems;
        float grow_factor;
} vec_serialize_header;

bool vec_to_file(FILE *file, vec *vec)
{
        vec_serialize_header header =
                {.marker = MARKER_SYMBOL_VEC_HEADER, .elem_size = vec->elem_size, .num_elems = vec
                        ->num_elems, .cap_elems = vec->cap_elems, .grow_factor = vec->grow_factor};
        int nwrite = fwrite(&header, sizeof(vec_serialize_header), 1, file);
        ERROR_IF_AND_RETURN(nwrite != 1, ERR_FWRITE_FAILED, NULL);
        nwrite = fwrite(vec->base, vec->elem_size, vec->num_elems, file);
        ERROR_IF_AND_RETURN(nwrite != (int) vec->num_elems, ERR_FWRITE_FAILED, NULL);

        return true;
}

bool vec_from_file(vec *vec, FILE *file)
{
        offset_t start = ftell(file);
        int err_code = ERR_NOERR;

        vec_serialize_header header;
        if (fread(&header, sizeof(vec_serialize_header), 1, file) != 1) {
                err_code = ERR_FREAD_FAILED;
                goto error_handling;
        }

        if (header.marker != MARKER_SYMBOL_VEC_HEADER) {
                err_code = ERR_CORRUPTED;
                goto error_handling;
        }

        vec->base = MALLOC(header.cap_elems * header.elem_size);
        vec->num_elems = header.num_elems;
        vec->cap_elems = header.cap_elems;
        vec->elem_size = header.elem_size;
        vec->grow_factor = header.grow_factor;

        if (fread(vec->base, header.elem_size, vec->num_elems, file) != vec->num_elems) {
                err_code = ERR_FREAD_FAILED;
                goto error_handling;
        }

        return true;

        error_handling:
        fseek(file, start, SEEK_SET);
        ERROR(err_code, NULL);
        return false;
}

bool vec_madvise(vec *vec, int madviseAdvice)
{
        UNUSED(vec);
        UNUSED(madviseAdvice);
        madvise(vec->base, vec->cap_elems * vec->elem_size, madviseAdvice);
        return true;
}

bool vec_set_grow_factor(vec *vec, float factor)
{
        if (UNLIKELY(factor <= 1.01f)) {
                return ERROR(ERR_ILLEGALARG, NULL);
        }

        vec->grow_factor = factor;
        return true;
}

bool vec_drop(vec *vec)
{
        free(vec->base);
        vec->base = NULL;
        return true;
}

bool vec_is_empty(const vec *vec)
{
        return vec->num_elems == 0 ? true : false;
}

bool vec_push(vec *vec, const void *data, size_t num_elems)
{
        size_t next_num = vec->num_elems + num_elems;
        while (next_num > vec->cap_elems) {
                size_t more = next_num - vec->cap_elems;
                vec->cap_elems = (vec->cap_elems + more) * vec->grow_factor;
                vec->base = realloc(vec->base, vec->cap_elems * vec->elem_size);
        }
        memcpy(vec->base + vec->num_elems * vec->elem_size, data, num_elems * vec->elem_size);
        vec->num_elems += num_elems;
        return true;
}

const void *vec_peek(vec *vec)
{
        if (!vec) {
                return NULL;
        } else {
                return (vec->num_elems > 0) ? vec_at(vec, vec->num_elems - 1) : NULL;
        }
}

bool vec_repeated_push(vec *vec, const void *data, size_t how_often)
{
        size_t next_num = vec->num_elems + how_often;
        while (next_num > vec->cap_elems) {
                size_t more = next_num - vec->cap_elems;
                vec->cap_elems = (vec->cap_elems + more) * vec->grow_factor;
                vec->base = realloc(vec->base, vec->cap_elems * vec->elem_size);
        }
        for (size_t i = 0; i < how_often; i++) {
                memcpy(vec->base + (vec->num_elems + i) * vec->elem_size, data, vec->elem_size);
        }

        vec->num_elems += how_often;
        return true;
}

const void *vec_pop(vec *vec)
{
        void *result;
        if (LIKELY((result = (vec ? (vec->num_elems > 0 ? vec->base + (vec->num_elems - 1) * vec->elem_size : NULL)
                                      : NULL)) != NULL)) {
                vec->num_elems--;
        }
        return result;
}

bool vec_clear(vec *vec)
{
        vec->num_elems = 0;
        return true;
}

bool vec_shrink(vec *vec)
{
        if (vec->num_elems < vec->cap_elems) {
                vec->cap_elems = JAK_MAX(1, vec->num_elems);
                vec->base = realloc(vec->base, vec->cap_elems * vec->elem_size);
        }
        return true;
}

bool vec_grow(size_t *numNewSlots, vec *vec)
{
        size_t freeSlotsBefore = vec->cap_elems - vec->num_elems;

        vec->cap_elems = (vec->cap_elems * vec->grow_factor) + 1;
        vec->base = realloc(vec->base, vec->cap_elems * vec->elem_size);
        size_t freeSlotsAfter = vec->cap_elems - vec->num_elems;
        if (LIKELY(numNewSlots != NULL)) {
                *numNewSlots = freeSlotsAfter - freeSlotsBefore;
        }
        return true;
}

bool vec_grow_to(vec *vec, size_t capacity)
{
        vec->cap_elems = JAK_MAX(vec->cap_elems, capacity);
        vec->base = realloc(vec->base, vec->cap_elems * vec->elem_size);
        return true;
}

const void *vec_at(const vec *vec, size_t pos)
{
        return (vec && pos < vec->num_elems) ? vec->base + pos * vec->elem_size : NULL;
}

size_t vec_capacity(const vec *vec)
{
        return vec->cap_elems;
}

bool vec_enlarge_size_to_capacity(vec *vec)
{
        vec->num_elems = vec->cap_elems;
        return true;
}

bool vec_zero_memory(vec *vec)
{
        ZERO_MEMORY(vec->base, vec->elem_size * vec->num_elems);
        return true;
}

bool vec_zero_memory_in_range(vec *vec, size_t from, size_t to)
{
        assert(from < to);
        assert(to <= vec->cap_elems);
        ZERO_MEMORY(vec->base + from * vec->elem_size, vec->elem_size * (to - from));
        return true;
}

bool vec_set(vec *vec, size_t pos, const void *data)
{
        assert(pos < vec->num_elems);
        memcpy(vec->base + pos * vec->elem_size, data, vec->elem_size);
        return true;
}

bool vec_cpy(vec *dst, const vec *src)
{
        CHECK_SUCCESS(vec_create(dst, src->elem_size, src->num_elems));
        dst->num_elems = src->num_elems;
        if (dst->num_elems > 0) {
                memcpy(dst->base, src->base, src->elem_size * src->num_elems);
        }
        return true;
}

bool vec_cpy_to(vec *dst, vec *src)
{
        void *handle = realloc(dst->base, src->cap_elems * src->elem_size);
        if (handle) {
                dst->elem_size = src->elem_size;
                dst->num_elems = src->num_elems;
                dst->cap_elems = src->cap_elems;
                dst->grow_factor = src->grow_factor;
                dst->base = handle;
                memcpy(dst->base, src->base, src->cap_elems * src->elem_size);
                return true;
        } else {
                return ERROR(ERR_HARDCOPYFAILED, NULL);
        }
}

const void *vec_data(const vec *vec)
{
        return vec ? vec->base : NULL;
}

char *vec_string(const vec ofType(T) *vec,
                    void (*printerFunc)(memfile *dst, void ofType(T) *values, size_t num_elems))
{
        memblock *block;
        memfile file;
        MEMBLOCK_CREATE(&block, vec->num_elems * vec->elem_size);
        MEMFILE_OPEN(&file, block, READ_WRITE);
        printerFunc(&file, vec->base, vec->num_elems);
        return MEMBLOCK_MOVE_CONTENTS_AND_DROP(block);
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>

#include <karbonit/stdx/slicelist.h>
#include <karbonit/std/hash.h>

#define SLICE_LIST_TAG "slice-list"

#define get_hashcode(key)    HASH_ADDITIVE(strlen(key), key)

/** OPTIMIZATION: we have only one item to find. Use branch-less scan instead of branching scan */
/** OPTIMIZATION: find function as macro */
#define SLICE_SCAN(slice, needle_hash, needle_str)                                                                     \
({                                                                                                                     \
    TRACE(SLICE_LIST_TAG, "SLICE_SCAN for '%s' started", needle_str);                                    \
    assert(slice);                                                                                                     \
    assert(needle_str);                                                                                                \
                                                                                                                       \
    register bool continueScan, keysMatch, keyHashsNoMatch, endReached;                                                \
    register bool cacheAvailable = (slice->cache_idx != (u32) -1);                                                 \
    register bool hashsEq = cacheAvailable && (slice->key_hash_column[slice->cache_idx] == needle_hash);                  \
    register bool cacheHit = hashsEq && (strcmp(slice->key_column[slice->cache_idx], needle_str) == 0);                 \
    register uint_fast32_t i = 0;                                                                                      \
    if (!cacheHit) {                                                                                                   \
        do {                                                                                                           \
            while ((keyHashsNoMatch = (slice->key_hash_column[i]!=needle_hash)) && i++<slice->num_elems) { ; }           \
            endReached    = ((i+1)>slice->num_elems);                                                                  \
            keysMatch      = endReached || (!keyHashsNoMatch && (strcmp(slice->key_column[i], needle_str)==0));        \
            continueScan  = !endReached && !keysMatch;                                                                 \
            i             += continueScan;                                                                             \
        }                                                                                                              \
        while (continueScan);                                                                                          \
        slice->cache_idx = !endReached && keysMatch ? i : slice->cache_idx;                                              \
    }                                                                                                                  \
    cacheHit ? slice->cache_idx : (!endReached && keysMatch ? i : slice->num_elems);                                    \
})

#define SLICE_BESEARCH(slice, needle_hash, needle_str)                                                                 \
({                                                                                                                     \
    0; \
})

static void appenderNew(slice_list_t *list);

static void appenderSeal(slice *slice);

static void _slicelist_lock(slice_list_t *list);

static void _slicelist_unlock(slice_list_t *list);

bool slice_list_create(slice_list_t *list, size_t slice_capacity)
{
        spinlock_init(&list->lock);

        vec_create(&list->slices, sizeof(slice), slice_capacity);
        vec_create(&list->descriptors, sizeof(slice_descriptor), slice_capacity);
        vec_create(&list->filters, sizeof(bitmap), slice_capacity);
        vec_create(&list->bounds, sizeof(hash_bounds), slice_capacity);

        ZERO_MEMORY(vec_data(&list->slices), slice_capacity * sizeof(slice));
        ZERO_MEMORY(vec_data(&list->descriptors), slice_capacity * sizeof(slice_descriptor));
        ZERO_MEMORY(vec_data(&list->filters), slice_capacity * sizeof(bitmap));
        ZERO_MEMORY(vec_data(&list->bounds), slice_capacity * sizeof(hash_bounds));

        appenderNew(list);

        return true;
}

bool slice_list_drop(slice_list_t *list)
{
        UNUSED(list);

        vec_drop(&list->slices);
        vec_drop(&list->descriptors);
        vec_drop(&list->bounds);
        for (size_t i = 0; i < list->filters.num_elems; i++) {
                bitmap *filter = VEC_GET(&list->filters, i, bitmap);
                bloom_drop(filter);
        }
        vec_drop(&list->filters);
        return true;
}

bool slice_list_is_empty(const slice_list_t *list)
{
        return (vec_is_empty(&list->slices));
}

bool slice_list_insert(slice_list_t *list, char **strings, archive_field_sid_t *ids, size_t num_pairs)
{
        _slicelist_lock(list);

        while (num_pairs--) {
                const char *key = *strings++;
                archive_field_sid_t value = *ids++;
                hash32_t keyHash = get_hashcode(key);
                slice_handle handle;
                int status;

                assert (key);

                /** check whether the keys-values pair is already contained in one slice */
                status = slice_list_lookup(&handle, list, key);

                if (status == true) {
                        /** pair was found, do not insert it twice */
                        assert (value == handle.value);
                        continue;
                } else {
                        /** pair is not found; append it */
                        hash_bounds *restrict bounds = VEC_ALL(&list->bounds, hash_bounds);
                        bitmap *restrict filters = VEC_ALL(&list->filters, bitmap);
                        slice *restrict slices = VEC_ALL(&list->slices, slice);

                        slice *restrict appender = slices + list->appender_idx;
                        bitmap *restrict appenderFilter = filters + list->appender_idx;
                        hash_bounds *restrict appenderBounds = bounds + list->appender_idx;

                        DEBUG(SLICE_LIST_TAG,
                                  "appender # of elems: %zu, limit: %zu",
                                  appender->num_elems,
                                  SLICE_KEY_COLUMN_MAX_ELEMS);
                        assert(appender->num_elems < SLICE_KEY_COLUMN_MAX_ELEMS);
                        appender->key_column[appender->num_elems] = key;
                        appender->key_hash_column[appender->num_elems] = keyHash;
                        appender->string_id_column[appender->num_elems] = value;
                        appenderBounds->min_hash = appenderBounds->min_hash < keyHash ? appenderBounds->min_hash : keyHash;
                        appenderBounds->max_hash = appenderBounds->max_hash > keyHash ? appenderBounds->max_hash : keyHash;
                        BLOOM_SET(appenderFilter, &keyHash, sizeof(hash32_t));
                        appender->num_elems++;
                        if (UNLIKELY(appender->num_elems == SLICE_KEY_COLUMN_MAX_ELEMS)) {
                                appenderSeal(appender);
                                appenderNew(list);
                        }
                }
        }

        _slicelist_unlock(list);
        return true;
}

bool slice_list_lookup(slice_handle *handle, slice_list_t *list, const char *needle)
{
        UNUSED(list);
        UNUSED(handle);
        UNUSED(needle);

        hash32_t keyHash = get_hashcode(needle);
        u32 numSlices = VEC_LENGTH(&list->slices);

        /** check whether the keys-values pair is already contained in one slice */
        hash_bounds *restrict bounds = VEC_ALL(&list->bounds, hash_bounds);
        bitmap *restrict filters = VEC_ALL(&list->filters, bitmap);
        slice *restrict slices = VEC_ALL(&list->slices, slice);
        slice_descriptor *restrict descs = VEC_ALL(&list->descriptors, slice_descriptor);

        for (register u32 i = 0; i < numSlices; i++) {
                slice_descriptor *restrict desc = descs + i;
                hash_bounds *restrict bound = bounds + i;
                slice *restrict slice = slices + i;

                desc->num_reads_all++;

                if (slice->num_elems > 0) {
                        bool keyHashIn = keyHash >= bound->min_hash && keyHash <= bound->max_hash;
                        if (keyHashIn) {
                                bitmap *restrict filter = filters + i;
                                bool maybeContained = BLOOM_TEST(filter, &keyHash, sizeof(hash32_t));
                                if (maybeContained) {
                                        DEBUG(SLICE_LIST_TAG,
                                                  "slice_list_lookup_by_key keys(%s) -> ?",
                                                  needle);
                                        u32 pairPosition;

                                        switch (slice->strat) {
                                                case SLICE_LOOKUP_SCAN:
                                                        pairPosition = SLICE_SCAN(slice, keyHash, needle);
                                                        break;
                                                case SLICE_LOOKUP_BESEARCH:
                                                        pairPosition = SLICE_BESEARCH(slice, keyHash, needle);
                                                        break;
                                                default:
                                                        return ERROR(ERR_UNSUPFINDSTRAT, NULL);
                                        }

                                        DEBUG(SLICE_LIST_TAG,
                                                  "slice_list_lookup_by_key keys(%s) -> pos(%zu in slice #%zu)",
                                                  needle,
                                                  pairPosition,
                                                  i);
                                        if (pairPosition < slice->num_elems) {
                                                /** pair is contained */
                                                desc->num_reads_hit++;
                                                handle->is_contained = true;
                                                handle->value = slice->string_id_column[pairPosition];
                                                handle->key = needle;
                                                handle->container = slice;

                                                desc->num_reads_hit++;
                                                return true;
                                        }
                                } else {
                                        /** bitmap is sure that pair is not contained */
                                        continue;
                                }
                        } else {
                                /** keys hash is not inside bounds of hashes in slice */
                                continue;
                        }
                }
        }

        handle->is_contained = false;

        return false;
}

bool slice_list_remove(slice_list_t *list, slice_handle *handle)
{
        UNUSED(list);
        UNUSED(handle);
        return ERROR(ERR_NOTIMPLEMENTED, NULL);
}

static void appenderNew(slice_list_t *list)
{
        /** ANTI-OPTIMIZATION: madvising sequential access to columns in slice decrease performance */

        /** the slice itself */
        slice slice = {.strat     = SLICE_LOOKUP_SCAN, .num_elems = 0, .cache_idx = (u32) -1};

        u32 numSlices = VEC_LENGTH(&list->slices);
        vec_push(&list->slices, &slice, 1);

        assert(SLICE_KEY_COLUMN_MAX_ELEMS > 0);

        /** the descriptor */
        slice_descriptor desc = {.num_reads_hit  = 0, .num_reads_all  = 0,};

        vec_push(&list->descriptors, &desc, 1);

        /** the lookup guards */
        assert(sizeof(bitmap) <= SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE);
        bitmap filter;

        /** NOTE: the size of each bitmap lead to a false positive probability of 100%, i.e., number of items in the
         * slice is around 32644 depending on the CPU cache size, the number of actual bits in the filter (Cache line size
         * in bits minus the header for the bitmap) along with the number of used hash functions (4), lead to that
         * probability. However, the reason a bitmap is used is to skip slices whch definitively do NOT contain the
         * keys-values pair - and that still works ;) */
        bloom_create(&filter,
                         (SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE - sizeof(bitmap)) * 8);
        vec_push(&list->filters, &filter, 1);
        hash_bounds bounds = {.min_hash        = (hash32_t) -1, .max_hash        = (hash32_t) 0};
        vec_push(&list->bounds, &bounds, 1);

        INFO(SLICE_LIST_TAG,
                 "created new appender in slice list %p\n\t"
                 "# of slices (incl. appender) in total...............: %zu\n\t"
                 "slice target memory size............................: %zuB (%s)\n\t"
                 "bitmap target memory size......................: %zuB (%s)\n\t"
                 "Max # of (keys, hash, str_buf) in appender/slice......: %zu\n\t"
                 "Bits used in per-slice bitmap..................: %zu\n\t"
                 "Prob. of bitmap to produce false-positives.....: %f\n\t"
                 "Single slice type size..............................: %zuB\n\t"
                 "Total slice-list size...............................: %f MiB",
                 list,
                 list->slices.num_elems,
                 (size_t) SLICE_LIST_TARGET_MEMORY_SIZE_IN_BYTE,
                 SLICE_LIST_TARGET_MEMORY_NAME,
                 (size_t) SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE,
                 SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_NAME,
                 (size_t) SLICE_KEY_COLUMN_MAX_ELEMS,
                 bitmap_nbits(&filter),
                 (pow(1 - exp(-(double) bloom_nhashs()
                              / ((double) bitmap_nbits(&filter) / (double) SLICE_KEY_COLUMN_MAX_ELEMS)),
                      bitmap_nbits(&filter))),
                 sizeof(slice),
                 (sizeof(slice_list_t) + list->slices.num_elems
                                         * (sizeof(slice) + sizeof(slice_descriptor) +
                                            (sizeof(u32) * list->descriptors.num_elems)
                                            + sizeof(bitmap) + bitmap_nbits(&filter) / 8 +
                                            sizeof(hash_bounds))) /
                 1024.0 / 1024.0);

        /** register new slice as the current appender */
        list->appender_idx = numSlices;
}

static void appenderSeal(slice *slice)
{
        UNUSED(slice);
        // TODO: sealing means sort and then replace 'find' with bsearch or something.
        // Not yet implemented: sealed slices are also search in a linear fashion
}

static void _slicelist_lock(slice_list_t *list)
{
        spinlock_acquire(&list->lock);
}

static void _slicelist_unlock(slice_list_t *list)
{
        spinlock_release(&list->lock);
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/stdx/unique_id.h>
#include <karbonit/utils/time.h>
#include <karbonit/error.h>
#include <karbonit/std/hash.h>

_Thread_local bool thread_local_init;

_Thread_local u64 thread_local_id;

_Thread_local u8 thread_local_magic;

_Thread_local u32 thread_local_counter;

_Thread_local u32 thread_local_counter_limit;

/**
 * Below is the best effort to create a world-unique, fast and scalable to compute identifier.
 *
 * An 64bit global identifier is constructed using process-local, thread-local and
 * call-local state-dependent and state-independent components. Additionally, a global time
 * component is added to minimize the risk of producing two equal identifier across multiple
 * machines.
 */
union global_id {
        struct {
                /** global */
                u64 global_wallclock
                        : 5;   /** increasing wall clock time (ms) */
                u64 global_build_date
                        : 1;   /** fix bit dependent on compilation time */
                u64 global_build_path
                        : 1;   /** fix bit dependent on compilation path */

                /** per-process */
                u64 process_id
                        : 7;   /** fix id */
                u64 process_magic
                        : 2;   /** random fix value */
                u64 process_counter
                        : 8;   /** increasing counter */

                /** per-thread  */
                u64 thread_id
                        : 7;   /** fix id */
                u64 thread_magic
                        : 2;   /** random fix value */
                u64 thread_counter
                        : 29;  /** increasing counter (< 536mio ids per thread) */

                /** per-call */
                u64 call_random
                        :  2;  /** random value */
        };

        u64 value;
};

bool unique_id_create(unique_id_t *out)
{
        assert(out);

        static bool process_init;
        static u64 process_local_id;
        static u8 process_magic;
        static u64 process_counter;

        static u8 global_build_date_bit;
        static u8 global_build_path_bit;

        if (!process_init) {
                srand(time(NULL));
                process_magic = rand();
                process_init = true;
                process_counter = rand();

                const char *file = __FILE__;
                const char *time = __TIME__;

                global_build_path_bit = HASH_BERNSTEIN(strlen(file), file) % 2;
                global_build_date_bit = HASH_BERNSTEIN(strlen(time), time) % 2;
        }

        if (!thread_local_init) {
                thread_local_counter = rand();
                thread_local_counter_limit = thread_local_counter++;
                thread_local_id = (u64) pthread_self();
                process_local_id = getpid();
                thread_local_magic = rand();
                thread_local_init = true;
        }

        bool capacity_left = (thread_local_counter != thread_local_counter_limit);
        if (LIKELY(capacity_left)) {
                union global_id internal =
                        {.global_wallclock  = wallclock(),
                                .global_build_date = global_build_date_bit,
                                .global_build_path = global_build_path_bit,
                                .process_id        = process_local_id,
                                .process_magic     = process_magic,
                                .process_counter   = process_counter++,
                                .thread_id         = (u64) thread_local_id,
                                .thread_magic      = thread_local_magic,
                                .thread_counter    = thread_local_counter++,
                                .call_random       = rand()};
                *out = internal.value;
        } else {
                *out = 0;
        }
        return capacity_left;
}

bool unique_id_get_global_wallclocktime(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->global_wallclock;
        return true;
}

bool unique_id_get_global_build_path_bit(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->global_build_path;
        return true;
}

bool unique_id_get_global_build_time_bit(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->global_build_date;
        return true;
}

bool unique_id_get_process_id(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->process_id;
        return true;
}

bool unique_id_get_process_magic(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->process_magic;
        return true;
}

bool unique_id_get_process_counter(uint_fast16_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->process_counter;
        return true;
}

bool unique_id_get_thread_id(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->thread_id;
        return true;
}

bool unique_id_get_thread_magic(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->thread_magic;
        return true;
}

bool unique_id_get_thread_counter(uint_fast32_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->thread_counter;
        return true;
}

bool unique_id_get_call_random(uint_fast8_t *out, unique_id_t id)
{
        *out = ((union global_id *) &id)->call_random;
        return true;
}


/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>

#include <karbonit/utils/convert.h>

i64 convert_atoi64(const char *string)
{
        i64 number;
        char character;
        int status = sscanf(string, "%" SCNd64 "%c", &number, &character);
        if (status == 1) {
                return number;
        } else if (status > 1) {
                return number;
        } else {
                return 0;
        }
}

u64 convert_atoiu64(const char *string)
{
        u64 number;
        char character;
        int status = sscanf(string, "%" SCNu64 "%c", &number, &character);
        if (status == 1) {
                return number;
        } else if (status > 1) {
                return number;
        } else {
                return 0;
        }
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/utils/numbers.h>

num_type_e num_min_type_unsigned(u64 value)
{
        if (value <= CARBON_U8_MAX) {
                return NUM_U8;
        } else if (value <= CARBON_U16_MAX) {
                return NUM_U16;
        } else if (value <= CARBON_U32_MAX) {
                return NUM_U32;
        } else if (value <= CARBON_U64_MAX) {
                return NUM_U64;
        } else {
                return NUM_UNKNOWN;
        }
}

num_type_e num_min_type_signed(i64 value)
{
        if (value >= CARBON_I8_MIN && value <= CARBON_I8_MAX) {
                return NUM_I8;
        } else if (value >= CARBON_I16_MIN && value <= CARBON_I16_MAX) {
                return NUM_I16;
        } else if (value >= CARBON_I32_MIN && value <= CARBON_I32_MAX) {
                return NUM_I32;
        } else if (value >= CARBON_I64_MIN && value <= CARBON_I64_MAX) {
                return NUM_I64;
        } else {
                return NUM_UNKNOWN;
        }
}

/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdlib.h>
#include <karbonit/std/string.h>

#include <karbonit/utils/priority_queue.h>

void priority_queue_init(priority_queue *queue)
{
        queue->num_elements = 0;
        pthread_mutex_init(&queue->mutex, NULL);
        queue->capacity = 0;
        queue->data = NULL;
}

void priority_queue_free(priority_queue *queue)
{
        free(queue->data);
}

void priority_queue_resize(priority_queue *queue, size_t size)
{
        priority_queue_element_info *new_data = MALLOC(sizeof(priority_queue_element_info) * size);

        memcpy(new_data, queue->data, sizeof(priority_queue_element_info) * queue->num_elements);
        free(queue->data);

        queue->data = new_data;
}

inline static void swap(priority_queue_element_info *el1, priority_queue_element_info *el2)
{
        priority_queue_element_info tmp = *el1;
        *el1 = *el2;
        *el2 = tmp;
}

static void down_heap(priority_queue_element_info *heap, size_t size)
{
        size_t cur = 0;
        size_t id = 1;
        for (size_t next = 3;; next = (next << 1) + 1) {
                size_t min = 0xffffffff;
                size_t minId = 0;
                while (id != next && id < size) {
                        if (heap[id].priority < min) {
                                min = heap[id].priority;
                                minId = id;
                        }
                        ++id;
                }
                if (heap[cur].priority <= heap[minId].priority) { break; }
                swap(&heap[cur], &heap[minId]);
                cur = minId;
                if (id == size) { break; }
        }
}

static void up_heap(priority_queue_element_info *heap, size_t size)
{
        if (size == 1) { return; }
        size_t log = 31 - __builtin_clz(size);

        size_t begin = 1 << (log - 1);
        size_t cur = size - 1;

        for (;;) {
                size_t end = (begin << 1) + 1;
                if (end > size) { end = size; }
                size_t max = heap[begin].priority;
                size_t id = begin;
                for (size_t i = begin + 1; i < end; ++i) {
                        if (heap[i].priority >= max) {
                                max = heap[i].priority;
                                id = i;
                        }
                }
                if (heap[id].priority <= heap[cur].priority) { break; }
                else {
                        swap(&heap[cur], &heap[id]);
                        cur = id;
                }
                if (!begin) { break; }
                begin >>= 1;
        }
}

void priority_queue_push(priority_queue *queue, void *data, size_t priority)
{
        pthread_mutex_lock(&queue->mutex);

        if (queue->num_elements >= queue->capacity) {
                priority_queue_resize(queue, ((queue->num_elements + 1) * 3) / 2);
        }

        queue->data[queue->num_elements].element = data;
        queue->data[queue->num_elements].priority = priority;
        ++queue->num_elements;
        up_heap(queue->data, queue->num_elements);

        pthread_mutex_unlock(&queue->mutex);
}

void *priority_queue_pop(priority_queue *queue)
{
        pthread_mutex_lock(&queue->mutex);

        void *ptr = NULL;

        if (queue->num_elements) {
                --queue->num_elements;

                ptr = queue->data[0].element;
                queue->data[0] = queue->data[queue->num_elements];
                down_heap(queue->data, queue->num_elements + 1);
        }

        pthread_mutex_unlock(&queue->mutex);
        return ptr;
}

int priority_queue_is_empty(priority_queue *queue)
{
        pthread_mutex_lock(&queue->mutex);

        int result = !queue->num_elements;

        pthread_mutex_unlock(&queue->mutex);
        return result;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <karbonit/utils/sort.h>
#include <karbonit/types.h>

bool sort_qsort_indicies(size_t *indices, const void *base, size_t width, less_eq_func_t comp,
                         size_t nelemns)
{
        if (nelemns <= 1) {
                return true;
        }

        i64 h = nelemns - 1;
        i64 *stack = (i64 *) MALLOC((h + 1) * sizeof(i64));
        i64 top = -1;
        i64 l = 0;

        stack[++top] = l;
        stack[++top] = h;

        while (top >= 0) {
                h = stack[top--];
                l = stack[top--];

                i64 p = QSORT_INDICIES_PARTITION(indices, base, width, comp, l, h);

                if (p - 1 > l) {
                        stack[++top] = l;
                        stack[++top] = p - 1;
                }

                if (p + 1 < h) {
                        stack[++top] = p + 1;
                        stack[++top] = h;
                }
        }

        free(stack);
        return true;
}

int sort_qsort_indicies_wargs(size_t *indices, const void *base, size_t width, less_eq_wargs_func_t comp,
                              size_t nelemens, void *args)
{
        if (nelemens <= 1) {
                return true;
        }

        i64 h = nelemens - 1;
        i64 *stack = MALLOC((h + 1) * sizeof(i64));
        assert (stack);

        i64 top = -1;
        i64 l = 0;

        stack[++top] = l;
        stack[++top] = h;

        while (top >= 0) {
                h = stack[top--];
                l = stack[top--];

                i64 p = QSORT_INDICIES_PARTITION_WARGS(indices, base, width, comp, l, h, args);

                if (p - 1 > l) {
                        stack[++top] = l;
                        stack[++top] = p - 1;
                }

                if (p + 1 < h) {
                        stack[++top] = p + 1;
                        stack[++top] = h;
                }
        }

        free(stack);
        return true;
}

size_t sort_bsearch_indicies(const size_t *indicies, const void *base, size_t width, size_t nelemens,
                             const void *neelde, eq_func_t compEq, less_func_t compLess)
{
        size_t l = 0;
        size_t r = nelemens - 1;
        while (l <= r && r < SIZE_MAX) {
                size_t m = l + (r - l) / 2;

                // Check if x is present at mid
                if (compEq(base + indicies[m] * width, neelde)) {
                        return m;
                }

                // If x greater, ignore left half
                if (compLess(base + indicies[m] * width, neelde)) {
                        l = m + 1;

                        // If x is smaller, ignore right half
                } else {
                        r = m - 1;
                }
        }

        // if we reach here, then element was
        // not present
        return nelemens;
}

size_t sort_get_min(const size_t *elements, size_t nelemens)
{
        size_t min = (size_t) -1;
        while (nelemens--) {
                min = min < *elements ? min : *elements;
                elements++;
        }
        return min;
}

size_t sort_get_max(const size_t *elements, size_t nelemens)
{
        size_t max = 0;
        while (nelemens--) {
                max = max > *elements ? max : *elements;
                elements++;
        }
        return max;
}

double sort_get_sum(const size_t *elements, size_t nelemens)
{
        double sum = 0;
        while (nelemens--) {
                sum += *elements;
                elements++;
        }
        return sum;
}

double sort_get_avg(const size_t *elements, size_t nelemens)
{
        return sort_get_sum(elements, nelemens) / (double) nelemens;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <ctype.h>
#include <karbonit/utils/strings.h>

bool strings_contains_blank_char(const char *str)
{
        if (LIKELY(str != NULL)) {
                for (const char *it = str; *it != '\0'; it++) {
                        if (isspace(*it)) {
                                return true;
                        }
                }
                return false;
        } else {
                return false;
        }
}

bool strings_is_enquoted(const char *str)
{
        return strings_is_enquoted_wlen(str, strlen(str));
}

bool strings_is_enquoted_wlen(const char *str, size_t len)
{
        if (*str == '"') {
                if (len > 1) {
                        return str[len - 1] == '"';
                } else {
                        return false;
                }
        } else {
                return false;
        }
}

char *strings_remove_tailing_blanks(char *str_in)
{
        size_t sl = strlen(str_in);
        size_t i = sl > 0 ? sl - 1 : 0;
        while (i) {
                char c = str_in[i];
                if (isblank(c)) {
                        str_in[i] = '\0';
                } else {
                        break;
                }
                i--;
        }
        return str_in;
}

const char *strings_skip_blanks(const char *str)
{
        if (LIKELY(str != NULL)) {
                const char *ret = str;
                while (*ret != '\0') {
                        char c = *ret;
                        if (LIKELY(!isblank(c))) {
                                return ret;
                        }
                        ret++;
                }
                return ret;
        } else {
                return NULL;
        }
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>

#include <karbonit/utils/time.h>

timestamp wallclock()
{
        long ms;
        time_t s;
        struct timespec spec;
        clock_gettime(CLOCK_REALTIME, &spec);
        s = spec.tv_sec;
        ms = round(spec.tv_nsec / 1.0e6);
        return s * 1000 + ((ms > 999) ? 1000 : ms);
}